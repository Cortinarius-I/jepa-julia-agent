"""
    Executor

The executor applies actions to the codebase.
This is where transformers get invoked - but ONLY for filling in code templates,
never for planning or reasoning about what to do.

Key principle: The executor is deterministic given an action and a code fragment.
Uncertainty is confined to the JEPA prediction and the transformer completion.
"""
module Executor

export execute_action, ExecutionResult, ExecutionContext
export render_code_fragment, CodeFragment

using ..WorldState
using ..Actions

# ============================================================================
# Execution Context
# ============================================================================

"""
    CodeFragment

A small piece of code to be generated by a transformer.
This is the ONLY place where transformers are invoked.
"""
struct CodeFragment
    template::String           # Template with {{HOLE}} markers
    context_before::String     # Code context before the hole
    context_after::String      # Code context after the hole
    constraints::Dict{Symbol, Any}  # Type constraints, naming conventions, etc.
    max_tokens::Int            # Hard limit on generated tokens
end

"""
    ExecutionContext

Context for executing actions.
"""
struct ExecutionContext
    repo_path::String
    dry_run::Bool
    transformer_endpoint::String  # URL for transformer API
    max_retries::Int
    validate_after::Bool  # Run validation after execution
end

function ExecutionContext(repo_path::String; 
                          dry_run::Bool=false,
                          transformer_endpoint::String="http://localhost:8000/render",
                          max_retries::Int=3,
                          validate_after::Bool=true)
    ExecutionContext(repo_path, dry_run, transformer_endpoint, max_retries, validate_after)
end

# ============================================================================
# Execution Result
# ============================================================================

"""
    ExecutionResult

The result of executing an action.
"""
struct ExecutionResult
    success::Bool
    action::Action
    before_state::WorldStateSnapshot
    after_state::Union{WorldStateSnapshot, Nothing}
    modified_files::Vector{String}
    generated_fragments::Vector{Tuple{CodeFragment, String}}  # (fragment, generated)
    validation_errors::Vector{String}
    error_message::Union{String, Nothing}
end

function ExecutionResult(; success::Bool,
                          action::Action,
                          before_state::WorldStateSnapshot,
                          after_state::Union{WorldStateSnapshot, Nothing}=nothing,
                          modified_files::Vector{String}=String[],
                          generated_fragments::Vector{Tuple{CodeFragment, String}}=Tuple{CodeFragment, String}[],
                          validation_errors::Vector{String}=String[],
                          error_message::Union{String, Nothing}=nothing)
    ExecutionResult(success, action, before_state, after_state, 
                    modified_files, generated_fragments, validation_errors, error_message)
end

# ============================================================================
# Code Fragment Rendering (Transformer Invocation)
# ============================================================================

"""
    render_code_fragment(fragment::CodeFragment, ctx::ExecutionContext) -> String

Invoke the transformer to fill in a code fragment.
This is the ONLY function that calls the transformer.

The transformer receives:
- The template with holes
- Surrounding context
- Type constraints
- Token limit

It returns ONLY the code to fill the hole, nothing else.
"""
function render_code_fragment(fragment::CodeFragment, ctx::ExecutionContext)
    # Build the prompt for the transformer
    prompt = build_render_prompt(fragment)
    
    if ctx.dry_run
        return "# DRY RUN: Would generate code here"
    end
    
    # Call the transformer endpoint
    # In production, this would be an HTTP call
    # For now, return a placeholder
    
    generated = call_transformer(prompt, ctx)
    
    # Validate the generated code
    if !validate_fragment(generated, fragment)
        error("Generated code does not satisfy constraints")
    end
    
    generated
end

"""
    build_render_prompt(fragment::CodeFragment) -> String

Build the prompt for the transformer.
The prompt is highly constrained - we're asking for code completion, not generation.
"""
function build_render_prompt(fragment::CodeFragment)
    prompt = """
    Fill in the {{HOLE}} in the following Julia code template.
    Return ONLY the code that goes in the hole, nothing else.
    
    CONSTRAINTS:
    """
    
    for (k, v) in fragment.constraints
        prompt *= "- $k: $v\n"
    end
    
    prompt *= """
    
    CONTEXT BEFORE:
    ```julia
    $(fragment.context_before)
    ```
    
    TEMPLATE:
    ```julia
    $(fragment.template)
    ```
    
    CONTEXT AFTER:
    ```julia
    $(fragment.context_after)
    ```
    
    CODE TO FILL HOLE (max $(fragment.max_tokens) tokens):
    """
    
    prompt
end

"""
    call_transformer(prompt::String, ctx::ExecutionContext) -> String

Make the actual call to the transformer endpoint.
"""
function call_transformer(prompt::String, ctx::ExecutionContext)
    # TODO: Implement HTTP call to transformer endpoint
    # For now, return placeholder
    "# TODO: Transformer-generated code"
end

"""
    validate_fragment(generated::String, fragment::CodeFragment) -> Bool

Validate that generated code satisfies constraints.
"""
function validate_fragment(generated::String, fragment::CodeFragment)
    # Check token count
    if length(split(generated)) > fragment.max_tokens
        return false
    end
    
    # Check syntax (try to parse)
    try
        Meta.parse(generated)
    catch
        return false
    end
    
    # Check type constraints if specified
    # TODO: More sophisticated validation
    
    true
end

# ============================================================================
# Action Execution
# ============================================================================

"""
    execute_action(action::Action, ctx::ExecutionContext) -> ExecutionResult

Execute an action in the given context.
"""
function execute_action(action::Action, ctx::ExecutionContext)
    # Get current state
    before_state = extract_world_state(ctx.repo_path)
    
    # Validate action
    valid, error_msg = validate_action(action, before_state)
    if !valid
        return ExecutionResult(
            success=false,
            action=action,
            before_state=before_state,
            error_message=error_msg
        )
    end
    
    # Execute based on action type
    result = try
        execute_typed_action(action, before_state, ctx)
    catch e
        return ExecutionResult(
            success=false,
            action=action,
            before_state=before_state,
            error_message=string(e)
        )
    end
    
    result
end

"""
    execute_typed_action(action::Action, state::WorldStateSnapshot, ctx::ExecutionContext)

Dispatch to the appropriate executor for each action type.
"""
function execute_typed_action(action::AddMethodAction, state::WorldStateSnapshot, ctx::ExecutionContext)
    modified_files = String[]
    generated_fragments = Tuple{CodeFragment, String}[]
    
    # Find insertion point
    file_path, line = determine_insertion_point(action, state, ctx)
    
    # Create code fragment for the method body
    fragment = CodeFragment(
        action.body_template,
        get_context_before(file_path, line, ctx),
        get_context_after(file_path, line, ctx),
        Dict(:function_name => action.function_name,
             :signature => action.signature,
             :module => action.target_module),
        500  # Max tokens for method body
    )
    
    # Render the code
    generated_code = render_code_fragment(fragment, ctx)
    push!(generated_fragments, (fragment, generated_code))
    
    # Build the full method definition
    method_def = build_method_definition(action, generated_code)
    
    # Insert into file
    if !ctx.dry_run
        insert_code_at(file_path, line, method_def)
        push!(modified_files, file_path)
    end
    
    # Get new state
    after_state = ctx.dry_run ? nothing : extract_world_state(ctx.repo_path)
    
    # Validate if requested
    validation_errors = String[]
    if ctx.validate_after && !ctx.dry_run
        validation_errors = validate_execution(before_state, after_state, action)
    end
    
    ExecutionResult(
        success=isempty(validation_errors),
        action=action,
        before_state=state,
        after_state=after_state,
        modified_files=modified_files,
        generated_fragments=generated_fragments,
        validation_errors=validation_errors
    )
end

# Default implementation for other action types
function execute_typed_action(action::Action, state::WorldStateSnapshot, ctx::ExecutionContext)
    @warn "No specialized executor for $(typeof(action)), using default"
    
    ExecutionResult(
        success=false,
        action=action,
        before_state=state,
        error_message="Executor not implemented for $(typeof(action))"
    )
end

# ============================================================================
# Helper Functions
# ============================================================================

function determine_insertion_point(action::AddMethodAction, state::WorldStateSnapshot, ctx::ExecutionContext)
    if action.insertion_point !== nothing
        return action.insertion_point
    end
    
    # Find the module file and a good insertion point
    # TODO: Implement smart insertion point detection
    ("$(ctx.repo_path)/src/main.jl", 1)
end

function get_context_before(file_path::String, line::Int, ctx::ExecutionContext)
    # Read lines before insertion point
    lines = readlines(file_path)
    start_line = max(1, line - 20)
    join(lines[start_line:min(line-1, length(lines))], "\n")
end

function get_context_after(file_path::String, line::Int, ctx::ExecutionContext)
    # Read lines after insertion point
    lines = readlines(file_path)
    end_line = min(length(lines), line + 20)
    join(lines[line:end_line], "\n")
end

function build_method_definition(action::AddMethodAction, body::String)
    sig = action.signature
    args = join(["$(a)" for a in sig.arg_types], ", ")
    
    """
    function $(sig.name)($(args))
        $body
    end
    """
end

function insert_code_at(file_path::String, line::Int, code::String)
    lines = readlines(file_path)
    insert!(lines, line, code)
    write(file_path, join(lines, "\n"))
end

function validate_execution(before::WorldStateSnapshot, after::WorldStateSnapshot, action::Action)
    errors = String[]
    
    # Check tests still pass
    for test in after.tests.results
        if !test.passed
            # Check if this test was passing before
            for old_test in before.tests.results
                if old_test.name == test.name && old_test.passed
                    push!(errors, "Test $(test.name) now failing: $(test.error_message)")
                end
            end
        end
    end
    
    # Check no unexpected invalidations
    if length(after.invalidations.recent_events) > length(before.invalidations.recent_events)
        push!(errors, "Action caused unexpected method invalidations")
    end
    
    errors
end

end # module
