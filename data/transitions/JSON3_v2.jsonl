{"repo": "JSON3.jl", "commit_sha": "e95b748ba1cfbc863263e79e5046c929450fae5a", "parent_sha": "fb220e513d8c43e6a698e2c863da2a5e9bcab2e3", "commit_message": "Remove inappropriate `@boundscheck` (#311)", "commit_date": "2025-05-23T15:17:26+02:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::AbstractArray) = isempty(x) ? 2 : sum(defaultminimum, (isassigned(x, i) ? defaultminimum(x[i]) : 4 for i in eachindex(x)))\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::SingletonType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::AbstractArray; kw...)\n    @writechar '['\n    n = 0\n    for i in eachindex(x)\n        if isassigned(x, i)\n            y = x[i]\n            buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        else\n            buf, pos, len = write(NullType(), buf, pos, len, nothing; kw...)\n        end\n        @writechar ','\n        n += 1\n    end\n    if n > 0\n        # for non-empty arrays, we eagerly write a comma after each element\n        # so backtrack one pos where we'll write ']'\n        pos -= 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\nwrite(::SingletonType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, x; kw...)\n\n# adapted from base/intfuncs.jl\n_split_sign(x) = Base.split_sign(x)\n_split_sign(x::BigInt) = (abs(x), x < 0)\n\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = _split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\n# default fallback for non-Integer/non-AbstractFloat numbers\n# conver to Float64 and write the string representation\n\"\"\"\n    JSON3.tostring(x::Real) -> String\n\nFor some number types that are `<: Real`, but not `<: Integer` or `<: AbstractFloat`,\n`tostring` provides an overload to convert `x` to an appropriate string representation\nwhich will be used for the JSON numeric representation. By default, `x` is converted\nto a `Float64` and then to a `String`.\n\"\"\"\ntostring(x::Real) = Base.string(convert(Float64, x))\n\nfunction write(::NumberType, buf, pos, len, x::T; kw...) where {T}\n    NT = StructTypes.numbertype(T)\n    if NT === T\n        # this means T hasn't overloaded numbertype\n        # and we can't StructTypes.construct since we'll just stack overflow\n        # so we call last-chance tostring that can be overloaded\n        bytes = codeunits(tostring(x))\n        sz = sizeof(bytes)\n        @check sz\n        for i = 1:sz\n            @inbounds @writechar bytes[i]\n        end\n\n        return buf, pos, len\n    else\n        write(NumberType(), buf, pos, len, StructTypes.construct(NT, x); kw...)\n    end\nend\n\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Ryu.neededdigits(T)\n    pos = Ryu.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::AbstractArray) = isempty(x) ? 2 : sum(defaultminimum, (isassigned(x, i) ? defaultminimum(x[i]) : 4 for i in eachindex(x)))\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::SingletonType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::AbstractArray; kw...)\n    @writechar '['\n    n = 0\n    for i in eachindex(x)\n        if isassigned(x, i)\n            y = x[i]\n            buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        else\n            buf, pos, len = write(NullType(), buf, pos, len, nothing; kw...)\n        end\n        @writechar ','\n        n += 1\n    end\n    if n > 0\n        # for non-empty arrays, we eagerly write a comma after each element\n        # so backtrack one pos where we'll write ']'\n        pos -= 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\nwrite(::SingletonType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, x; kw...)\n\n# adapted from base/intfuncs.jl\n_split_sign(x) = Base.split_sign(x)\n_split_sign(x::BigInt) = (abs(x), x < 0)\n\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = _split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\n# default fallback for non-Integer/non-AbstractFloat numbers\n# conver to Float64 and write the string representation\n\"\"\"\n    JSON3.tostring(x::Real) -> String\n\nFor some number types that are `<: Real`, but not `<: Integer` or `<: AbstractFloat`,\n`tostring` provides an overload to convert `x` to an appropriate string representation\nwhich will be used for the JSON numeric representation. By default, `x` is converted\nto a `Float64` and then to a `String`.\n\"\"\"\ntostring(x::Real) = Base.string(convert(Float64, x))\n\nfunction write(::NumberType, buf, pos, len, x::T; kw...) where {T}\n    NT = StructTypes.numbertype(T)\n    if NT === T\n        # this means T hasn't overloaded numbertype\n        # and we can't StructTypes.construct since we'll just stack overflow\n        # so we call last-chance tostring that can be overloaded\n        bytes = codeunits(tostring(x))\n        sz = sizeof(bytes)\n        @check sz\n        for i = 1:sz\n            @inbounds @writechar bytes[i]\n        end\n\n        return buf, pos, len\n    else\n        write(NumberType(), buf, pos, len, StructTypes.construct(NT, x); kw...)\n    end\nend\n\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Ryu.neededdigits(T)\n    pos = Ryu.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 28, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "737f6f482a9811bc2f741656c2f13e74831841b0", "parent_sha": "ce90511530d6ee0fddb6998b169e3329fd35b789", "commit_message": "add `parse` and `parsefile` functions (#302)", "commit_date": "2024-12-17T00:06:07-05:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/read.jl", "target_symbol": "read", "signature": null, "confidence": 0.75}, "files_before": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::Union{IO, Base.AbstractCmd}; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\n\"\"\"\n    JSON3.read(json, [type]; kw... )\n\nRead JSON.\n\n## Args\n\n* `json`: A file, string, IO, or bytes (`AbstractVector{UInt8`) containing JSON to read\n* `type`: Optionally, a type to read the JSON into. If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `jsonlines`: A Bool indicating that the `json_str` contains newline delimited JSON strings, which will be read into a `JSON3.Array` of the JSON values.  See [jsonlines](https://jsonlines.org/) for reference. [default `false`]\n* `allow_inf`: Allow reading of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing the format of dates in the JSON so that they can be read into `Date`s, `Time`s, or `DateTime`s when reading into a type. [default `Dates.default_format(T)`]\n* `parsequoted`: Accept quoted values when reading into a NumberType. [default `false`]\n* `numbertype`: Type to parse numbers as. [default `nothing`, which parses numbers as Int if possible, Float64 otherwise]\n* `ignore_extra_fields`: Ignore extra fields in the JSON when reading into a struct. [default `true`]\n\"\"\"\nfunction read(json::AbstractString; jsonlines::Bool=false,\n              numbertype::Union{DataType, Nothing}=nothing, kw...)\n\n    str = read_json_str(json)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if numbertype === nothing\n        checkint = true\n    elseif numbertype == Float64\n        checkint = false\n    else\n        throw(ArgumentError(\"numbertype $numbertype is not supported. \" *\n                            \"Only `nothing` (default) and `Float64` are supported so far.\"))\n    end\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1), checkint; kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any, checkint; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        obj = Object(buf, tape, Dict{Symbol, Int}())\n        populateinds!(obj)\n        return obj\n    elseif isarray(t)\n        arr = Array{geteltype(tape[2])}(buf, tape, Int[])\n        populateinds!(arr)\n        return arr\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nconst FLOAT_INT_BOUND = 2.0^53\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object, checkint; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array, checkint; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            !isfinite(float) && !allow_inf && @goto invalid\n            @check\n            # if, for example, we've already parsed floats in an array, just keep them all as floats and don't check for ints\n            if checkint\n                fp, ip = modf(float)\n                if fp == 0 && Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                    # ok great, we know the number is integral and pretty much in Int64 range\n                    if -FLOAT_INT_BOUND < float < FLOAT_INT_BOUND\n                        # easy case, integer w/ less than or equal to 53-bits of precision\n                        int = unsafe_trunc(Int64, float)\n                    else\n                        # if our integral float is > 53-bit precision, we need to reparse the Int so we don't get a lossy conversion\n                        # there are also a few floats that satisfy Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                        # that actually overflow Int64, like -9223372036854775809 and 9223372036854775808\n                        # in those cases, we're going to verify that this Int64 parsing doesn't overflow\n                        int, code, floatpos2 = Parsers.typeparser(Int64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n                        if floatpos2 < floatpos\n                            # ah, but there's one more case we need to handle: a > 53-bit precision integer given in\n                            # exponent form, like 1e17 or 9.007199254740994e15; in those cases, the truncation to Int64 *isn't* lossy\n                            int = unsafe_trunc(Int64, float)\n                        end\n                    end\n                    if code > 0\n                        @inbounds tape[tapeidx] = INT\n                        @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                        return floatpos, tapeidx + 2\n                    end\n                end\n            end\n            @inbounds tape[tapeidx] = FLOAT\n            @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}, checkint=true; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, checkint; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}, checkint=true; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        check_int = checkint ? eT != FLOAT && eT != (FLOAT | NULL) : false\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, check_int; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx, checkint=true; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        check_int = checkint ? eT != FLOAT && eT != (FLOAT | NULL) : false\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, check_int; kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n", "src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, SingletonType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::Union{IO, Base.AbstractCmd}, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(json::AbstractString, ::Type{T}) where {T}\n    str = read_json_str(json)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\nread(::NumberType, buf, pos, len, b, ::Type{Integer}; kw...) =\n    read(NumberType(), buf, pos, len, b, Int64; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\nfunction readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\nfunction read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    f.values[i] = y_i\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; ignore_extra_fields::Bool=true, kw...) where {T}\n    values = Vector{Any}(undef, fieldcount(T))\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            if ignore_extra_fields\n                pos, _ = read(Struct(), buf, pos, len, b, Any)\n            else\n                error = ExtraField\n                @goto invalid\n            end\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::Union{IO, Base.AbstractCmd}; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\n\"\"\"\n    JSON3.read(json, [type]; kw... )\n\nRead JSON.\n\n## Args\n\n* `json`: A file, string, IO, or bytes (`AbstractVector{UInt8`) containing JSON to read\n* `type`: Optionally, a type to read the JSON into. If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `jsonlines`: A Bool indicating that the `json_str` contains newline delimited JSON strings, which will be read into a `JSON3.Array` of the JSON values.  See [jsonlines](https://jsonlines.org/) for reference. [default `false`]\n* `allow_inf`: Allow reading of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing the format of dates in the JSON so that they can be read into `Date`s, `Time`s, or `DateTime`s when reading into a type. [default `Dates.default_format(T)`]\n* `parsequoted`: Accept quoted values when reading into a NumberType. [default `false`]\n* `numbertype`: Type to parse numbers as. [default `nothing`, which parses numbers as Int if possible, Float64 otherwise]\n* `ignore_extra_fields`: Ignore extra fields in the JSON when reading into a struct. [default `true`]\n\"\"\"\nfunction read(json::AbstractString; jsonlines::Bool=false,\n              numbertype::Union{DataType, Nothing}=nothing, kw...)\n    return parse(read_json_str(json); jsonlines, numbertype, kw...)\nend\n\nfunction parse(str::AbstractString; jsonlines::Bool=false,\n               numbertype::Union{DataType, Nothing}=nothing, kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if numbertype === nothing\n        checkint = true\n    elseif numbertype == Float64\n        checkint = false\n    else\n        throw(ArgumentError(\"numbertype $numbertype is not supported. \" *\n                            \"Only `nothing` (default) and `Float64` are supported so far.\"))\n    end\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1), checkint; kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any, checkint; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        obj = Object(buf, tape, Dict{Symbol, Int}())\n        populateinds!(obj)\n        return obj\n    elseif isarray(t)\n        arr = Array{geteltype(tape[2])}(buf, tape, Int[])\n        populateinds!(arr)\n        return arr\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction parsefile(fname::AbstractString; jsonlines::Bool=false,\n                   numbertype::Union{DataType, Nothing}=nothing, kw...)\n    return parse(VectorString(Mmap.mmap(fname)); jsonlines, numbertype, kw...)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nconst FLOAT_INT_BOUND = 2.0^53\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object, checkint; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array, checkint; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            !isfinite(float) && !allow_inf && @goto invalid\n            @check\n            # if, for example, we've already parsed floats in an array, just keep them all as floats and don't check for ints\n            if checkint\n                fp, ip = modf(float)\n                if fp == 0 && Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                    # ok great, we know the number is integral and pretty much in Int64 range\n                    if -FLOAT_INT_BOUND < float < FLOAT_INT_BOUND\n                        # easy case, integer w/ less than or equal to 53-bits of precision\n                        int = unsafe_trunc(Int64, float)\n                    else\n                        # if our integral float is > 53-bit precision, we need to reparse the Int so we don't get a lossy conversion\n                        # there are also a few floats that satisfy Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                        # that actually overflow Int64, like -9223372036854775809 and 9223372036854775808\n                        # in those cases, we're going to verify that this Int64 parsing doesn't overflow\n                        int, code, floatpos2 = Parsers.typeparser(Int64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n                        if floatpos2 < floatpos\n                            # ah, but there's one more case we need to handle: a > 53-bit precision integer given in\n                            # exponent form, like 1e17 or 9.007199254740994e15; in those cases, the truncation to Int64 *isn't* lossy\n                            int = unsafe_trunc(Int64, float)\n                        end\n                    end\n                    if code > 0\n                        @inbounds tape[tapeidx] = INT\n                        @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                        return floatpos, tapeidx + 2\n                    end\n                end\n            end\n            @inbounds tape[tapeidx] = FLOAT\n            @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}, checkint=true; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, checkint; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}, checkint=true; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        check_int = checkint ? eT != FLOAT && eT != (FLOAT | NULL) : false\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, check_int; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx, checkint=true; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        check_int = checkint ? eT != FLOAT && eT != (FLOAT | NULL) : false\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, check_int; kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n", "src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, SingletonType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::Union{IO, Base.AbstractCmd}, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction parse(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    return parse(read_json_str(str), T; jsonlines, kw...)\nend\n\nfunction parsefile(fname::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    return parse(VectorString(Mmap.mmap(fname)), T; jsonlines, kw...)\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(read_json_str(str), T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\nread(::NumberType, buf, pos, len, b, ::Type{Integer}; kw...) =\n    read(NumberType(), buf, pos, len, b, Int64; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\nfunction readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\nfunction read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    f.values[i] = y_i\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; ignore_extra_fields::Bool=true, kw...) where {T}\n    values = Vector{Any}(undef, fieldcount(T))\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            if ignore_extra_fields\n                pos, _ = read(Struct(), buf, pos, len, b, Any)\n            else\n                error = ExtraField\n                @goto invalid\n            end\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/read.jl", "src/structs.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 51, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "ce90511530d6ee0fddb6998b169e3329fd35b789", "parent_sha": "02e2ecf029d4b357b9de1dc80330a3c8f89eb364", "commit_message": "Add extra keyword argument for ignoring extra fields (#300)", "commit_date": "2024-12-17T06:06:00+01:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/JSON3.jl", "target_symbol": "read", "signature": null, "confidence": 0.75}, "files_before": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap, UUIDs, Dates, StructTypes\nusing Base: Ryu\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON object. Supports the `AbstractDict` interface. See [built in types](#Builtin-types) for more detail on why we have an `Object` type.\"\"\"\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\n    inds::Dict{Symbol, Int}\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(Int64(2)), 0], Dict{Symbol, Int}())\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON array. Supports the `AbstractArray` interface. See [built in types](#Builtin-types) for more detail on why we have an `Array` type.\"\"\"\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\n    inds::Vector{Int}\nend\n\nArray{T}(buf::S, tape::TT, inds::Vector{Int}) where {T, S, TT} = Array{T, S, TT}(buf, tape, inds)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\ngetinds(j::Union{Object, Array}) = getfield(j, :inds)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedClosingArrayChar ExpectedComma ExpectedSemiColon ExpectedNewline InvalidChar InvalidNumber\n\n# AbstractDict interface\nBase.length(obj::Object) = getnontypemask(gettape(obj)[2])\n\nfunction populateinds!(x::Object)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    i = 1\n    while i <= len\n        @inbounds t = tape[tapeidx]\n        key = getvalue(Symbol, buf, tape, tapeidx, t)\n        tapeidx += 2\n        inds[key] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\nfunction populateinds!(x::Array)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    resize!(inds, len)\n    i = 1\n    while i <= len\n        @inbounds inds[i] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    ind = getinds(obj)[key]\n    tape = gettape(obj)\n    @inbounds t = tape[ind]\n    return getvalue(Any, getbuf(obj), tape, ind, t)\nend\n\nBase.get(obj::Object, key) = get(obj, Symbol(key))\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    return get(obj, key)\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default\n    end\nend\n\nBase.get(obj::Object, key, default) = get(obj, Symbol(key), default)\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    return get(obj, key, default)\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default()\n    end\nend\n\nBase.get(default::Base.Callable, obj::Object, key) = get(default, obj, Symbol(key))\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, key) = get(obj, key)\n\n\"\"\"\n    copy(obj)\n\nRecursively copy [`JSON3.Object`](@ref)s to `Dict`s and [`JSON3.Array`](@ref)s to `Vector`s.  This copy can then be mutated if needed.\n\"\"\"\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = v isa Object || v isa Array ? copy(v) : v\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nBase.size(arr::Array) = (length(getinds(arr)),)\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    @inbounds ind = getinds(arr)[i]\n    @inbounds t = tape[ind]\n    return getvalue(T, buf, tape, ind, t)\nend\n\nBase.copy(arr::Array) = map(x->x isa Object || x isa Array ? copy(x) : x, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\ninclude(\"pretty.jl\")\ninclude(\"gentypes.jl\")\n\ninclude(\"workload.jl\")\n\nend # module\n", "src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::Union{IO, Base.AbstractCmd}; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\n\"\"\"\n    JSON3.read(json, [type]; kw... )\n\nRead JSON.\n\n## Args\n\n* `json`: A file, string, IO, or bytes (`AbstractVector{UInt8`) containing JSON to read\n* `type`: Optionally, a type to read the JSON into. If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `jsonlines`: A Bool indicating that the `json_str` contains newline delimited JSON strings, which will be read into a `JSON3.Array` of the JSON values.  See [jsonlines](https://jsonlines.org/) for reference. [default `false`]\n* `allow_inf`: Allow reading of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing the format of dates in the JSON so that they can be read into `Date`s, `Time`s, or `DateTime`s when reading into a type. [default `Dates.default_format(T)`]\n* `parsequoted`: Accept quoted values when reading into a NumberType. [default `false`]\n* `numbertype`: Type to parse numbers as. [default `nothing`, which parses numbers as Int if possible, Float64 otherwise]\n\"\"\"\nfunction read(json::AbstractString; jsonlines::Bool=false,\n              numbertype::Union{DataType, Nothing}=nothing, kw...)\n\n    str = read_json_str(json)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if numbertype === nothing\n        checkint = true\n    elseif numbertype == Float64\n        checkint = false\n    else\n        throw(ArgumentError(\"numbertype $numbertype is not supported. \" *\n                            \"Only `nothing` (default) and `Float64` are supported so far.\"))\n    end\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1), checkint; kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any, checkint; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        obj = Object(buf, tape, Dict{Symbol, Int}())\n        populateinds!(obj)\n        return obj\n    elseif isarray(t)\n        arr = Array{geteltype(tape[2])}(buf, tape, Int[])\n        populateinds!(arr)\n        return arr\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nconst FLOAT_INT_BOUND = 2.0^53\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object, checkint; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array, checkint; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            !isfinite(float) && !allow_inf && @goto invalid\n            @check\n            # if, for example, we've already parsed floats in an array, just keep them all as floats and don't check for ints\n            if checkint\n                fp, ip = modf(float)\n                if fp == 0 && Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                    # ok great, we know the number is integral and pretty much in Int64 range\n                    if -FLOAT_INT_BOUND < float < FLOAT_INT_BOUND\n                        # easy case, integer w/ less than or equal to 53-bits of precision\n                        int = unsafe_trunc(Int64, float)\n                    else\n                        # if our integral float is > 53-bit precision, we need to reparse the Int so we don't get a lossy conversion\n                        # there are also a few floats that satisfy Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                        # that actually overflow Int64, like -9223372036854775809 and 9223372036854775808\n                        # in those cases, we're going to verify that this Int64 parsing doesn't overflow\n                        int, code, floatpos2 = Parsers.typeparser(Int64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n                        if floatpos2 < floatpos\n                            # ah, but there's one more case we need to handle: a > 53-bit precision integer given in\n                            # exponent form, like 1e17 or 9.007199254740994e15; in those cases, the truncation to Int64 *isn't* lossy\n                            int = unsafe_trunc(Int64, float)\n                        end\n                    end\n                    if code > 0\n                        @inbounds tape[tapeidx] = INT\n                        @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                        return floatpos, tapeidx + 2\n                    end\n                end\n            end\n            @inbounds tape[tapeidx] = FLOAT\n            @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}, checkint=true; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, checkint; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}, checkint=true; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        check_int = checkint ? eT != FLOAT && eT != (FLOAT | NULL) : false\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, check_int; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx, checkint=true; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        check_int = checkint ? eT != FLOAT && eT != (FLOAT | NULL) : false\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, check_int; kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n", "src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, SingletonType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::Union{IO, Base.AbstractCmd}, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(json::AbstractString, ::Type{T}) where {T}\n    str = read_json_str(json)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\nread(::NumberType, buf, pos, len, b, ::Type{Integer}; kw...) =\n    read(NumberType(), buf, pos, len, b, Int64; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\nfunction readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\nfunction read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    f.values[i] = y_i\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, fieldcount(T))\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap, UUIDs, Dates, StructTypes\nusing Base: Ryu\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON object. Supports the `AbstractDict` interface. See [built in types](#Builtin-types) for more detail on why we have an `Object` type.\"\"\"\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\n    inds::Dict{Symbol, Int}\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(Int64(2)), 0], Dict{Symbol, Int}())\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON array. Supports the `AbstractArray` interface. See [built in types](#Builtin-types) for more detail on why we have an `Array` type.\"\"\"\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\n    inds::Vector{Int}\nend\n\nArray{T}(buf::S, tape::TT, inds::Vector{Int}) where {T, S, TT} = Array{T, S, TT}(buf, tape, inds)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\ngetinds(j::Union{Object, Array}) = getfield(j, :inds)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedClosingArrayChar ExpectedComma ExpectedSemiColon ExpectedNewline InvalidChar InvalidNumber ExtraField\n\n# AbstractDict interface\nBase.length(obj::Object) = getnontypemask(gettape(obj)[2])\n\nfunction populateinds!(x::Object)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    i = 1\n    while i <= len\n        @inbounds t = tape[tapeidx]\n        key = getvalue(Symbol, buf, tape, tapeidx, t)\n        tapeidx += 2\n        inds[key] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\nfunction populateinds!(x::Array)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    resize!(inds, len)\n    i = 1\n    while i <= len\n        @inbounds inds[i] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    ind = getinds(obj)[key]\n    tape = gettape(obj)\n    @inbounds t = tape[ind]\n    return getvalue(Any, getbuf(obj), tape, ind, t)\nend\n\nBase.get(obj::Object, key) = get(obj, Symbol(key))\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    return get(obj, key)\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default\n    end\nend\n\nBase.get(obj::Object, key, default) = get(obj, Symbol(key), default)\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    return get(obj, key, default)\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default()\n    end\nend\n\nBase.get(default::Base.Callable, obj::Object, key) = get(default, obj, Symbol(key))\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, key) = get(obj, key)\n\n\"\"\"\n    copy(obj)\n\nRecursively copy [`JSON3.Object`](@ref)s to `Dict`s and [`JSON3.Array`](@ref)s to `Vector`s.  This copy can then be mutated if needed.\n\"\"\"\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = v isa Object || v isa Array ? copy(v) : v\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nBase.size(arr::Array) = (length(getinds(arr)),)\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    @inbounds ind = getinds(arr)[i]\n    @inbounds t = tape[ind]\n    return getvalue(T, buf, tape, ind, t)\nend\n\nBase.copy(arr::Array) = map(x->x isa Object || x isa Array ? copy(x) : x, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\ninclude(\"pretty.jl\")\ninclude(\"gentypes.jl\")\n\ninclude(\"workload.jl\")\n\nend # module\n", "src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::Union{IO, Base.AbstractCmd}; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\n\"\"\"\n    JSON3.read(json, [type]; kw... )\n\nRead JSON.\n\n## Args\n\n* `json`: A file, string, IO, or bytes (`AbstractVector{UInt8`) containing JSON to read\n* `type`: Optionally, a type to read the JSON into. If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `jsonlines`: A Bool indicating that the `json_str` contains newline delimited JSON strings, which will be read into a `JSON3.Array` of the JSON values.  See [jsonlines](https://jsonlines.org/) for reference. [default `false`]\n* `allow_inf`: Allow reading of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing the format of dates in the JSON so that they can be read into `Date`s, `Time`s, or `DateTime`s when reading into a type. [default `Dates.default_format(T)`]\n* `parsequoted`: Accept quoted values when reading into a NumberType. [default `false`]\n* `numbertype`: Type to parse numbers as. [default `nothing`, which parses numbers as Int if possible, Float64 otherwise]\n* `ignore_extra_fields`: Ignore extra fields in the JSON when reading into a struct. [default `true`]\n\"\"\"\nfunction read(json::AbstractString; jsonlines::Bool=false,\n              numbertype::Union{DataType, Nothing}=nothing, kw...)\n\n    str = read_json_str(json)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if numbertype === nothing\n        checkint = true\n    elseif numbertype == Float64\n        checkint = false\n    else\n        throw(ArgumentError(\"numbertype $numbertype is not supported. \" *\n                            \"Only `nothing` (default) and `Float64` are supported so far.\"))\n    end\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1), checkint; kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any, checkint; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        obj = Object(buf, tape, Dict{Symbol, Int}())\n        populateinds!(obj)\n        return obj\n    elseif isarray(t)\n        arr = Array{geteltype(tape[2])}(buf, tape, Int[])\n        populateinds!(arr)\n        return arr\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nconst FLOAT_INT_BOUND = 2.0^53\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object, checkint; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array, checkint; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            !isfinite(float) && !allow_inf && @goto invalid\n            @check\n            # if, for example, we've already parsed floats in an array, just keep them all as floats and don't check for ints\n            if checkint\n                fp, ip = modf(float)\n                if fp == 0 && Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                    # ok great, we know the number is integral and pretty much in Int64 range\n                    if -FLOAT_INT_BOUND < float < FLOAT_INT_BOUND\n                        # easy case, integer w/ less than or equal to 53-bits of precision\n                        int = unsafe_trunc(Int64, float)\n                    else\n                        # if our integral float is > 53-bit precision, we need to reparse the Int so we don't get a lossy conversion\n                        # there are also a few floats that satisfy Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                        # that actually overflow Int64, like -9223372036854775809 and 9223372036854775808\n                        # in those cases, we're going to verify that this Int64 parsing doesn't overflow\n                        int, code, floatpos2 = Parsers.typeparser(Int64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n                        if floatpos2 < floatpos\n                            # ah, but there's one more case we need to handle: a > 53-bit precision integer given in\n                            # exponent form, like 1e17 or 9.007199254740994e15; in those cases, the truncation to Int64 *isn't* lossy\n                            int = unsafe_trunc(Int64, float)\n                        end\n                    end\n                    if code > 0\n                        @inbounds tape[tapeidx] = INT\n                        @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                        return floatpos, tapeidx + 2\n                    end\n                end\n            end\n            @inbounds tape[tapeidx] = FLOAT\n            @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}, checkint=true; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, checkint; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}, checkint=true; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        check_int = checkint ? eT != FLOAT && eT != (FLOAT | NULL) : false\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, check_int; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx, checkint=true; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        check_int = checkint ? eT != FLOAT && eT != (FLOAT | NULL) : false\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, check_int; kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n", "src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, SingletonType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::Union{IO, Base.AbstractCmd}, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(json::AbstractString, ::Type{T}) where {T}\n    str = read_json_str(json)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\nread(::NumberType, buf, pos, len, b, ::Type{Integer}; kw...) =\n    read(NumberType(), buf, pos, len, b, Int64; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\nfunction readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\nfunction read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    f.values[i] = y_i\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; ignore_extra_fields::Bool=true, kw...) where {T}\n    values = Vector{Any}(undef, fieldcount(T))\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            if ignore_extra_fields\n                pos, _ = read(Struct(), buf, pos, len, b, Any)\n            else\n                error = ExtraField\n                @goto invalid\n            end\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/JSON3.jl", "src/read.jl", "src/structs.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 20, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "5e4717e6c2579776e3ef36a0f1ab598b732d3d14", "parent_sha": "4856272072978d877edbb899b2739ffc998facf4", "commit_message": "Remove two inlines slowing down GLTF TTFX and bloating compiled dll size (#282)", "commit_date": "2024-10-17T01:38:51+03:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "readarray", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, SingletonType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::Union{IO, Base.AbstractCmd}, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(json::AbstractString, ::Type{T}) where {T}\n    str = read_json_str(json)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\nread(::NumberType, buf, pos, len, b, ::Type{Integer}; kw...) =\n    read(NumberType(), buf, pos, len, b, Int64; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    f.values[i] = y_i\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, fieldcount(T))\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, SingletonType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::Union{IO, Base.AbstractCmd}, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(json::AbstractString, ::Type{T}) where {T}\n    str = read_json_str(json)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\nread(::NumberType, buf, pos, len, b, ::Type{Integer}; kw...) =\n    read(NumberType(), buf, pos, len, b, Int64; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\nfunction readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\nfunction read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    f.values[i] = y_i\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, fieldcount(T))\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 4, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "4856272072978d877edbb899b2739ffc998facf4", "parent_sha": "b23ad48cfc2fc5eaa9d40cde990d07c957a22ddc", "commit_message": "handle lots of fields (#284)", "commit_date": "2024-10-17T00:38:24+02:00", "action": {"type": "REMOVE_FIELD", "target_file": "src/structs.jl", "target_symbol": "DEFAULT_STRUCT_FIELD_COUNT", "signature": null, "confidence": 0.75}, "files_before": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, SingletonType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::Union{IO, Base.AbstractCmd}, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(json::AbstractString, ::Type{T}) where {T}\n    str = read_json_str(json)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\nread(::NumberType, buf, pos, len, b, ::Type{Integer}; kw...) =\n    read(NumberType(), buf, pos, len, b, Int64; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, SingletonType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::Union{IO, Base.AbstractCmd}, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(json::AbstractString, ::Type{T}) where {T}\n    str = read_json_str(json)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\nread(::NumberType, buf, pos, len, b, ::Type{Integer}; kw...) =\n    read(NumberType(), buf, pos, len, b, Int64; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    f.values[i] = y_i\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, fieldcount(T))\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 12, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "0480e3f1d9e675b4ad2a5f9faf25033aa82ac869", "parent_sha": "717406d5da6c31cab398385a39941e7d511dda01", "commit_message": "add nested getindex to precompile (#271)", "commit_date": "2023-09-21T17:29:58-04:00", "action": {"type": "UNKNOWN", "target_file": "src/workload.jl", "target_symbol": null, "signature": null, "confidence": 0.1}, "files_before": {"src/workload.jl": "using PrecompileTools\n\n@compile_workload begin\n    str = \"\"\"{\"a\": 1, \"b\": \"hello, world\", \"c\": [1, 2], \"d\": true, \"e\": null, \"f\": 1.92}\"\"\"\n\n    JSON3.read(IOBuffer(str))\n    json = JSON3.read(str)\n    for i in \"abcdef\"\n        json[i]\n    end\n\n    JSON3.read(\n        str,\n        NamedTuple{(:a, :b, :c, :d, :e, :f), Tuple{Int, String, Vector{Int}, Bool, Nothing, Float32}}\n    )\n\n    JSON3.write(IOBuffer(), json)\n    JSON3.pretty(IOBuffer(), json)\nend\n"}, "files_after": {"src/workload.jl": "using PrecompileTools\n\n@compile_workload begin\n    str = \"\"\"{\"a\": 1, \"b\": \"hello, world\", \"c\": [1, 2], \"d\": true, \"e\": null, \"f\": 1.92, \"g\": {\"a\": {\"a\" : \"b\"}}}\"\"\"\n\n    JSON3.read(IOBuffer(str))\n    json = JSON3.read(str)\n    for i in \"abcdef\"\n        json[i]\n    end\n    json[:g][:a][:a]\n\n    JSON3.read(\n        str,\n        NamedTuple{(:a, :b, :c, :d, :e, :f), Tuple{Int, String, Vector{Int}, Bool, Nothing, Float32}}\n    )\n\n    JSON3.write(IOBuffer(), json)\n    JSON3.pretty(IOBuffer(), json)\nend\n"}, "source_files_changed": ["src/workload.jl"], "test_files_changed": [], "lines_changed": 3, "is_valid": false, "validation_errors": ["Low action confidence: 0.1", "Could not infer action type"]}
{"repo": "JSON3.jl", "commit_sha": "ac35be7fde0466ed992223496f3e03c8214436b4", "parent_sha": "e33786c0af759f6e85e2a1a4749835e30899f937", "commit_message": "Refactor internal getvalue for JSON3.Array to improve performance (#267)", "commit_date": "2023-08-02T15:52:14-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/utils.jl", "target_symbol": "getvalue", "signature": null, "confidence": 0.6}, "files_before": {"src/utils.jl": "_symbol(ptr, len) = ccall(:jl_symbol_n, Ref{Symbol}, (Ptr{UInt8}, Int), ptr, len)\n\nfunction getbyte(buf, pos)\n    unsafe_load(pointer(buf.s), pos)\nend\n\nfunction getbyte(buf::AbstractVector{UInt8}, pos)\n    @inbounds b = buf[pos]\n    return b\nend\n\nmacro eof()\n    esc(quote\n        if pos > len\n            error = UnexpectedEOF\n            @goto invalid\n        end\n    end)\nend\n\nmacro wh()\n    esc(quote\n        while b == UInt8('\\t') || b == UInt8(' ') || b == UInt8('\\n') || b == UInt8('\\r')\n            pos += 1\n            if pos > len\n                error = UnexpectedEOF\n                @goto invalid\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nmacro wh_done()\n    esc(quote\n        while b == UInt8(' ') || b == UInt8('\\t')\n            pos += 1\n            if pos > len\n                @goto done\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nconst EMPTY   = UInt64(0b00000000) << 56\nconst OBJECT  = UInt64(0b00000001) << 56\nconst ARRAY   = UInt64(0b00000010) << 56\nconst STRING  = UInt64(0b00000100) << 56\nconst INT     = UInt64(0b00001000) << 56\nconst FLOAT   = UInt64(0b00010000) << 56\nconst BOOL    = UInt64(0b00100000) << 56\nconst NULL    = UInt64(0b01000000) << 56\nconst ANY     = UInt64(0b10000000) << 56\n\nconst TYPEMASK = 0xff00000000000000\n\nempty(x::UInt64) = (x & TYPEMASK) == EMPTY\nisany(x::UInt64) = (x & TYPEMASK) == ANY\nisobject(x::UInt64) = (x & TYPEMASK) == OBJECT\nisarray(x::UInt64) = (x & TYPEMASK) == ARRAY\nisstring(x::UInt64) = (x & TYPEMASK) == STRING\nisint(x::UInt64) = (x & TYPEMASK) == INT\nisfloat(x::UInt64) = (x & TYPEMASK) == FLOAT\nisbool(x::UInt64) = (x & TYPEMASK) == BOOL\nisnull(x::UInt64) = (x & TYPEMASK) == NULL\nisintfloat(x::UInt64) = (x & TYPEMASK) == (INT | FLOAT)\nnonnull(x::UInt64) = (x & TYPEMASK) & ~NULL\n\nfunction geteltype(T)\n    if empty(T); return Union{}\n    elseif isany(T); return Any\n    elseif isobject(T); return Object\n    elseif isarray(T); return Array\n    elseif isstring(T); return String\n    elseif isint(T); return Int64\n    elseif isfloat(T); return Float64\n    elseif isbool(T); return Bool\n    elseif isnull(T); return Nothing\n    elseif isintfloat(T); return Union{Int64, Float64}\n    else return Union{geteltype(nonnull(T)), Nothing}\n    end\nend\n\nobject(tapelen) = OBJECT | Core.bitcast(UInt64, tapelen)\narray(tapelen)  = ARRAY  | Core.bitcast(UInt64, tapelen)\neltypelen(T, len) = T | Core.bitcast(UInt64, len)\nstring(len) = STRING | Core.bitcast(UInt64, len)\nconst ESCAPE_BIT = UInt64(1) << 63\n\nfunction promoteeltype(A, B)\n    if A == B\n        return A\n    elseif A == EMPTY\n        return B\n    elseif (A | B) == A\n        return A\n    elseif A == INT && B == FLOAT\n        return A | B\n    elseif A == FLOAT && B == INT\n        return A | B\n    elseif A == (INT | NULL) && B == FLOAT\n        return A | B\n    elseif A == (FLOAT | NULL) && B == INT\n        return A | B\n    elseif A == NULL || B == NULL\n        return A | B\n    else\n        return ANY\n    end\nend\n\ngettypemask(x::UInt64) = x & TYPEMASK\ngetnontypemask(x::UInt64) = Core.bitcast(Int64, x & ~TYPEMASK)\ngetpos(x::UInt64) = Core.bitcast(Int64, getnontypemask(x) >> 16)\ngetlen(x::UInt64) = Core.bitcast(Int64, x & 0x000000000000ffff)\n\ngettapelen(T, x::UInt64) = ifelse(isobject(x) | isarray(x), getnontypemask(x), 2)\ngettapelen(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = 2\n\nregularstride(T) = false\nregularstride(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = true\nregularstride(::Type{Union{Int64, Float64}}) = true\n\nfunction getvalue(::Type{Object}, buf, tape, tapeidx, t)\n    x = Object(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)), Dict{Symbol, Int}())\n    populateinds!(x)\n    return x\nend\n\nfunction getvalue(::Type{Array}, buf, tape, tapeidx, t)\n    x = Array{geteltype(tape[tapeidx+1])}(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)), Int[])\n    populateinds!(x)\n    return x\nend\n\nfunction getvalue(::Type{Symbol}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return Symbol(unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t))))\n    else\n        return _symbol(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{String}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t)))\n    else\n        return unsafe_string(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{Int64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Int64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Float64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Float64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Union{Int64, Float64}}, buf, tape, tapeidx, t)\n    @inbounds x = tape[tapeidx+1]\n    return Core.bitcast(ifelse(isint(t), Int64, Float64), x)\nend\ngetvalue(::Type{Bool}, buf, tape, tapeidx, t) = getnontypemask(t) == UInt64(1)\ngetvalue(::Type{Nothing}, buf, tape, tapeidx, t) = nothing\n@inline function getvalue(T, buf, tape, tapeidx, t)\n    if isobject(t)\n        return getvalue(Object, buf, tape, tapeidx, t)\n    elseif isarray(t)\n        return getvalue(Array, buf, tape, tapeidx, t)\n    elseif isstring(t)\n        return getvalue(String, buf, tape, tapeidx, t)\n    elseif isint(t)\n        return getvalue(Int64, buf, tape, tapeidx, t)\n    elseif isfloat(t)\n        return getvalue(Float64, buf, tape, tapeidx, t)\n    elseif isbool(t)\n        return getvalue(Bool, buf, tape, tapeidx, t)\n    elseif isnull(t)\n        return nothing\n    end\nend\n\nBase.@pure function symbolin(names::Tuple{Vararg{Symbol}}, name::Symbol)\n    for nm in names\n        nm === name && return true\n    end\n    return false\nend\n\nfunction read_json_str(json)\n    # length check is to ensure that isfile doesn't thrown an error\n    # see issue for details https://github.com/JuliaLang/julia/issues/39774\n    !(json isa VectorString) && sizeof(json) < 255 && isfile(json) ?\n          VectorString(Mmap.mmap(json)) : \n          json\nend\n"}, "files_after": {"src/utils.jl": "_symbol(ptr, len) = ccall(:jl_symbol_n, Ref{Symbol}, (Ptr{UInt8}, Int), ptr, len)\n\nfunction getbyte(buf, pos)\n    unsafe_load(pointer(buf.s), pos)\nend\n\nfunction getbyte(buf::AbstractVector{UInt8}, pos)\n    @inbounds b = buf[pos]\n    return b\nend\n\nmacro eof()\n    esc(quote\n        if pos > len\n            error = UnexpectedEOF\n            @goto invalid\n        end\n    end)\nend\n\nmacro wh()\n    esc(quote\n        while b == UInt8('\\t') || b == UInt8(' ') || b == UInt8('\\n') || b == UInt8('\\r')\n            pos += 1\n            if pos > len\n                error = UnexpectedEOF\n                @goto invalid\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nmacro wh_done()\n    esc(quote\n        while b == UInt8(' ') || b == UInt8('\\t')\n            pos += 1\n            if pos > len\n                @goto done\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nconst EMPTY   = UInt64(0b00000000) << 56\nconst OBJECT  = UInt64(0b00000001) << 56\nconst ARRAY   = UInt64(0b00000010) << 56\nconst STRING  = UInt64(0b00000100) << 56\nconst INT     = UInt64(0b00001000) << 56\nconst FLOAT   = UInt64(0b00010000) << 56\nconst BOOL    = UInt64(0b00100000) << 56\nconst NULL    = UInt64(0b01000000) << 56\nconst ANY     = UInt64(0b10000000) << 56\n\nconst TYPEMASK = 0xff00000000000000\n\nempty(x::UInt64) = (x & TYPEMASK) == EMPTY\nisany(x::UInt64) = (x & TYPEMASK) == ANY\nisobject(x::UInt64) = (x & TYPEMASK) == OBJECT\nisarray(x::UInt64) = (x & TYPEMASK) == ARRAY\nisstring(x::UInt64) = (x & TYPEMASK) == STRING\nisint(x::UInt64) = (x & TYPEMASK) == INT\nisfloat(x::UInt64) = (x & TYPEMASK) == FLOAT\nisbool(x::UInt64) = (x & TYPEMASK) == BOOL\nisnull(x::UInt64) = (x & TYPEMASK) == NULL\nisintfloat(x::UInt64) = (x & TYPEMASK) == (INT | FLOAT)\nnonnull(x::UInt64) = (x & TYPEMASK) & ~NULL\n\nfunction geteltype(T)\n    if empty(T); return Union{}\n    elseif isany(T); return Any\n    elseif isobject(T); return Object\n    elseif isarray(T); return Array\n    elseif isstring(T); return String\n    elseif isint(T); return Int64\n    elseif isfloat(T); return Float64\n    elseif isbool(T); return Bool\n    elseif isnull(T); return Nothing\n    elseif isintfloat(T); return Union{Int64, Float64}\n    else return Union{geteltype(nonnull(T)), Nothing}\n    end\nend\n\nobject(tapelen) = OBJECT | Core.bitcast(UInt64, tapelen)\narray(tapelen)  = ARRAY  | Core.bitcast(UInt64, tapelen)\neltypelen(T, len) = T | Core.bitcast(UInt64, len)\nstring(len) = STRING | Core.bitcast(UInt64, len)\nconst ESCAPE_BIT = UInt64(1) << 63\n\nfunction promoteeltype(A, B)\n    if A == B\n        return A\n    elseif A == EMPTY\n        return B\n    elseif (A | B) == A\n        return A\n    elseif A == INT && B == FLOAT\n        return A | B\n    elseif A == FLOAT && B == INT\n        return A | B\n    elseif A == (INT | NULL) && B == FLOAT\n        return A | B\n    elseif A == (FLOAT | NULL) && B == INT\n        return A | B\n    elseif A == NULL || B == NULL\n        return A | B\n    else\n        return ANY\n    end\nend\n\ngettypemask(x::UInt64) = x & TYPEMASK\ngetnontypemask(x::UInt64) = Core.bitcast(Int64, x & ~TYPEMASK)\ngetpos(x::UInt64) = Core.bitcast(Int64, getnontypemask(x) >> 16)\ngetlen(x::UInt64) = Core.bitcast(Int64, x & 0x000000000000ffff)\n\ngettapelen(T, x::UInt64) = ifelse(isobject(x) | isarray(x), getnontypemask(x), 2)\ngettapelen(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = 2\n\nregularstride(T) = false\nregularstride(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = true\nregularstride(::Type{Union{Int64, Float64}}) = true\n\nfunction getvalue(::Type{Object}, buf, tape, tapeidx, t)\n    x = Object(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)), Dict{Symbol, Int}())\n    populateinds!(x)\n    return x\nend\n\nfunction getvalue(::Type{Array}, buf, tape, tapeidx, t)\n    T = tape[tapeidx+1]\n    ttape = Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t))\n    inds = Int[]\n    if empty(T)\n        x = Array{Union{},typeof(buf),typeof(ttape)}(buf, ttape, inds)\n        populateinds!(x)\n        return x\n    elseif isany(T)\n        x = Array{Any,typeof(buf),typeof(ttape)}(buf, ttape, inds)\n        populateinds!(x)\n        return x\n    elseif isobject(T)\n        x = Array{Object,typeof(buf),typeof(ttape)}(buf, ttape, inds)\n        populateinds!(x)\n        return x\n    elseif isarray(T)\n        x = Array{Array,typeof(buf),typeof(ttape)}(buf, ttape, inds)\n        populateinds!(x)\n        return x\n    elseif isstring(T)\n        x = Array{String,typeof(buf),typeof(ttape)}(buf, ttape, inds)\n        populateinds!(x)\n        return x\n    elseif isint(T)\n        x = Array{Int64,typeof(buf),typeof(ttape)}(buf, ttape, inds)\n        populateinds!(x)\n        return x\n    elseif isfloat(T)\n        x = Array{Float64,typeof(buf),typeof(ttape)}(buf, ttape, inds)\n        populateinds!(x)\n        return x\n    elseif isbool(T)\n        x = Array{Bool,typeof(buf),typeof(ttape)}(buf, ttape, inds)\n        populateinds!(x)\n        return x\n    elseif isnull(T)\n        x = Array{Nothing,typeof(buf),typeof(ttape)}(buf, ttape, inds)\n        populateinds!(x)\n        return x\n    elseif isintfloat(T)\n        x = Array{Union{Int64, Float64},typeof(buf),typeof(ttape)}(buf, ttape, inds)\n        populateinds!(x)\n        return x\n    else\n        x = Array{Union{geteltype(nonnull(T)), Nothing},typeof(buf),typeof(ttape)}(buf, ttape, inds)\n        populateinds!(x)\n        return x\n    end\nend\n\nfunction getvalue(::Type{Symbol}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return Symbol(unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t))))\n    else\n        return _symbol(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{String}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t)))\n    else\n        return unsafe_string(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{Int64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Int64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Float64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Float64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Union{Int64, Float64}}, buf, tape, tapeidx, t)\n    @inbounds x = tape[tapeidx+1]\n    return Core.bitcast(ifelse(isint(t), Int64, Float64), x)\nend\ngetvalue(::Type{Bool}, buf, tape, tapeidx, t) = getnontypemask(t) == UInt64(1)\ngetvalue(::Type{Nothing}, buf, tape, tapeidx, t) = nothing\n@inline function getvalue(T, buf, tape, tapeidx, t)\n    if isobject(t)\n        return getvalue(Object, buf, tape, tapeidx, t)\n    elseif isarray(t)\n        return getvalue(Array, buf, tape, tapeidx, t)\n    elseif isstring(t)\n        return getvalue(String, buf, tape, tapeidx, t)\n    elseif isint(t)\n        return getvalue(Int64, buf, tape, tapeidx, t)\n    elseif isfloat(t)\n        return getvalue(Float64, buf, tape, tapeidx, t)\n    elseif isbool(t)\n        return getvalue(Bool, buf, tape, tapeidx, t)\n    elseif isnull(t)\n        return nothing\n    end\nend\n\nBase.@pure function symbolin(names::Tuple{Vararg{Symbol}}, name::Symbol)\n    for nm in names\n        nm === name && return true\n    end\n    return false\nend\n\nfunction read_json_str(json)\n    # length check is to ensure that isfile doesn't thrown an error\n    # see issue for details https://github.com/JuliaLang/julia/issues/39774\n    !(json isa VectorString) && sizeof(json) < 255 && isfile(json) ?\n          VectorString(Mmap.mmap(json)) : \n          json\nend\n"}, "source_files_changed": ["src/utils.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 52, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "7c6d69a295adffdd6f24be9c29fdf6d7387822fd", "parent_sha": "b23f72bd6d6b35970526b935cb9e2af0a6692e4c", "commit_message": "Fix JSON3.write for non-traditional indexed AbstractVector (#261)", "commit_date": "2023-06-05T16:44:10-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.6}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::AbstractArray) = isempty(x) ? 2 : sum(defaultminimum, (isassigned(x, i) ? defaultminimum(x[i]) : 4 for i in eachindex(x)))\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::SingletonType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::AbstractArray; kw...)\n    @writechar '['\n    n = length(x)\n    i = 1\n    for i in eachindex(x)\n        if isassigned(x, i)\n            y = x[i]\n            buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        else\n            buf, pos, len = write(NullType(), buf, pos, len, nothing; kw...)\n        end\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\nwrite(::SingletonType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, x; kw...)\n\n# adapted from base/intfuncs.jl\n_split_sign(x) = Base.split_sign(x)\n_split_sign(x::BigInt) = (abs(x), x < 0)\n\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = _split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\n# default fallback for non-Integer/non-AbstractFloat numbers\n# conver to Float64 and write the string representation\n\"\"\"\n    JSON3.tostring(x::Real) -> String\n\nFor some number types that are `<: Real`, but not `<: Integer` or `<: AbstractFloat`,\n`tostring` provides an overload to convert `x` to an appropriate string representation\nwhich will be used for the JSON numeric representation. By default, `x` is converted\nto a `Float64` and then to a `String`.\n\"\"\"\ntostring(x::Real) = Base.string(convert(Float64, x))\n\nfunction write(::NumberType, buf, pos, len, x::T; kw...) where {T}\n    NT = StructTypes.numbertype(T)\n    if NT === T\n        # this means T hasn't overloaded numbertype\n        # and we can't StructTypes.construct since we'll just stack overflow\n        # so we call last-chance tostring that can be overloaded\n        bytes = codeunits(tostring(x))\n        sz = sizeof(bytes)\n        @check sz\n        for i = 1:sz\n            @inbounds @writechar bytes[i]\n        end\n\n        return buf, pos, len\n    else\n        write(NumberType(), buf, pos, len, StructTypes.construct(NT, x); kw...)\n    end\nend\n\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Ryu.neededdigits(T)\n    pos = Ryu.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::AbstractArray) = isempty(x) ? 2 : sum(defaultminimum, (isassigned(x, i) ? defaultminimum(x[i]) : 4 for i in eachindex(x)))\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::SingletonType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::AbstractArray; kw...)\n    @writechar '['\n    n = 0\n    for i in eachindex(x)\n        if isassigned(x, i)\n            y = x[i]\n            buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        else\n            buf, pos, len = write(NullType(), buf, pos, len, nothing; kw...)\n        end\n        @writechar ','\n        n += 1\n    end\n    if n > 0\n        # for non-empty arrays, we eagerly write a comma after each element\n        # so backtrack one pos where we'll write ']'\n        pos -= 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\nwrite(::SingletonType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, x; kw...)\n\n# adapted from base/intfuncs.jl\n_split_sign(x) = Base.split_sign(x)\n_split_sign(x::BigInt) = (abs(x), x < 0)\n\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = _split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\n# default fallback for non-Integer/non-AbstractFloat numbers\n# conver to Float64 and write the string representation\n\"\"\"\n    JSON3.tostring(x::Real) -> String\n\nFor some number types that are `<: Real`, but not `<: Integer` or `<: AbstractFloat`,\n`tostring` provides an overload to convert `x` to an appropriate string representation\nwhich will be used for the JSON numeric representation. By default, `x` is converted\nto a `Float64` and then to a `String`.\n\"\"\"\ntostring(x::Real) = Base.string(convert(Float64, x))\n\nfunction write(::NumberType, buf, pos, len, x::T; kw...) where {T}\n    NT = StructTypes.numbertype(T)\n    if NT === T\n        # this means T hasn't overloaded numbertype\n        # and we can't StructTypes.construct since we'll just stack overflow\n        # so we call last-chance tostring that can be overloaded\n        bytes = codeunits(tostring(x))\n        sz = sizeof(bytes)\n        @check sz\n        for i = 1:sz\n            @inbounds @writechar bytes[i]\n        end\n\n        return buf, pos, len\n    else\n        write(NumberType(), buf, pos, len, StructTypes.construct(NT, x); kw...)\n    end\nend\n\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Ryu.neededdigits(T)\n    pos = Ryu.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 14, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "b23f72bd6d6b35970526b935cb9e2af0a6692e4c", "parent_sha": "0dd0f0f43f39226d1696c6bf434924fb2ede99e2", "commit_message": "Use `sizeof` rather than `length` for file length check (#260)", "commit_date": "2023-06-03T06:20:12+01:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/utils.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/utils.jl": "_symbol(ptr, len) = ccall(:jl_symbol_n, Ref{Symbol}, (Ptr{UInt8}, Int), ptr, len)\n\nfunction getbyte(buf, pos)\n    unsafe_load(pointer(buf.s), pos)\nend\n\nfunction getbyte(buf::AbstractVector{UInt8}, pos)\n    @inbounds b = buf[pos]\n    return b\nend\n\nmacro eof()\n    esc(quote\n        if pos > len\n            error = UnexpectedEOF\n            @goto invalid\n        end\n    end)\nend\n\nmacro wh()\n    esc(quote\n        while b == UInt8('\\t') || b == UInt8(' ') || b == UInt8('\\n') || b == UInt8('\\r')\n            pos += 1\n            if pos > len\n                error = UnexpectedEOF\n                @goto invalid\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nmacro wh_done()\n    esc(quote\n        while b == UInt8(' ') || b == UInt8('\\t')\n            pos += 1\n            if pos > len\n                @goto done\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nconst EMPTY   = UInt64(0b00000000) << 56\nconst OBJECT  = UInt64(0b00000001) << 56\nconst ARRAY   = UInt64(0b00000010) << 56\nconst STRING  = UInt64(0b00000100) << 56\nconst INT     = UInt64(0b00001000) << 56\nconst FLOAT   = UInt64(0b00010000) << 56\nconst BOOL    = UInt64(0b00100000) << 56\nconst NULL    = UInt64(0b01000000) << 56\nconst ANY     = UInt64(0b10000000) << 56\n\nconst TYPEMASK = 0xff00000000000000\n\nempty(x::UInt64) = (x & TYPEMASK) == EMPTY\nisany(x::UInt64) = (x & TYPEMASK) == ANY\nisobject(x::UInt64) = (x & TYPEMASK) == OBJECT\nisarray(x::UInt64) = (x & TYPEMASK) == ARRAY\nisstring(x::UInt64) = (x & TYPEMASK) == STRING\nisint(x::UInt64) = (x & TYPEMASK) == INT\nisfloat(x::UInt64) = (x & TYPEMASK) == FLOAT\nisbool(x::UInt64) = (x & TYPEMASK) == BOOL\nisnull(x::UInt64) = (x & TYPEMASK) == NULL\nisintfloat(x::UInt64) = (x & TYPEMASK) == (INT | FLOAT)\nnonnull(x::UInt64) = (x & TYPEMASK) & ~NULL\n\nfunction geteltype(T)\n    if empty(T); return Union{}\n    elseif isany(T); return Any\n    elseif isobject(T); return Object\n    elseif isarray(T); return Array\n    elseif isstring(T); return String\n    elseif isint(T); return Int64\n    elseif isfloat(T); return Float64\n    elseif isbool(T); return Bool\n    elseif isnull(T); return Nothing\n    elseif isintfloat(T); return Union{Int64, Float64}\n    else return Union{geteltype(nonnull(T)), Nothing}\n    end\nend\n\nobject(tapelen) = OBJECT | Core.bitcast(UInt64, tapelen)\narray(tapelen)  = ARRAY  | Core.bitcast(UInt64, tapelen)\neltypelen(T, len) = T | Core.bitcast(UInt64, len)\nstring(len) = STRING | Core.bitcast(UInt64, len)\nconst ESCAPE_BIT = UInt64(1) << 63\n\nfunction promoteeltype(A, B)\n    if A == B\n        return A\n    elseif A == EMPTY\n        return B\n    elseif (A | B) == A\n        return A\n    elseif A == INT && B == FLOAT\n        return A | B\n    elseif A == FLOAT && B == INT\n        return A | B\n    elseif A == (INT | NULL) && B == FLOAT\n        return A | B\n    elseif A == (FLOAT | NULL) && B == INT\n        return A | B\n    elseif A == NULL || B == NULL\n        return A | B\n    else\n        return ANY\n    end\nend\n\ngettypemask(x::UInt64) = x & TYPEMASK\ngetnontypemask(x::UInt64) = Core.bitcast(Int64, x & ~TYPEMASK)\ngetpos(x::UInt64) = Core.bitcast(Int64, getnontypemask(x) >> 16)\ngetlen(x::UInt64) = Core.bitcast(Int64, x & 0x000000000000ffff)\n\ngettapelen(T, x::UInt64) = ifelse(isobject(x) | isarray(x), getnontypemask(x), 2)\ngettapelen(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = 2\n\nregularstride(T) = false\nregularstride(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = true\nregularstride(::Type{Union{Int64, Float64}}) = true\n\nfunction getvalue(::Type{Object}, buf, tape, tapeidx, t)\n    x = Object(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)), Dict{Symbol, Int}())\n    populateinds!(x)\n    return x\nend\n\nfunction getvalue(::Type{Array}, buf, tape, tapeidx, t)\n    x = Array{geteltype(tape[tapeidx+1])}(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)), Int[])\n    populateinds!(x)\n    return x\nend\n\nfunction getvalue(::Type{Symbol}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return Symbol(unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t))))\n    else\n        return _symbol(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{String}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t)))\n    else\n        return unsafe_string(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{Int64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Int64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Float64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Float64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Union{Int64, Float64}}, buf, tape, tapeidx, t)\n    @inbounds x = tape[tapeidx+1]\n    return Core.bitcast(ifelse(isint(t), Int64, Float64), x)\nend\ngetvalue(::Type{Bool}, buf, tape, tapeidx, t) = getnontypemask(t) == UInt64(1)\ngetvalue(::Type{Nothing}, buf, tape, tapeidx, t) = nothing\n@inline function getvalue(T, buf, tape, tapeidx, t)\n    if isobject(t)\n        return getvalue(Object, buf, tape, tapeidx, t)\n    elseif isarray(t)\n        return getvalue(Array, buf, tape, tapeidx, t)\n    elseif isstring(t)\n        return getvalue(String, buf, tape, tapeidx, t)\n    elseif isint(t)\n        return getvalue(Int64, buf, tape, tapeidx, t)\n    elseif isfloat(t)\n        return getvalue(Float64, buf, tape, tapeidx, t)\n    elseif isbool(t)\n        return getvalue(Bool, buf, tape, tapeidx, t)\n    elseif isnull(t)\n        return nothing\n    end\nend\n\nBase.@pure function symbolin(names::Tuple{Vararg{Symbol}}, name::Symbol)\n    for nm in names\n        nm === name && return true\n    end\n    return false\nend\n\nfunction read_json_str(json)\n    # length check is to ensure that isfile doesn't thrown an error\n    # see issue for details https://github.com/JuliaLang/julia/issues/39774\n    !(json isa VectorString) && length(json) < 255 && isfile(json) ?\n          VectorString(Mmap.mmap(json)) : \n          json\nend"}, "files_after": {"src/utils.jl": "_symbol(ptr, len) = ccall(:jl_symbol_n, Ref{Symbol}, (Ptr{UInt8}, Int), ptr, len)\n\nfunction getbyte(buf, pos)\n    unsafe_load(pointer(buf.s), pos)\nend\n\nfunction getbyte(buf::AbstractVector{UInt8}, pos)\n    @inbounds b = buf[pos]\n    return b\nend\n\nmacro eof()\n    esc(quote\n        if pos > len\n            error = UnexpectedEOF\n            @goto invalid\n        end\n    end)\nend\n\nmacro wh()\n    esc(quote\n        while b == UInt8('\\t') || b == UInt8(' ') || b == UInt8('\\n') || b == UInt8('\\r')\n            pos += 1\n            if pos > len\n                error = UnexpectedEOF\n                @goto invalid\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nmacro wh_done()\n    esc(quote\n        while b == UInt8(' ') || b == UInt8('\\t')\n            pos += 1\n            if pos > len\n                @goto done\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nconst EMPTY   = UInt64(0b00000000) << 56\nconst OBJECT  = UInt64(0b00000001) << 56\nconst ARRAY   = UInt64(0b00000010) << 56\nconst STRING  = UInt64(0b00000100) << 56\nconst INT     = UInt64(0b00001000) << 56\nconst FLOAT   = UInt64(0b00010000) << 56\nconst BOOL    = UInt64(0b00100000) << 56\nconst NULL    = UInt64(0b01000000) << 56\nconst ANY     = UInt64(0b10000000) << 56\n\nconst TYPEMASK = 0xff00000000000000\n\nempty(x::UInt64) = (x & TYPEMASK) == EMPTY\nisany(x::UInt64) = (x & TYPEMASK) == ANY\nisobject(x::UInt64) = (x & TYPEMASK) == OBJECT\nisarray(x::UInt64) = (x & TYPEMASK) == ARRAY\nisstring(x::UInt64) = (x & TYPEMASK) == STRING\nisint(x::UInt64) = (x & TYPEMASK) == INT\nisfloat(x::UInt64) = (x & TYPEMASK) == FLOAT\nisbool(x::UInt64) = (x & TYPEMASK) == BOOL\nisnull(x::UInt64) = (x & TYPEMASK) == NULL\nisintfloat(x::UInt64) = (x & TYPEMASK) == (INT | FLOAT)\nnonnull(x::UInt64) = (x & TYPEMASK) & ~NULL\n\nfunction geteltype(T)\n    if empty(T); return Union{}\n    elseif isany(T); return Any\n    elseif isobject(T); return Object\n    elseif isarray(T); return Array\n    elseif isstring(T); return String\n    elseif isint(T); return Int64\n    elseif isfloat(T); return Float64\n    elseif isbool(T); return Bool\n    elseif isnull(T); return Nothing\n    elseif isintfloat(T); return Union{Int64, Float64}\n    else return Union{geteltype(nonnull(T)), Nothing}\n    end\nend\n\nobject(tapelen) = OBJECT | Core.bitcast(UInt64, tapelen)\narray(tapelen)  = ARRAY  | Core.bitcast(UInt64, tapelen)\neltypelen(T, len) = T | Core.bitcast(UInt64, len)\nstring(len) = STRING | Core.bitcast(UInt64, len)\nconst ESCAPE_BIT = UInt64(1) << 63\n\nfunction promoteeltype(A, B)\n    if A == B\n        return A\n    elseif A == EMPTY\n        return B\n    elseif (A | B) == A\n        return A\n    elseif A == INT && B == FLOAT\n        return A | B\n    elseif A == FLOAT && B == INT\n        return A | B\n    elseif A == (INT | NULL) && B == FLOAT\n        return A | B\n    elseif A == (FLOAT | NULL) && B == INT\n        return A | B\n    elseif A == NULL || B == NULL\n        return A | B\n    else\n        return ANY\n    end\nend\n\ngettypemask(x::UInt64) = x & TYPEMASK\ngetnontypemask(x::UInt64) = Core.bitcast(Int64, x & ~TYPEMASK)\ngetpos(x::UInt64) = Core.bitcast(Int64, getnontypemask(x) >> 16)\ngetlen(x::UInt64) = Core.bitcast(Int64, x & 0x000000000000ffff)\n\ngettapelen(T, x::UInt64) = ifelse(isobject(x) | isarray(x), getnontypemask(x), 2)\ngettapelen(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = 2\n\nregularstride(T) = false\nregularstride(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = true\nregularstride(::Type{Union{Int64, Float64}}) = true\n\nfunction getvalue(::Type{Object}, buf, tape, tapeidx, t)\n    x = Object(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)), Dict{Symbol, Int}())\n    populateinds!(x)\n    return x\nend\n\nfunction getvalue(::Type{Array}, buf, tape, tapeidx, t)\n    x = Array{geteltype(tape[tapeidx+1])}(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)), Int[])\n    populateinds!(x)\n    return x\nend\n\nfunction getvalue(::Type{Symbol}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return Symbol(unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t))))\n    else\n        return _symbol(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{String}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t)))\n    else\n        return unsafe_string(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{Int64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Int64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Float64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Float64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Union{Int64, Float64}}, buf, tape, tapeidx, t)\n    @inbounds x = tape[tapeidx+1]\n    return Core.bitcast(ifelse(isint(t), Int64, Float64), x)\nend\ngetvalue(::Type{Bool}, buf, tape, tapeidx, t) = getnontypemask(t) == UInt64(1)\ngetvalue(::Type{Nothing}, buf, tape, tapeidx, t) = nothing\n@inline function getvalue(T, buf, tape, tapeidx, t)\n    if isobject(t)\n        return getvalue(Object, buf, tape, tapeidx, t)\n    elseif isarray(t)\n        return getvalue(Array, buf, tape, tapeidx, t)\n    elseif isstring(t)\n        return getvalue(String, buf, tape, tapeidx, t)\n    elseif isint(t)\n        return getvalue(Int64, buf, tape, tapeidx, t)\n    elseif isfloat(t)\n        return getvalue(Float64, buf, tape, tapeidx, t)\n    elseif isbool(t)\n        return getvalue(Bool, buf, tape, tapeidx, t)\n    elseif isnull(t)\n        return nothing\n    end\nend\n\nBase.@pure function symbolin(names::Tuple{Vararg{Symbol}}, name::Symbol)\n    for nm in names\n        nm === name && return true\n    end\n    return false\nend\n\nfunction read_json_str(json)\n    # length check is to ensure that isfile doesn't thrown an error\n    # see issue for details https://github.com/JuliaLang/julia/issues/39774\n    !(json isa VectorString) && sizeof(json) < 255 && isfile(json) ?\n          VectorString(Mmap.mmap(json)) : \n          json\nend\n"}, "source_files_changed": ["src/utils.jl"], "test_files_changed": ["test/json.jl"], "lines_changed": 12, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "40a3eeba306b807b8b29b88f16e444f90fbeda81", "parent_sha": "4a15a8ab95d82f42c89f25bb0a0e3106c45b63a7", "commit_message": "Migrate from SnoopPrecompile to PrecompileTools (#256)", "commit_date": "2023-04-27T17:36:57-05:00", "action": {"type": "ADD_IMPORT", "target_file": "src/workload.jl", "target_symbol": null, "signature": null, "confidence": 0.6}, "files_before": {"src/workload.jl": "using SnoopPrecompile\n\n@precompile_all_calls begin\n    str = \"\"\"{\"a\": 1, \"b\": \"hello, world\", \"c\": [1, 2], \"d\": true, \"e\": null, \"f\": 1.92}\"\"\"\n\n    JSON3.read(IOBuffer(str))\n    json = JSON3.read(str)\n    for i in \"abcdef\"\n        json[i]\n    end\n\n    JSON3.read(\n        str,\n        NamedTuple{(:a, :b, :c, :d, :e, :f), Tuple{Int, String, Vector{Int}, Bool, Nothing, Float32}}\n    )\n\n    JSON3.write(IOBuffer(), json)\n    JSON3.pretty(IOBuffer(), json)\nend\n"}, "files_after": {"src/workload.jl": "using PrecompileTools\n\n@compile_workload begin\n    str = \"\"\"{\"a\": 1, \"b\": \"hello, world\", \"c\": [1, 2], \"d\": true, \"e\": null, \"f\": 1.92}\"\"\"\n\n    JSON3.read(IOBuffer(str))\n    json = JSON3.read(str)\n    for i in \"abcdef\"\n        json[i]\n    end\n\n    JSON3.read(\n        str,\n        NamedTuple{(:a, :b, :c, :d, :e, :f), Tuple{Int, String, Vector{Int}, Bool, Nothing, Float32}}\n    )\n\n    JSON3.write(IOBuffer(), json)\n    JSON3.pretty(IOBuffer(), json)\nend\n"}, "source_files_changed": ["src/workload.jl"], "test_files_changed": [], "lines_changed": 8, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "4a15a8ab95d82f42c89f25bb0a0e3106c45b63a7", "parent_sha": "ce174f7fd26d0ad2adfeaa94ab671ee9adbd4e11", "commit_message": "Fix writing when array has undef values (#253)", "commit_date": "2023-02-03T16:20:24-07:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "defaultminimum", "signature": null, "confidence": 0.75}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::SingletonType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\nwrite(::SingletonType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, x; kw...)\n\n# adapted from base/intfuncs.jl\n_split_sign(x) = Base.split_sign(x)\n_split_sign(x::BigInt) = (abs(x), x < 0)\n\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = _split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\n# default fallback for non-Integer/non-AbstractFloat numbers\n# conver to Float64 and write the string representation\n\"\"\"\n    JSON3.tostring(x::Real) -> String\n\nFor some number types that are `<: Real`, but not `<: Integer` or `<: AbstractFloat`,\n`tostring` provides an overload to convert `x` to an appropriate string representation\nwhich will be used for the JSON numeric representation. By default, `x` is converted\nto a `Float64` and then to a `String`.\n\"\"\"\ntostring(x::Real) = Base.string(convert(Float64, x))\n\nfunction write(::NumberType, buf, pos, len, x::T; kw...) where {T}\n    NT = StructTypes.numbertype(T)\n    if NT === T\n        # this means T hasn't overloaded numbertype\n        # and we can't StructTypes.construct since we'll just stack overflow\n        # so we call last-chance tostring that can be overloaded\n        bytes = codeunits(tostring(x))\n        sz = sizeof(bytes)\n        @check sz\n        for i = 1:sz\n            @inbounds @writechar bytes[i]\n        end\n\n        return buf, pos, len\n    else\n        write(NumberType(), buf, pos, len, StructTypes.construct(NT, x); kw...)\n    end\nend\n\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Ryu.neededdigits(T)\n    pos = Ryu.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::AbstractArray) = isempty(x) ? 2 : sum(defaultminimum, (isassigned(x, i) ? defaultminimum(x[i]) : 4 for i in eachindex(x)))\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::SingletonType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::AbstractArray; kw...)\n    @writechar '['\n    n = length(x)\n    i = 1\n    for i in eachindex(x)\n        if isassigned(x, i)\n            y = x[i]\n            buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        else\n            buf, pos, len = write(NullType(), buf, pos, len, nothing; kw...)\n        end\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\nwrite(::SingletonType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, x; kw...)\n\n# adapted from base/intfuncs.jl\n_split_sign(x) = Base.split_sign(x)\n_split_sign(x::BigInt) = (abs(x), x < 0)\n\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = _split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\n# default fallback for non-Integer/non-AbstractFloat numbers\n# conver to Float64 and write the string representation\n\"\"\"\n    JSON3.tostring(x::Real) -> String\n\nFor some number types that are `<: Real`, but not `<: Integer` or `<: AbstractFloat`,\n`tostring` provides an overload to convert `x` to an appropriate string representation\nwhich will be used for the JSON numeric representation. By default, `x` is converted\nto a `Float64` and then to a `String`.\n\"\"\"\ntostring(x::Real) = Base.string(convert(Float64, x))\n\nfunction write(::NumberType, buf, pos, len, x::T; kw...) where {T}\n    NT = StructTypes.numbertype(T)\n    if NT === T\n        # this means T hasn't overloaded numbertype\n        # and we can't StructTypes.construct since we'll just stack overflow\n        # so we call last-chance tostring that can be overloaded\n        bytes = codeunits(tostring(x))\n        sz = sizeof(bytes)\n        @check sz\n        for i = 1:sz\n            @inbounds @writechar bytes[i]\n        end\n\n        return buf, pos, len\n    else\n        write(NumberType(), buf, pos, len, StructTypes.construct(NT, x); kw...)\n    end\nend\n\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Ryu.neededdigits(T)\n    pos = Ryu.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 40, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "ce174f7fd26d0ad2adfeaa94ab671ee9adbd4e11", "parent_sha": "faa521e37317826a38bd211898b512be592be5c7", "commit_message": "can now do read(::Cmd, ::Type) (#252)", "commit_date": "2023-02-02T19:46:34-08:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": "read", "signature": null, "confidence": 0.75}, "files_before": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, SingletonType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(json::AbstractString, ::Type{T}) where {T}\n    str = read_json_str(json)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\nread(::NumberType, buf, pos, len, b, ::Type{Integer}; kw...) =\n    read(NumberType(), buf, pos, len, b, Int64; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, SingletonType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::Union{IO, Base.AbstractCmd}, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(json::AbstractString, ::Type{T}) where {T}\n    str = read_json_str(json)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\nread(::NumberType, buf, pos, len, b, ::Type{Integer}; kw...) =\n    read(NumberType(), buf, pos, len, b, Int64; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "ee5e294cce86de0e7e1b58602531ebe08a063658", "parent_sha": "8569ff907666183f4fe6eff9da12917b83a8d2d2", "commit_message": "Fix writing of BigInts (#244)", "commit_date": "2022-11-17T23:06:37-07:00", "action": {"type": "ADD_METHOD", "target_file": "src/write.jl", "target_symbol": "_split_sign", "signature": null, "confidence": 0.85}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::SingletonType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\nwrite(::SingletonType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, x; kw...)\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\n# default fallback for non-Integer/non-AbstractFloat numbers\n# conver to Float64 and write the string representation\n\"\"\"\n    JSON3.tostring(x::Real) -> String\n\nFor some number types that are `<: Real`, but not `<: Integer` or `<: AbstractFloat`,\n`tostring` provides an overload to convert `x` to an appropriate string representation\nwhich will be used for the JSON numeric representation. By default, `x` is converted\nto a `Float64` and then to a `String`.\n\"\"\"\ntostring(x::Real) = Base.string(convert(Float64, x))\n\nfunction write(::NumberType, buf, pos, len, x::T; kw...) where {T}\n    NT = StructTypes.numbertype(T)\n    if NT === T\n        # this means T hasn't overloaded numbertype\n        # and we can't StructTypes.construct since we'll just stack overflow\n        # so we call last-chance tostring that can be overloaded\n        bytes = codeunits(tostring(x))\n        sz = sizeof(bytes)\n        @check sz\n        for i = 1:sz\n            @inbounds @writechar bytes[i]\n        end\n\n        return buf, pos, len\n    else\n        write(NumberType(), buf, pos, len, StructTypes.construct(NT, x); kw...)\n    end\nend\n\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Ryu.neededdigits(T)\n    pos = Ryu.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::SingletonType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\nwrite(::SingletonType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, x; kw...)\n\n# adapted from base/intfuncs.jl\n_split_sign(x) = Base.split_sign(x)\n_split_sign(x::BigInt) = (abs(x), x < 0)\n\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = _split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\n# default fallback for non-Integer/non-AbstractFloat numbers\n# conver to Float64 and write the string representation\n\"\"\"\n    JSON3.tostring(x::Real) -> String\n\nFor some number types that are `<: Real`, but not `<: Integer` or `<: AbstractFloat`,\n`tostring` provides an overload to convert `x` to an appropriate string representation\nwhich will be used for the JSON numeric representation. By default, `x` is converted\nto a `Float64` and then to a `String`.\n\"\"\"\ntostring(x::Real) = Base.string(convert(Float64, x))\n\nfunction write(::NumberType, buf, pos, len, x::T; kw...) where {T}\n    NT = StructTypes.numbertype(T)\n    if NT === T\n        # this means T hasn't overloaded numbertype\n        # and we can't StructTypes.construct since we'll just stack overflow\n        # so we call last-chance tostring that can be overloaded\n        bytes = codeunits(tostring(x))\n        sz = sizeof(bytes)\n        @check sz\n        for i = 1:sz\n            @inbounds @writechar bytes[i]\n        end\n\n        return buf, pos, len\n    else\n        write(NumberType(), buf, pos, len, StructTypes.construct(NT, x); kw...)\n    end\nend\n\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Ryu.neededdigits(T)\n    pos = Ryu.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 10, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "765c3bf7eb4a392cf94d4852fdaf6df363526ed2", "parent_sha": "df5049d0fc92c652afd54a8cd7e583f3c9cbe51e", "commit_message": "add numbertype=Float64 option (#240)", "commit_date": "2022-11-03T04:24:22+01:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/read.jl", "target_symbol": "read", "signature": null, "confidence": 0.75}, "files_before": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::Union{IO, Base.AbstractCmd}; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\n\"\"\"\n    JSON3.read(json_str, [type]; kw... )\n\nRead JSON.\n\n## Args\n\n* `json_str`: A string, IO, or bytes (`AbstractVector{UInt8`) containing JSON to read\n* `type`: Optionally, a type to read the JSON into. If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `jsonlines`: A Bool indicating that the `json_str` contains newline delimited JSON strings, which will be read into a `JSON3.Array` of the JSON values.  See [jsonlines](https://jsonlines.org/) for reference. [default `false`]\n* `allow_inf`: Allow reading of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing the format of dates in the JSON so that they can be read into `Date`s, `Time`s, or `DateTime`s when reading into a type. [default `Dates.default_format(T)`]\n* `parsequoted`: Accept quoted values when reading into a NumberType. [default `false`]\n\"\"\"\nfunction read(str::AbstractString; jsonlines::Bool=false, kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1); kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        obj = Object(buf, tape, Dict{Symbol, Int}())\n        populateinds!(obj)\n        return obj\n    elseif isarray(t)\n        arr = Array{geteltype(tape[2])}(buf, tape, Int[])\n        populateinds!(arr)\n        return arr\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nconst FLOAT_INT_BOUND = 2.0^53\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            !isfinite(float) && !allow_inf && @goto invalid\n            @check\n            # if, for example, we've already parsed floats in an array, just keep them all as floats and don't check for ints\n            if checkint\n                fp, ip = modf(float)\n                if fp == 0 && Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                    # ok great, we know the number is integral and pretty much in Int64 range\n                    if -FLOAT_INT_BOUND < float < FLOAT_INT_BOUND\n                        # easy case, integer w/ less than or equal to 53-bits of precision\n                        int = unsafe_trunc(Int64, float)\n                    else\n                        # if our integral float is > 53-bit precision, we need to reparse the Int so we don't get a lossy conversion\n                        # there are also a few floats that satisfy Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                        # that actually overflow Int64, like -9223372036854775809 and 9223372036854775808\n                        # in those cases, we're going to verify that this Int64 parsing doesn't overflow\n                        int, code, floatpos2 = Parsers.typeparser(Int64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n                        if floatpos2 < floatpos\n                            # ah, but there's one more case we need to handle: a > 53-bit precision integer given in\n                            # exponent form, like 1e17 or 9.007199254740994e15; in those cases, the truncation to Int64 *isn't* lossy\n                            int = unsafe_trunc(Int64, float)\n                        end\n                    end\n                    if code > 0\n                        @inbounds tape[tapeidx] = INT\n                        @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                        return floatpos, tapeidx + 2\n                    end\n                end\n            end\n            @inbounds tape[tapeidx] = FLOAT\n            @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "files_after": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::Union{IO, Base.AbstractCmd}; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\n\"\"\"\n    JSON3.read(json_str, [type]; kw... )\n\nRead JSON.\n\n## Args\n\n* `json_str`: A string, IO, or bytes (`AbstractVector{UInt8`) containing JSON to read\n* `type`: Optionally, a type to read the JSON into. If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `jsonlines`: A Bool indicating that the `json_str` contains newline delimited JSON strings, which will be read into a `JSON3.Array` of the JSON values.  See [jsonlines](https://jsonlines.org/) for reference. [default `false`]\n* `allow_inf`: Allow reading of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing the format of dates in the JSON so that they can be read into `Date`s, `Time`s, or `DateTime`s when reading into a type. [default `Dates.default_format(T)`]\n* `parsequoted`: Accept quoted values when reading into a NumberType. [default `false`]\n* `numbertype`: Type to parse numbers as. [default `nothing`, which parses numbers as Int if possible, Float64 otherwise]\n\"\"\"\nfunction read(str::AbstractString; jsonlines::Bool=false,\n              numbertype::Union{DataType, Nothing}=nothing, kw...)\n\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if numbertype === nothing\n        checkint = true\n    elseif numbertype == Float64\n        checkint = false\n    else\n        throw(ArgumentError(\"numbertype $numbertype is not supported. \" *\n                            \"Only `nothing` (default) and `Float64` are supported so far.\"))\n    end\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1), checkint; kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any, checkint; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        obj = Object(buf, tape, Dict{Symbol, Int}())\n        populateinds!(obj)\n        return obj\n    elseif isarray(t)\n        arr = Array{geteltype(tape[2])}(buf, tape, Int[])\n        populateinds!(arr)\n        return arr\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nconst FLOAT_INT_BOUND = 2.0^53\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object, checkint; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array, checkint; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            !isfinite(float) && !allow_inf && @goto invalid\n            @check\n            # if, for example, we've already parsed floats in an array, just keep them all as floats and don't check for ints\n            if checkint\n                fp, ip = modf(float)\n                if fp == 0 && Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                    # ok great, we know the number is integral and pretty much in Int64 range\n                    if -FLOAT_INT_BOUND < float < FLOAT_INT_BOUND\n                        # easy case, integer w/ less than or equal to 53-bits of precision\n                        int = unsafe_trunc(Int64, float)\n                    else\n                        # if our integral float is > 53-bit precision, we need to reparse the Int so we don't get a lossy conversion\n                        # there are also a few floats that satisfy Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                        # that actually overflow Int64, like -9223372036854775809 and 9223372036854775808\n                        # in those cases, we're going to verify that this Int64 parsing doesn't overflow\n                        int, code, floatpos2 = Parsers.typeparser(Int64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n                        if floatpos2 < floatpos\n                            # ah, but there's one more case we need to handle: a > 53-bit precision integer given in\n                            # exponent form, like 1e17 or 9.007199254740994e15; in those cases, the truncation to Int64 *isn't* lossy\n                            int = unsafe_trunc(Int64, float)\n                        end\n                    end\n                    if code > 0\n                        @inbounds tape[tapeidx] = INT\n                        @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                        return floatpos, tapeidx + 2\n                    end\n                end\n            end\n            @inbounds tape[tapeidx] = FLOAT\n            @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}, checkint=true; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, checkint; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}, checkint=true; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        check_int = checkint ? eT != FLOAT && eT != (FLOAT | NULL) : false\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, check_int; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx, checkint=true; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        check_int = checkint ? eT != FLOAT && eT != (FLOAT | NULL) : false\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, check_int; kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "source_files_changed": ["src/read.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 44, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "df5049d0fc92c652afd54a8cd7e583f3c9cbe51e", "parent_sha": "45e5494295076e044f402fed6c2f8b9edf7cdbd9", "commit_message": "Make pretty take an AbstractString", "commit_date": "2022-11-02T20:46:56-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/pretty.jl", "target_symbol": "pretty", "signature": null, "confidence": 0.75}, "files_before": {"src/pretty.jl": "\"\"\"\n    JSON3.@pretty json_str\n\nPretty print a JSON string or an object as JSON.\n\"\"\"\nmacro pretty(json)\n    return esc(:(JSON3.pretty($json)))\nend\n\n\"\"\"\n    JSON3.AlignmentContext(alignment=:Left, indent=4, level=0, offset=0)\n\nSpecifies the indentation of a pretty JSON string.\n\n## Keyword Args\n* `alignment`: A Symbol specifying the alignment type. Can be `:Left` to left-align\n               everything or `:Colon` to align at the `:`.\n* `indent`: The number of spaces to indent each new level with.\n* `level`: The indentation level.\n* `offset`: The indentation offset.\n\"\"\"\nBase.@kwdef mutable struct AlignmentContext\n    alignment::Symbol = :Left\n    indent::UInt16 = 4\n    level::UInt16 = 0\n    offset::UInt16 = 0\n    function AlignmentContext(alignment, indent, level, offset)\n        if alignment != :Left && alignment != :Colon\n            throw(ArgumentError(\"Alignment :$(alignment) is not supported. \" * \n                                 \"Only `:Left` and `:Colon` are supported so far\"))\n        end\n        new(alignment, indent, level, offset)\n    end\nend\n\n\"\"\"\n    JSON3.pretty(x, ac=JSON3.AlignmentContext(); kw...)\n    JSON3.pretty(io, x, ac=JSON3.AlignmentContext(); kw...)\n\nPretty print a JSON string.\n\n## Args\n\n* `x`: A JSON string, or an object to write to JSON then pretty print.\n* `io`: The `IO` object to write the pretty printed string to. [default `stdout`]\n* `ac`: The `AlignmentContext` for the pretty printing. Defaults to left-aligned\n        with 4 spaces indent. See [`JSON3.AlignmentContext`](@ref) for more options.\n\n## Keyword Args\n\nSee [`JSON3.write`](@ref) and [`JSON3.read`](@ref).\n\"\"\"\npretty(str, ac=AlignmentContext(); kw...) = pretty(stdout, str, ac; kw...)\npretty(out::IO, x, ac=AlignmentContext(); kw...) = pretty(out, JSON3.write(x; kw...), ac; kw...)\nfunction pretty(out::IO, str::String, ac=AlignmentContext(); kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        return\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    # printing object?\n    if b == UInt8('{')\n        Base.write(out, \"{\\n\")\n\n        obj = JSON3.read(str; kw...)\n\n        if length(obj) == 0\n            Base.write(out, ' '^(ac.indent * ac.level + ac.offset) * \"}\")\n            return\n        end\n\n        ks = collect(keys(obj))\n        maxlen = maximum(map(sizeof, ks)) + 5\n        ac.alignment == :Colon && (ac.offset += maxlen)\n        ac.level += 1\n\n        i = 1\n        for (key, value) in obj\n            Base.write(out, ' '^(ac.level * ac.indent))\n            Base.write(out, lpad(\"\\\"$(key)\\\"\" * \": \", ac.offset, ' '))\n            pretty(out, JSON3.write(value; kw...), ac; kw...)\n            if i == length(obj)\n                ac.level -= 1\n                ac.alignment == :Colon && (ac.offset -= maxlen)\n                Base.write(out, \"\\n\" * ' '^(ac.indent * ac.level + ac.offset) * \"}\")\n            else\n                Base.write(out, \",\\n\")\n                i += 1\n            end\n        end\n    # printing array?\n    elseif b == UInt8('[')\n        Base.write(out, \"[\\n\")\n\n        arr = JSON3.read(str; kw...)\n\n        if length(arr) == 0\n            Base.write(out, ' '^(ac.indent * ac.level + ac.offset) * \"]\")\n            return\n        end\n\n        ac.level += 1\n\n        for (i, val) in enumerate(arr)\n            Base.write(out, ' '^(ac.indent * ac.level + ac.offset))\n            pretty(out, JSON3.write(val; kw...), ac; kw...)\n            if i == length(arr)\n                ac.level -= 1\n                Base.write(out, \"\\n\" * ' '^(ac.indent * ac.level + ac.offset) * \"]\")\n            else\n                Base.write(out, \",\\n\")\n            end\n        end\n    # printing constant?\n    else\n        Base.write(out, str)\n    end\n    return\n@label invalid\n    Base.error(\"error pretty-fying json: $error\")\nend\n"}, "files_after": {"src/pretty.jl": "\"\"\"\n    JSON3.@pretty json_str\n\nPretty print a JSON string or an object as JSON.\n\"\"\"\nmacro pretty(json)\n    return esc(:(JSON3.pretty($json)))\nend\n\n\"\"\"\n    JSON3.AlignmentContext(alignment=:Left, indent=4, level=0, offset=0)\n\nSpecifies the indentation of a pretty JSON string.\n\n## Keyword Args\n* `alignment`: A Symbol specifying the alignment type. Can be `:Left` to left-align\n               everything or `:Colon` to align at the `:`.\n* `indent`: The number of spaces to indent each new level with.\n* `level`: The indentation level.\n* `offset`: The indentation offset.\n\"\"\"\nBase.@kwdef mutable struct AlignmentContext\n    alignment::Symbol = :Left\n    indent::UInt16 = 4\n    level::UInt16 = 0\n    offset::UInt16 = 0\n    function AlignmentContext(alignment, indent, level, offset)\n        if alignment != :Left && alignment != :Colon\n            throw(ArgumentError(\"Alignment :$(alignment) is not supported. \" * \n                                 \"Only `:Left` and `:Colon` are supported so far\"))\n        end\n        new(alignment, indent, level, offset)\n    end\nend\n\n\"\"\"\n    JSON3.pretty(x, ac=JSON3.AlignmentContext(); kw...)\n    JSON3.pretty(io, x, ac=JSON3.AlignmentContext(); kw...)\n\nPretty print a JSON string.\n\n## Args\n\n* `x`: A JSON string, or an object to write to JSON then pretty print.\n* `io`: The `IO` object to write the pretty printed string to. [default `stdout`]\n* `ac`: The `AlignmentContext` for the pretty printing. Defaults to left-aligned\n        with 4 spaces indent. See [`JSON3.AlignmentContext`](@ref) for more options.\n\n## Keyword Args\n\nSee [`JSON3.write`](@ref) and [`JSON3.read`](@ref).\n\"\"\"\npretty(str, ac=AlignmentContext(); kw...) = pretty(stdout, str, ac; kw...)\npretty(out::IO, x, ac=AlignmentContext(); kw...) = pretty(out, JSON3.write(x; kw...), ac; kw...)\nfunction pretty(out::IO, str::AbstractString, ac=AlignmentContext(); kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        return\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    # printing object?\n    if b == UInt8('{')\n        Base.write(out, \"{\\n\")\n\n        obj = JSON3.read(str; kw...)\n\n        if length(obj) == 0\n            Base.write(out, ' '^(ac.indent * ac.level + ac.offset) * \"}\")\n            return\n        end\n\n        ks = collect(keys(obj))\n        maxlen = maximum(map(sizeof, ks)) + 5\n        ac.alignment == :Colon && (ac.offset += maxlen)\n        ac.level += 1\n\n        i = 1\n        for (key, value) in obj\n            Base.write(out, ' '^(ac.level * ac.indent))\n            Base.write(out, lpad(\"\\\"$(key)\\\"\" * \": \", ac.offset, ' '))\n            pretty(out, JSON3.write(value; kw...), ac; kw...)\n            if i == length(obj)\n                ac.level -= 1\n                ac.alignment == :Colon && (ac.offset -= maxlen)\n                Base.write(out, \"\\n\" * ' '^(ac.indent * ac.level + ac.offset) * \"}\")\n            else\n                Base.write(out, \",\\n\")\n                i += 1\n            end\n        end\n    # printing array?\n    elseif b == UInt8('[')\n        Base.write(out, \"[\\n\")\n\n        arr = JSON3.read(str; kw...)\n\n        if length(arr) == 0\n            Base.write(out, ' '^(ac.indent * ac.level + ac.offset) * \"]\")\n            return\n        end\n\n        ac.level += 1\n\n        for (i, val) in enumerate(arr)\n            Base.write(out, ' '^(ac.indent * ac.level + ac.offset))\n            pretty(out, JSON3.write(val; kw...), ac; kw...)\n            if i == length(arr)\n                ac.level -= 1\n                Base.write(out, \"\\n\" * ' '^(ac.indent * ac.level + ac.offset) * \"]\")\n            else\n                Base.write(out, \",\\n\")\n            end\n        end\n    # printing constant?\n    else\n        Base.write(out, str)\n    end\n    return\n@label invalid\n    Base.error(\"error pretty-fying json: $error\")\nend\n"}, "source_files_changed": ["src/pretty.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "85bf666f47f0fe3b7c339450ea3aeec70e0434e0", "parent_sha": "7f593adbbc4b303987bdc7bbcf232d5084c0e4ef", "commit_message": "Rely on Base for Ryu (#238)", "commit_date": "2022-10-22T02:49:49+01:00", "action": {"type": "ADD_IMPORT", "target_file": "src/JSON3.jl", "target_symbol": null, "signature": null, "confidence": 0.8}, "files_before": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap, UUIDs, Dates, StructTypes\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON object. Supports the `AbstractDict` interface. See [built in types](#Builtin-types) for more detail on why we have an `Object` type.\"\"\"\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\n    inds::Dict{Symbol, Int}\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(Int64(2)), 0], Dict{Symbol, Int}())\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON array. Supports the `AbstractArray` interface. See [built in types](#Builtin-types) for more detail on why we have an `Array` type.\"\"\"\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\n    inds::Vector{Int}\nend\n\nArray{T}(buf::S, tape::TT, inds::Vector{Int}) where {T, S, TT} = Array{T, S, TT}(buf, tape, inds)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\ngetinds(j::Union{Object, Array}) = getfield(j, :inds)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedClosingArrayChar ExpectedComma ExpectedSemiColon ExpectedNewline InvalidChar InvalidNumber\n\n# AbstractDict interface\nBase.length(obj::Object) = getnontypemask(gettape(obj)[2])\n\nfunction populateinds!(x::Object)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    i = 1\n    while i <= len\n        @inbounds t = tape[tapeidx]\n        key = getvalue(Symbol, buf, tape, tapeidx, t)\n        tapeidx += 2\n        inds[key] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\nfunction populateinds!(x::Array)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    resize!(inds, len)\n    i = 1\n    while i <= len\n        @inbounds inds[i] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    ind = getinds(obj)[key]\n    tape = gettape(obj)\n    @inbounds t = tape[ind]\n    return getvalue(Any, getbuf(obj), tape, ind, t)\nend\n\nBase.get(obj::Object, key) = get(obj, Symbol(key))\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    return get(obj, key)\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default\n    end\nend\n\nBase.get(obj::Object, key, default) = get(obj, Symbol(key), default)\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    return get(obj, key, default)\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default()\n    end\nend\n\nBase.get(default::Base.Callable, obj::Object, key) = get(default, obj, Symbol(key))\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, key) = get(obj, key)\n\n\"\"\"\n    copy(obj)\n\nRecursively copy [`JSON3.Object`](@ref)s to `Dict`s and [`JSON3.Array`](@ref)s to `Vector`s.  This copy can then be mutated if needed.\n\"\"\"\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = v isa Object || v isa Array ? copy(v) : v\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nBase.size(arr::Array) = (length(getinds(arr)),)\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    @inbounds ind = getinds(arr)[i]\n    @inbounds t = tape[ind]\n    return getvalue(T, buf, tape, ind, t)\nend\n\nBase.copy(arr::Array) = map(x->x isa Object || x isa Array ? copy(x) : x, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\ninclude(\"pretty.jl\")\ninclude(\"gentypes.jl\")\n\ninclude(\"workload.jl\")\n\nend # module\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::SingletonType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\nwrite(::SingletonType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, x; kw...)\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\n# default fallback for non-Integer/non-AbstractFloat numbers\n# conver to Float64 and write the string representation\n\"\"\"\n    JSON3.tostring(x::Real) -> String\n\nFor some number types that are `<: Real`, but not `<: Integer` or `<: AbstractFloat`,\n`tostring` provides an overload to convert `x` to an appropriate string representation\nwhich will be used for the JSON numeric representation. By default, `x` is converted\nto a `Float64` and then to a `String`.\n\"\"\"\ntostring(x::Real) = Base.string(convert(Float64, x))\n\nfunction write(::NumberType, buf, pos, len, x::T; kw...) where {T}\n    NT = StructTypes.numbertype(T)\n    if NT === T\n        # this means T hasn't overloaded numbertype\n        # and we can't StructTypes.construct since we'll just stack overflow\n        # so we call last-chance tostring that can be overloaded\n        bytes = codeunits(tostring(x))\n        sz = sizeof(bytes)\n        @check sz\n        for i = 1:sz\n            @inbounds @writechar bytes[i]\n        end\n\n        return buf, pos, len\n    else\n        write(NumberType(), buf, pos, len, StructTypes.construct(NT, x); kw...)\n    end\nend\n\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "files_after": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap, UUIDs, Dates, StructTypes\nusing Base: Ryu\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON object. Supports the `AbstractDict` interface. See [built in types](#Builtin-types) for more detail on why we have an `Object` type.\"\"\"\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\n    inds::Dict{Symbol, Int}\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(Int64(2)), 0], Dict{Symbol, Int}())\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON array. Supports the `AbstractArray` interface. See [built in types](#Builtin-types) for more detail on why we have an `Array` type.\"\"\"\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\n    inds::Vector{Int}\nend\n\nArray{T}(buf::S, tape::TT, inds::Vector{Int}) where {T, S, TT} = Array{T, S, TT}(buf, tape, inds)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\ngetinds(j::Union{Object, Array}) = getfield(j, :inds)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedClosingArrayChar ExpectedComma ExpectedSemiColon ExpectedNewline InvalidChar InvalidNumber\n\n# AbstractDict interface\nBase.length(obj::Object) = getnontypemask(gettape(obj)[2])\n\nfunction populateinds!(x::Object)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    i = 1\n    while i <= len\n        @inbounds t = tape[tapeidx]\n        key = getvalue(Symbol, buf, tape, tapeidx, t)\n        tapeidx += 2\n        inds[key] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\nfunction populateinds!(x::Array)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    resize!(inds, len)\n    i = 1\n    while i <= len\n        @inbounds inds[i] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    ind = getinds(obj)[key]\n    tape = gettape(obj)\n    @inbounds t = tape[ind]\n    return getvalue(Any, getbuf(obj), tape, ind, t)\nend\n\nBase.get(obj::Object, key) = get(obj, Symbol(key))\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    return get(obj, key)\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default\n    end\nend\n\nBase.get(obj::Object, key, default) = get(obj, Symbol(key), default)\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    return get(obj, key, default)\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default()\n    end\nend\n\nBase.get(default::Base.Callable, obj::Object, key) = get(default, obj, Symbol(key))\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, key) = get(obj, key)\n\n\"\"\"\n    copy(obj)\n\nRecursively copy [`JSON3.Object`](@ref)s to `Dict`s and [`JSON3.Array`](@ref)s to `Vector`s.  This copy can then be mutated if needed.\n\"\"\"\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = v isa Object || v isa Array ? copy(v) : v\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nBase.size(arr::Array) = (length(getinds(arr)),)\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    @inbounds ind = getinds(arr)[i]\n    @inbounds t = tape[ind]\n    return getvalue(T, buf, tape, ind, t)\nend\n\nBase.copy(arr::Array) = map(x->x isa Object || x isa Array ? copy(x) : x, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\ninclude(\"pretty.jl\")\ninclude(\"gentypes.jl\")\n\ninclude(\"workload.jl\")\n\nend # module\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::SingletonType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\nwrite(::SingletonType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, x; kw...)\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\n# default fallback for non-Integer/non-AbstractFloat numbers\n# conver to Float64 and write the string representation\n\"\"\"\n    JSON3.tostring(x::Real) -> String\n\nFor some number types that are `<: Real`, but not `<: Integer` or `<: AbstractFloat`,\n`tostring` provides an overload to convert `x` to an appropriate string representation\nwhich will be used for the JSON numeric representation. By default, `x` is converted\nto a `Float64` and then to a `String`.\n\"\"\"\ntostring(x::Real) = Base.string(convert(Float64, x))\n\nfunction write(::NumberType, buf, pos, len, x::T; kw...) where {T}\n    NT = StructTypes.numbertype(T)\n    if NT === T\n        # this means T hasn't overloaded numbertype\n        # and we can't StructTypes.construct since we'll just stack overflow\n        # so we call last-chance tostring that can be overloaded\n        bytes = codeunits(tostring(x))\n        sz = sizeof(bytes)\n        @check sz\n        for i = 1:sz\n            @inbounds @writechar bytes[i]\n        end\n\n        return buf, pos, len\n    else\n        write(NumberType(), buf, pos, len, StructTypes.construct(NT, x); kw...)\n    end\nend\n\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Ryu.neededdigits(T)\n    pos = Ryu.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "source_files_changed": ["src/JSON3.jl", "src/write.jl"], "test_files_changed": [], "lines_changed": 5, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "9f9c1db2957a775969aa6ecbd4c3fe2415b6a354", "parent_sha": "3bac427dbeb2dea3ce42e22bcc6b860f4add77bd", "commit_message": "Add SnoopPrecompile (#228)", "commit_date": "2022-10-20T21:50:51+02:00", "action": {"type": "ADD_IMPORT", "target_file": "src/JSON3.jl", "target_symbol": null, "signature": null, "confidence": 0.8}, "files_before": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap, UUIDs, Dates, StructTypes\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON object. Supports the `AbstractDict` interface. See [built in types](#Builtin-types) for more detail on why we have an `Object` type.\"\"\"\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\n    inds::Dict{Symbol, Int}\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(Int64(2)), 0], Dict{Symbol, Int}())\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON array. Supports the `AbstractArray` interface. See [built in types](#Builtin-types) for more detail on why we have an `Array` type.\"\"\"\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\n    inds::Vector{Int}\nend\n\nArray{T}(buf::S, tape::TT, inds::Vector{Int}) where {T, S, TT} = Array{T, S, TT}(buf, tape, inds)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\ngetinds(j::Union{Object, Array}) = getfield(j, :inds)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedClosingArrayChar ExpectedComma ExpectedSemiColon ExpectedNewline InvalidChar InvalidNumber\n\n# AbstractDict interface\nBase.length(obj::Object) = getnontypemask(gettape(obj)[2])\n\nfunction populateinds!(x::Object)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    i = 1\n    while i <= len\n        @inbounds t = tape[tapeidx]\n        key = getvalue(Symbol, buf, tape, tapeidx, t)\n        tapeidx += 2\n        inds[key] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\nfunction populateinds!(x::Array)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    resize!(inds, len)\n    i = 1\n    while i <= len\n        @inbounds inds[i] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    ind = getinds(obj)[key]\n    tape = gettape(obj)\n    @inbounds t = tape[ind]\n    return getvalue(Any, getbuf(obj), tape, ind, t)\nend\n\nBase.get(obj::Object, key) = get(obj, Symbol(key))\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    return get(obj, key)\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default\n    end\nend\n\nBase.get(obj::Object, key, default) = get(obj, Symbol(key), default)\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    return get(obj, key, default)\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default()\n    end\nend\n\nBase.get(default::Base.Callable, obj::Object, key) = get(default, obj, Symbol(key))\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, key) = get(obj, key)\n\n\"\"\"\n    copy(obj)\n\nRecursively copy [`JSON3.Object`](@ref)s to `Dict`s and [`JSON3.Array`](@ref)s to `Vector`s.  This copy can then be mutated if needed.\n\"\"\"\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = v isa Object || v isa Array ? copy(v) : v\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nBase.size(arr::Array) = (length(getinds(arr)),)\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    @inbounds ind = getinds(arr)[i]\n    @inbounds t = tape[ind]\n    return getvalue(T, buf, tape, ind, t)\nend\n\nBase.copy(arr::Array) = map(x->x isa Object || x isa Array ? copy(x) : x, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\ninclude(\"pretty.jl\")\ninclude(\"gentypes.jl\")\n\nend # module\n"}, "files_after": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap, UUIDs, Dates, StructTypes\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON object. Supports the `AbstractDict` interface. See [built in types](#Builtin-types) for more detail on why we have an `Object` type.\"\"\"\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\n    inds::Dict{Symbol, Int}\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(Int64(2)), 0], Dict{Symbol, Int}())\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON array. Supports the `AbstractArray` interface. See [built in types](#Builtin-types) for more detail on why we have an `Array` type.\"\"\"\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\n    inds::Vector{Int}\nend\n\nArray{T}(buf::S, tape::TT, inds::Vector{Int}) where {T, S, TT} = Array{T, S, TT}(buf, tape, inds)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\ngetinds(j::Union{Object, Array}) = getfield(j, :inds)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedClosingArrayChar ExpectedComma ExpectedSemiColon ExpectedNewline InvalidChar InvalidNumber\n\n# AbstractDict interface\nBase.length(obj::Object) = getnontypemask(gettape(obj)[2])\n\nfunction populateinds!(x::Object)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    i = 1\n    while i <= len\n        @inbounds t = tape[tapeidx]\n        key = getvalue(Symbol, buf, tape, tapeidx, t)\n        tapeidx += 2\n        inds[key] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\nfunction populateinds!(x::Array)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    resize!(inds, len)\n    i = 1\n    while i <= len\n        @inbounds inds[i] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    ind = getinds(obj)[key]\n    tape = gettape(obj)\n    @inbounds t = tape[ind]\n    return getvalue(Any, getbuf(obj), tape, ind, t)\nend\n\nBase.get(obj::Object, key) = get(obj, Symbol(key))\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    return get(obj, key)\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default\n    end\nend\n\nBase.get(obj::Object, key, default) = get(obj, Symbol(key), default)\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    return get(obj, key, default)\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default()\n    end\nend\n\nBase.get(default::Base.Callable, obj::Object, key) = get(default, obj, Symbol(key))\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, key) = get(obj, key)\n\n\"\"\"\n    copy(obj)\n\nRecursively copy [`JSON3.Object`](@ref)s to `Dict`s and [`JSON3.Array`](@ref)s to `Vector`s.  This copy can then be mutated if needed.\n\"\"\"\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = v isa Object || v isa Array ? copy(v) : v\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nBase.size(arr::Array) = (length(getinds(arr)),)\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    @inbounds ind = getinds(arr)[i]\n    @inbounds t = tape[ind]\n    return getvalue(T, buf, tape, ind, t)\nend\n\nBase.copy(arr::Array) = map(x->x isa Object || x isa Array ? copy(x) : x, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\ninclude(\"pretty.jl\")\ninclude(\"gentypes.jl\")\n\ninclude(\"workload.jl\")\n\nend # module\n", "src/workload.jl": "using SnoopPrecompile\n\n@precompile_all_calls begin\n    str = \"\"\"{\"a\": 1, \"b\": \"hello, world\", \"c\": [1, 2], \"d\": true, \"e\": null, \"f\": 1.92}\"\"\"\n\n    JSON3.read(IOBuffer(str))\n    json = JSON3.read(str)\n    for i in \"abcdef\"\n        json[i]\n    end\n\n    JSON3.read(\n        str,\n        NamedTuple{(:a, :b, :c, :d, :e, :f), Tuple{Int, String, Vector{Int}, Bool, Nothing, Float32}}\n    )\n\n    JSON3.write(IOBuffer(), json)\n    JSON3.pretty(IOBuffer(), json)\nend\n"}, "source_files_changed": ["src/JSON3.jl", "src/workload.jl"], "test_files_changed": [], "lines_changed": 23, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "3bac427dbeb2dea3ce42e22bcc6b860f4add77bd", "parent_sha": "3d542d32bc5d9fddce2feef7ce577db626e0195c", "commit_message": "Add `JSON3.tostring` for Real number overloads when writing (#236)", "commit_date": "2022-10-20T13:50:40-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.75}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::SingletonType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\nwrite(::SingletonType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, x; kw...)\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::SingletonType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\nwrite(::SingletonType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, x; kw...)\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\n# default fallback for non-Integer/non-AbstractFloat numbers\n# conver to Float64 and write the string representation\n\"\"\"\n    JSON3.tostring(x::Real) -> String\n\nFor some number types that are `<: Real`, but not `<: Integer` or `<: AbstractFloat`,\n`tostring` provides an overload to convert `x` to an appropriate string representation\nwhich will be used for the JSON numeric representation. By default, `x` is converted\nto a `Float64` and then to a `String`.\n\"\"\"\ntostring(x::Real) = Base.string(convert(Float64, x))\n\nfunction write(::NumberType, buf, pos, len, x::T; kw...) where {T}\n    NT = StructTypes.numbertype(T)\n    if NT === T\n        # this means T hasn't overloaded numbertype\n        # and we can't StructTypes.construct since we'll just stack overflow\n        # so we call last-chance tostring that can be overloaded\n        bytes = codeunits(tostring(x))\n        sz = sizeof(bytes)\n        @check sz\n        for i = 1:sz\n            @inbounds @writechar bytes[i]\n        end\n\n        return buf, pos, len\n    else\n        write(NumberType(), buf, pos, len, StructTypes.construct(NT, x); kw...)\n    end\nend\n\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 38, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "3d542d32bc5d9fddce2feef7ce577db626e0195c", "parent_sha": "3c6e0b0d106e7f2a6ca56332e6886aabfc93ebba", "commit_message": "Add singleton support (#191)", "commit_date": "2022-09-06T16:25:11+01:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "write", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\nread(::NumberType, buf, pos, len, b, ::Type{Integer}; kw...) =\n    read(NumberType(), buf, pos, len, b, Int64; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, SingletonType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\nread(::NumberType, buf, pos, len, b, ::Type{Integer}; kw...) =\n    read(NumberType(), buf, pos, len, b, Int64; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::SingletonType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\nwrite(::SingletonType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, x; kw...)\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "source_files_changed": ["src/structs.jl", "src/write.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 16, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "25c6739e88cb884cdefe32daedcf84c824907cbd", "parent_sha": "8cc44675ca7f5db298685af4e6b24666de458f7d", "commit_message": "Fix ambiguity dispatch for Integer. Fixes https://github.com/JuliaDat\u2026 (#231)", "commit_date": "2022-09-05T12:26:41-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "read", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\nread(::NumberType, buf, pos, len, b, ::Type{Integer}; kw...) =\n    read(NumberType(), buf, pos, len, b, Int64; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 20, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "6531a99a53d98e72da6d50e69fef1afc5ac00aa4", "parent_sha": "35a5d6753a27cf397763125a77c9ddd94fd4e73d", "commit_message": "fix: vector expression generation within union (#218)", "commit_date": "2022-05-19T10:47:53-04:00", "action": {"type": "ADD_FIELD", "target_file": "src/gentypes.jl", "target_symbol": null, "signature": null, "confidence": 0.7}, "files_before": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# if a union contains two named tuples, unify them\n# if union length is > 2, u.b will have continuing fields\nfunction unify_union(u)\n    if !isa(u.b, Union)\n        # because of unify methods, only need to worry about unions with len > 2\n        return u\n    end\n\n    # unions are sorted alphabetically, so pairs of super types will always be adjacent\n    type = Union{}\n    union_types = Base.uniontypes(u)\n    i = 1\n    while i <= Base.unionlen(u)\n        cur = union_types[i]\n\n        # no more nexts to compare to\n        if i == Base.unionlen(u)\n            type = Union{type,cur}\n            break\n        end\n\n        next = union_types[i+1]\n        if cur <: Vector && next <: Vector\n            type = Union{type,unify(cur, next)}\n            i += 2\n        elseif cur <: NamedTuple && next <: NamedTuple\n            type = Union{type,unify(cur, next)}\n            i += 2\n        else\n            type = Union{type,cur}\n            i += 1\n        end\n    end\n\n    return type\nend\n\n# unify two types to a single type\nfunction promoteunion(::Type{T}, ::Type{S}) where {T,S}\n    new = promote_type(T, S)\n    if !isabstracttype(new) && isconcretetype(new)\n        return new\n    else\n        return unify_union(Union{T,S})\n    end\nend\n\n# get the type of the contents\ntype_or_eltype(::Type{Vector{T}}) where {T} = T\ntype_or_eltype(::Type{T}) where {T} = T\n\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(b::Type{S}, a::Type{T}) where {T,S<:T} = T\nunify(a::Type{T}, b::Type{T}) where {T} = T\nunify(a::Type{Any}, b::Type{T}) where {T} = T\nunify(b::Type{T}, a::Type{Any}) where {T} = T\nunify(a::Type{Any}, b::Type{Any}) = Any\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\nunify(a::Type{NamedTuple{A,T}}, b::Type{NamedTuple{A,T}}) where {A,T<:Tuple} =\n    NamedTuple{A,T}\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\nunify(a::Type{Vector{T}}, b::Type{Vector{T}}) where {T} = Vector{T}\n\n# parse json into a type, maintain field order\n\"\"\"\n    JSON3.generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    if isempty(a)\n        return Vector{Any}\n    end\n\n    t = Set([])\n    nt = Any\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n# remove line number nodes\nfunction remove_line_numbers!(expr::Expr)\n    filter!(x -> !isa(x, LineNumberNode), expr.args)\n    for arg in expr.args\n        remove_line_numbers!(arg)\n    end\nend\nremove_line_numbers!(x) = nothing # no-op fallback\n\n# collapse singleton blocks into just the contained Expr\nfunction collapse_singleton_blocks!(expr::Expr)\n    if expr.head == :block && length(expr.args) == 1\n        expr.head = expr.args[1].head\n        expr.args = expr.args[1].args\n    end\n\n    for arg in expr.args\n        collapse_singleton_blocks!(arg)\n    end\nend\ncollapse_singleton_blocks!(x) = nothing # no-op fallback\n\nisunion(expr::Expr) = expr.head == :curly && length(expr.args) > 0 && expr.args[1] == :Union\nisunion(x) = false # fallback\n\n# Union{A, Union{B, C}} => Union{A, B, C}\nfunction collapse_unions!(expr::Expr)\n    if isunion(expr) && isunion(expr.args[end])\n        u = pop!(expr.args)\n        append!(expr.args, u.args[2:3])\n        collapse_unions!(expr) # catch more nested unions\n    end\n\n    for arg in expr.args\n        collapse_unions!(arg)\n    end\nend\ncollapse_unions!(x) = nothing # no-op fallback\n\n# from https://docs.julialang.org/en/v1/base/base/#Keywords\nconst RESERVED_WORDS = (\n    :baremodule,\n    :begin,\n    :break,\n    :catch,\n    :const,\n    :continue,\n    :do,\n    :else,\n    :elseif,\n    :end,\n    :export,\n    :false,\n    :finally,\n    :for,\n    :function,\n    :global,\n    :if,\n    :import,\n    :let,\n    :local,\n    :macro,\n    :module,\n    :quote,\n    :return,\n    :struct,\n    :true,\n    :try,\n    :using,\n    :while,\n)\n\nis_valid_fieldname(x::Symbol) = Base.isidentifier(x) && !(x in RESERVED_WORDS)\nis_valid_fieldname(x) = true # fallback for cases outside of x::Int\n\n# end::Int => var\"#JSON3_ESCAPE_THIS#end\"::Int (the escape token gets removed later)\nconst JSON3_ESCAPE_TOKEN = \"#JSON3_ESCAPE_THIS#\"\n@static if Base.VERSION < v\"1.3\"\n    function escape_variable_names!(expr::Expr)\n        if expr.head == :(::)\n            if !is_valid_fieldname(expr.args[1])\n                @warn \"\"\"Invalid identifier found: $(expr.args[1]).\n\n                In the types written to file, rename the field in the struct to a valid identifier and add a line `StructTypes.names(::Type{MyType}) = ((:julia_field_name, :json_field_name))` with the affected type, new Julia field name, and original JSON field name.\"\"\"\n            end\n        else\n            for arg in expr.args\n                escape_variable_names!(arg)\n            end\n        end\n    end\nelse\n    function escape_variable_names!(expr::Expr)\n        if expr.head == :(::)\n            if !is_valid_fieldname(expr.args[1])\n                # if the variable name is invalid, it will be escaped by `repr` later. This\n                # token is used to force reserved keywords to be marked as invalid and will\n                # be removed in `write_expr`..\n                expr.args[1] = Symbol(\"$JSON3_ESCAPE_TOKEN$(expr.args[1])\")\n            end\n        else\n            for arg in expr.args\n                escape_variable_names!(arg)\n            end\n        end\n    end\nend\nescape_variable_names!(x) = nothing # no-op fallback\n\n\"\"\"\n    JSON3.write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    remove_line_numbers!(expr)\n    collapse_unions!(expr)\n    collapse_singleton_blocks!(expr)\n    escape_variable_names!(expr)\n\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    str = replace(str, JSON3_ESCAPE_TOKEN => \"\") # remove the escape token\n\n    # better spacing\n    str = replace(str, \"end\\n\" => \"end\\n\\n\")\n    str = replace(str, r\"(module \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = replace(str, r\"(import \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = str[1:end-3] * \"\\nend # module\\n\"\n\n    Base.write(io, str)\n\n    return nothing\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    struct_exprs = filter(e -> e.head == :struct && e.args[2] == struct_name, exprs)\n    if length(struct_exprs) > 0 # already a struct with this name, augment it\n        new_struct_name = replace(String(gensym(struct_name)), \"#\" => \"\")\n        @info \"struct with name $struct_name already exists, changing name to $new_struct_name\"\n        struct_name = Symbol(new_struct_name)\n    end\n\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    struct_name = generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, struct_name)\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    JSON3.generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\n                \"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\",\n            ),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\nread_json_str(json_str) = read(\n    length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) : json_str,\n)\n\n\"\"\"\n    JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string, an array of json strings, or a file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate an AST with the module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str(json_str)\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\nfunction generatetypes(\n    json_str::Vector{<:AbstractString},\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str.(json_str)\n\n    # build a type for the JSON\n    raw_json_type = reduce(unify, type_or_eltype.(generate_type.(json)); init = Any)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    JSON3.@generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable = mutable, root_name = root_name)\n    write_exprs(mod, file_name)\nend\n"}, "files_after": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# if a union contains two named tuples, unify them\n# if union length is > 2, u.b will have continuing fields\nfunction unify_union(u)\n    if !isa(u.b, Union)\n        # because of unify methods, only need to worry about unions with len > 2\n        return u\n    end\n\n    # unions are sorted alphabetically, so pairs of super types will always be adjacent\n    type = Union{}\n    union_types = Base.uniontypes(u)\n    i = 1\n    while i <= Base.unionlen(u)\n        cur = union_types[i]\n\n        # no more nexts to compare to\n        if i == Base.unionlen(u)\n            type = Union{type,cur}\n            break\n        end\n\n        next = union_types[i+1]\n        if cur <: Vector && next <: Vector\n            type = Union{type,unify(cur, next)}\n            i += 2\n        elseif cur <: NamedTuple && next <: NamedTuple\n            type = Union{type,unify(cur, next)}\n            i += 2\n        else\n            type = Union{type,cur}\n            i += 1\n        end\n    end\n\n    return type\nend\n\n# unify two types to a single type\nfunction promoteunion(::Type{T}, ::Type{S}) where {T,S}\n    new = promote_type(T, S)\n    if !isabstracttype(new) && isconcretetype(new)\n        return new\n    else\n        return unify_union(Union{T,S})\n    end\nend\n\n# get the type of the contents\ntype_or_eltype(::Type{Vector{T}}) where {T} = T\ntype_or_eltype(::Type{T}) where {T} = T\n\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(b::Type{S}, a::Type{T}) where {T,S<:T} = T\nunify(a::Type{T}, b::Type{T}) where {T} = T\nunify(a::Type{Any}, b::Type{T}) where {T} = T\nunify(b::Type{T}, a::Type{Any}) where {T} = T\nunify(a::Type{Any}, b::Type{Any}) = Any\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\nunify(a::Type{NamedTuple{A,T}}, b::Type{NamedTuple{A,T}}) where {A,T<:Tuple} =\n    NamedTuple{A,T}\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\nunify(a::Type{Vector{T}}, b::Type{Vector{T}}) where {T} = Vector{T}\n\n# parse json into a type, maintain field order\n\"\"\"\n    JSON3.generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    if isempty(a)\n        return Vector{Any}\n    end\n\n    t = Set([])\n    nt = Any\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n# remove line number nodes\nfunction remove_line_numbers!(expr::Expr)\n    filter!(x -> !isa(x, LineNumberNode), expr.args)\n    for arg in expr.args\n        remove_line_numbers!(arg)\n    end\nend\nremove_line_numbers!(x) = nothing # no-op fallback\n\n# collapse singleton blocks into just the contained Expr\nfunction collapse_singleton_blocks!(expr::Expr)\n    if expr.head == :block && length(expr.args) == 1\n        expr.head = expr.args[1].head\n        expr.args = expr.args[1].args\n    end\n\n    for arg in expr.args\n        collapse_singleton_blocks!(arg)\n    end\nend\ncollapse_singleton_blocks!(x) = nothing # no-op fallback\n\nisunion(expr::Expr) = expr.head == :curly && length(expr.args) > 0 && expr.args[1] == :Union\nisunion(x) = false # fallback\n\n# Union{A, Union{B, C}} => Union{A, B, C}\nfunction collapse_unions!(expr::Expr)\n    if isunion(expr) && isunion(expr.args[end])\n        u = pop!(expr.args)\n        append!(expr.args, u.args[2:3])\n        collapse_unions!(expr) # catch more nested unions\n    end\n\n    for arg in expr.args\n        collapse_unions!(arg)\n    end\nend\ncollapse_unions!(x) = nothing # no-op fallback\n\n# from https://docs.julialang.org/en/v1/base/base/#Keywords\nconst RESERVED_WORDS = (\n    :baremodule,\n    :begin,\n    :break,\n    :catch,\n    :const,\n    :continue,\n    :do,\n    :else,\n    :elseif,\n    :end,\n    :export,\n    :false,\n    :finally,\n    :for,\n    :function,\n    :global,\n    :if,\n    :import,\n    :let,\n    :local,\n    :macro,\n    :module,\n    :quote,\n    :return,\n    :struct,\n    :true,\n    :try,\n    :using,\n    :while,\n)\n\nis_valid_fieldname(x::Symbol) = Base.isidentifier(x) && !(x in RESERVED_WORDS)\nis_valid_fieldname(x) = true # fallback for cases outside of x::Int\n\n# end::Int => var\"#JSON3_ESCAPE_THIS#end\"::Int (the escape token gets removed later)\nconst JSON3_ESCAPE_TOKEN = \"#JSON3_ESCAPE_THIS#\"\n@static if Base.VERSION < v\"1.3\"\n    function escape_variable_names!(expr::Expr)\n        if expr.head == :(::)\n            if !is_valid_fieldname(expr.args[1])\n                @warn \"\"\"Invalid identifier found: $(expr.args[1]).\n\n                In the types written to file, rename the field in the struct to a valid identifier and add a line `StructTypes.names(::Type{MyType}) = ((:julia_field_name, :json_field_name))` with the affected type, new Julia field name, and original JSON field name.\"\"\"\n            end\n        else\n            for arg in expr.args\n                escape_variable_names!(arg)\n            end\n        end\n    end\nelse\n    function escape_variable_names!(expr::Expr)\n        if expr.head == :(::)\n            if !is_valid_fieldname(expr.args[1])\n                # if the variable name is invalid, it will be escaped by `repr` later. This\n                # token is used to force reserved keywords to be marked as invalid and will\n                # be removed in `write_expr`..\n                expr.args[1] = Symbol(\"$JSON3_ESCAPE_TOKEN$(expr.args[1])\")\n            end\n        else\n            for arg in expr.args\n                escape_variable_names!(arg)\n            end\n        end\n    end\nend\nescape_variable_names!(x) = nothing # no-op fallback\n\n\"\"\"\n    JSON3.write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    remove_line_numbers!(expr)\n    collapse_unions!(expr)\n    collapse_singleton_blocks!(expr)\n    escape_variable_names!(expr)\n\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    str = replace(str, JSON3_ESCAPE_TOKEN => \"\") # remove the escape token\n\n    # better spacing\n    str = replace(str, \"end\\n\" => \"end\\n\\n\")\n    str = replace(str, r\"(module \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = replace(str, r\"(import \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = str[1:end-3] * \"\\nend # module\\n\"\n\n    Base.write(io, str)\n\n    return nothing\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable, is_root = true)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n    kwargs...,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n    struct_name = pascalcase(root_name)\n    struct_exprs = filter(e -> e.head == :struct && e.args[2] == struct_name, exprs)\n    if length(struct_exprs) > 0 # already a struct with this name, augment it\n        new_struct_name = replace(String(gensym(struct_name)), \"#\" => \"\")\n        @info \"struct with name $struct_name already exists, changing name to $new_struct_name\"\n        struct_name = Symbol(new_struct_name)\n    end\n\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n\n    return struct_name\nend\n\n# If at the root of a JSON expression, use the vectors type as the type, otherwise, generate\n# with the vector still wrapping the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    is_root::Bool = false,\n    kwargs...,\n) where {T<:NamedTuple,N}\n    if is_root\n        return generate_expr!(exprs, T, root_name; kwargs...)\n    else\n        return Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1)\n    end\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    struct_name = generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, struct_name)\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    JSON3.generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\n                \"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\",\n            ),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\nread_json_str(json_str) = read(\n    length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) : json_str,\n)\n\n\"\"\"\n    JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string, an array of json strings, or a file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate an AST with the module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str(json_str)\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\nfunction generatetypes(\n    json_str::Vector{<:AbstractString},\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str.(json_str)\n\n    # build a type for the JSON\n    raw_json_type = reduce(unify, type_or_eltype.(generate_type.(json)); init = Any)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    JSON3.@generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable = mutable, root_name = root_name)\n    write_exprs(mod, file_name)\nend\n"}, "source_files_changed": ["src/gentypes.jl"], "test_files_changed": ["test/gentypes.jl"], "lines_changed": 49, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "35a5d6753a27cf397763125a77c9ddd94fd4e73d", "parent_sha": "92b7e6b038afaf3e5e7071a5a8a97be615cd046a", "commit_message": "Make length call on Object more accurate. (#217)", "commit_date": "2022-05-07T22:57:09-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/JSON3.jl", "target_symbol": "Base.length", "signature": null, "confidence": 0.75}, "files_before": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap, UUIDs, Dates, StructTypes\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON object. Supports the `AbstractDict` interface. See [built in types](#Builtin-types) for more detail on why we have an `Object` type.\"\"\"\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\n    inds::Dict{Symbol, Int}\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(Int64(2)), 0], Dict{Symbol, Int}())\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON array. Supports the `AbstractArray` interface. See [built in types](#Builtin-types) for more detail on why we have an `Array` type.\"\"\"\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\n    inds::Vector{Int}\nend\n\nArray{T}(buf::S, tape::TT, inds::Vector{Int}) where {T, S, TT} = Array{T, S, TT}(buf, tape, inds)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\ngetinds(j::Union{Object, Array}) = getfield(j, :inds)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedClosingArrayChar ExpectedComma ExpectedSemiColon ExpectedNewline InvalidChar InvalidNumber\n\n# AbstractDict interface\nBase.length(obj::Object) = length(getinds(obj))\n\nfunction populateinds!(x::Object)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    i = 1\n    while i <= len\n        @inbounds t = tape[tapeidx]\n        key = getvalue(Symbol, buf, tape, tapeidx, t)\n        tapeidx += 2\n        inds[key] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\nfunction populateinds!(x::Array)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    resize!(inds, len)\n    i = 1\n    while i <= len\n        @inbounds inds[i] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    ind = getinds(obj)[key]\n    tape = gettape(obj)\n    @inbounds t = tape[ind]\n    return getvalue(Any, getbuf(obj), tape, ind, t)\nend\n\nBase.get(obj::Object, key) = get(obj, Symbol(key))\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    return get(obj, key)\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default\n    end\nend\n\nBase.get(obj::Object, key, default) = get(obj, Symbol(key), default)\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    return get(obj, key, default)\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default()\n    end\nend\n\nBase.get(default::Base.Callable, obj::Object, key) = get(default, obj, Symbol(key))\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, key) = get(obj, key)\n\n\"\"\"\n    copy(obj)\n\nRecursively copy [`JSON3.Object`](@ref)s to `Dict`s and [`JSON3.Array`](@ref)s to `Vector`s.  This copy can then be mutated if needed.\n\"\"\"\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = v isa Object || v isa Array ? copy(v) : v\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nBase.size(arr::Array) = (length(getinds(arr)),)\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    @inbounds ind = getinds(arr)[i]\n    @inbounds t = tape[ind]\n    return getvalue(T, buf, tape, ind, t)\nend\n\nBase.copy(arr::Array) = map(x->x isa Object || x isa Array ? copy(x) : x, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\ninclude(\"pretty.jl\")\ninclude(\"gentypes.jl\")\n\nend # module\n"}, "files_after": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap, UUIDs, Dates, StructTypes\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON object. Supports the `AbstractDict` interface. See [built in types](#Builtin-types) for more detail on why we have an `Object` type.\"\"\"\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\n    inds::Dict{Symbol, Int}\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(Int64(2)), 0], Dict{Symbol, Int}())\n\n\"\"\"An immutable (read only) struct which provides an efficient view of a JSON array. Supports the `AbstractArray` interface. See [built in types](#Builtin-types) for more detail on why we have an `Array` type.\"\"\"\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\n    inds::Vector{Int}\nend\n\nArray{T}(buf::S, tape::TT, inds::Vector{Int}) where {T, S, TT} = Array{T, S, TT}(buf, tape, inds)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\ngetinds(j::Union{Object, Array}) = getfield(j, :inds)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedClosingArrayChar ExpectedComma ExpectedSemiColon ExpectedNewline InvalidChar InvalidNumber\n\n# AbstractDict interface\nBase.length(obj::Object) = getnontypemask(gettape(obj)[2])\n\nfunction populateinds!(x::Object)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    i = 1\n    while i <= len\n        @inbounds t = tape[tapeidx]\n        key = getvalue(Symbol, buf, tape, tapeidx, t)\n        tapeidx += 2\n        inds[key] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\nfunction populateinds!(x::Array)\n    inds = getinds(x)\n    buf = getbuf(x)\n    tape = gettape(x)\n    tapeidx = 3\n    @inbounds len = getnontypemask(tape[2])\n    resize!(inds, len)\n    i = 1\n    while i <= len\n        @inbounds inds[i] = tapeidx\n        @inbounds tapeidx += gettapelen(Any, tape[tapeidx])\n        i += 1\n    end\n    return\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    ind = getinds(obj)[key]\n    tape = gettape(obj)\n    @inbounds t = tape[ind]\n    return getvalue(Any, getbuf(obj), tape, ind, t)\nend\n\nBase.get(obj::Object, key) = get(obj, Symbol(key))\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    return get(obj, key)\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default\n    end\nend\n\nBase.get(obj::Object, key, default) = get(obj, Symbol(key), default)\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    return get(obj, key, default)\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    ind = getinds(obj)\n    if haskey(ind, key)\n        return get(obj, key)\n    else\n        return default()\n    end\nend\n\nBase.get(default::Base.Callable, obj::Object, key) = get(default, obj, Symbol(key))\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, key) = get(obj, key)\n\n\"\"\"\n    copy(obj)\n\nRecursively copy [`JSON3.Object`](@ref)s to `Dict`s and [`JSON3.Array`](@ref)s to `Vector`s.  This copy can then be mutated if needed.\n\"\"\"\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = v isa Object || v isa Array ? copy(v) : v\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nBase.size(arr::Array) = (length(getinds(arr)),)\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    @inbounds ind = getinds(arr)[i]\n    @inbounds t = tape[ind]\n    return getvalue(T, buf, tape, ind, t)\nend\n\nBase.copy(arr::Array) = map(x->x isa Object || x isa Array ? copy(x) : x, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\ninclude(\"pretty.jl\")\ninclude(\"gentypes.jl\")\n\nend # module\n"}, "source_files_changed": ["src/JSON3.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "5149d2c4c41db81ea1416375e3e77576456cf7f2", "parent_sha": "1ad5ec5158353fe4f36b623d1f701a8433e33b25", "commit_message": "De-duplicate struct names (#208)", "commit_date": "2022-03-10T17:17:57-05:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/gentypes.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# if a union contains two named tuples, unify them\n# if union length is > 2, u.b will have continuing fields\nfunction unify_union(u)\n    if !isa(u.b, Union)\n        # because of unify methods, only need to worry about unions with len > 2\n        return u\n    end\n\n    # unions are sorted alphabetically, so pairs of super types will always be adjacent\n    type = Union{}\n    union_types = Base.uniontypes(u)\n    i = 1\n    while i <= Base.unionlen(u)\n        cur = union_types[i]\n\n        # no more nexts to compare to\n        if i == Base.unionlen(u)\n            type = Union{type,cur}\n            break\n        end\n\n        next = union_types[i+1]\n        if cur <: Vector && next <: Vector\n            type = Union{type,unify(cur, next)}\n            i += 2\n        elseif cur <: NamedTuple && next <: NamedTuple\n            type = Union{type,unify(cur, next)}\n            i += 2\n        else\n            type = Union{type,cur}\n            i += 1\n        end\n    end\n\n    return type\nend\n\n# unify two types to a single type\nfunction promoteunion(::Type{T}, ::Type{S}) where {T,S}\n    new = promote_type(T, S)\n    if !isabstracttype(new) && isconcretetype(new)\n        return new\n    else\n        return unify_union(Union{T,S})\n    end\nend\n\n# get the type of the contents\ntype_or_eltype(::Type{Vector{T}}) where {T} = T\ntype_or_eltype(::Type{T}) where {T} = T\n\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(b::Type{S}, a::Type{T}) where {T,S<:T} = T\nunify(a::Type{T}, b::Type{T}) where {T} = T\nunify(a::Type{Any}, b::Type{T}) where {T} = T\nunify(b::Type{T}, a::Type{Any}) where {T} = T\nunify(a::Type{Any}, b::Type{Any}) = Any\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\nunify(a::Type{NamedTuple{A,T}}, b::Type{NamedTuple{A,T}}) where {A,T<:Tuple} =\n    NamedTuple{A,T}\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\nunify(a::Type{Vector{T}}, b::Type{Vector{T}}) where {T} = Vector{T}\n\n# parse json into a type, maintain field order\n\"\"\"\n    JSON3.generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    if isempty(a)\n        return Vector{Any}\n    end\n\n    t = Set([])\n    nt = Any\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n# remove line number nodes\nfunction remove_line_numbers!(expr::Expr)\n    filter!(x -> !isa(x, LineNumberNode), expr.args)\n    for arg in expr.args\n        remove_line_numbers!(arg)\n    end\nend\nremove_line_numbers!(x) = nothing # no-op fallback\n\n# collapse singleton blocks into just the contained Expr\nfunction collapse_singleton_blocks!(expr::Expr)\n    if expr.head == :block && length(expr.args) == 1\n        expr.head = expr.args[1].head\n        expr.args = expr.args[1].args\n    end\n\n    for arg in expr.args\n        collapse_singleton_blocks!(arg)\n    end\nend\ncollapse_singleton_blocks!(x) = nothing # no-op fallback\n\nisunion(expr::Expr) = expr.head == :curly && length(expr.args) > 0 && expr.args[1] == :Union\nisunion(x) = false # fallback\n\n# Union{A, Union{B, C}} => Union{A, B, C}\nfunction collapse_unions!(expr::Expr)\n    if isunion(expr) && isunion(expr.args[end])\n        u = pop!(expr.args)\n        append!(expr.args, u.args[2:3])\n        collapse_unions!(expr) # catch more nested unions\n    end\n\n    for arg in expr.args\n        collapse_unions!(arg)\n    end\nend\ncollapse_unions!(x) = nothing # no-op fallback\n\n# from https://docs.julialang.org/en/v1/base/base/#Keywords\nconst RESERVED_WORDS = (\n    :baremodule,\n    :begin,\n    :break,\n    :catch,\n    :const,\n    :continue,\n    :do,\n    :else,\n    :elseif,\n    :end,\n    :export,\n    :false,\n    :finally,\n    :for,\n    :function,\n    :global,\n    :if,\n    :import,\n    :let,\n    :local,\n    :macro,\n    :module,\n    :quote,\n    :return,\n    :struct,\n    :true,\n    :try,\n    :using,\n    :while,\n)\n\nis_valid_fieldname(x::Symbol) = Base.isidentifier(x) && !(x in RESERVED_WORDS)\nis_valid_fieldname(x) = true # fallback for cases outside of x::Int\n\n# end::Int => var\"#JSON3_ESCAPE_THIS#end\"::Int (the escape token gets removed later)\nconst JSON3_ESCAPE_TOKEN = \"#JSON3_ESCAPE_THIS#\"\n@static if Base.VERSION < v\"1.3\"\n    function escape_variable_names!(expr::Expr)\n        if expr.head == :(::)\n            if !is_valid_fieldname(expr.args[1])\n                @warn \"\"\"Invalid identifier found: $(expr.args[1]).\n\n                In the types written to file, rename the field in the struct to a valid identifier and add a line `StructTypes.names(::Type{MyType}) = ((:julia_field_name, :json_field_name))` with the affected type, new Julia field name, and original JSON field name.\"\"\"\n            end\n        else\n            for arg in expr.args\n                escape_variable_names!(arg)\n            end\n        end\n    end\nelse\n    function escape_variable_names!(expr::Expr)\n        if expr.head == :(::)\n            if !is_valid_fieldname(expr.args[1])\n                # if the variable name is invalid, it will be escaped by `repr` later. This\n                # token is used to force reserved keywords to be marked as invalid and will\n                # be removed in `write_expr`..\n                expr.args[1] = Symbol(\"$JSON3_ESCAPE_TOKEN$(expr.args[1])\")\n            end\n        else\n            for arg in expr.args\n                escape_variable_names!(arg)\n            end\n        end\n    end\nend\nescape_variable_names!(x) = nothing # no-op fallback\n\n\"\"\"\n    JSON3.write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    remove_line_numbers!(expr)\n    collapse_unions!(expr)\n    collapse_singleton_blocks!(expr)\n    escape_variable_names!(expr)\n\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    str = replace(str, JSON3_ESCAPE_TOKEN => \"\") # remove the escape token\n\n    # better spacing\n    str = replace(str, \"end\\n\" => \"end\\n\\n\")\n    str = replace(str, r\"(module \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = replace(str, r\"(import \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = str[1:end-3] * \"\\nend # module\\n\"\n\n    Base.write(io, str)\n\n    return nothing\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    JSON3.generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\n                \"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\",\n            ),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\nread_json_str(json_str) = read(\n    length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) : json_str,\n)\n\n\"\"\"\n    JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string, an array of json strings, or a file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate an AST with the module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str(json_str)\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\nfunction generatetypes(\n    json_str::Vector{<:AbstractString},\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str.(json_str)\n\n    # build a type for the JSON\n    raw_json_type = reduce(unify, type_or_eltype.(generate_type.(json)); init = Any)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    JSON3.@generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable = mutable, root_name = root_name)\n    write_exprs(mod, file_name)\nend\n"}, "files_after": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# if a union contains two named tuples, unify them\n# if union length is > 2, u.b will have continuing fields\nfunction unify_union(u)\n    if !isa(u.b, Union)\n        # because of unify methods, only need to worry about unions with len > 2\n        return u\n    end\n\n    # unions are sorted alphabetically, so pairs of super types will always be adjacent\n    type = Union{}\n    union_types = Base.uniontypes(u)\n    i = 1\n    while i <= Base.unionlen(u)\n        cur = union_types[i]\n\n        # no more nexts to compare to\n        if i == Base.unionlen(u)\n            type = Union{type,cur}\n            break\n        end\n\n        next = union_types[i+1]\n        if cur <: Vector && next <: Vector\n            type = Union{type,unify(cur, next)}\n            i += 2\n        elseif cur <: NamedTuple && next <: NamedTuple\n            type = Union{type,unify(cur, next)}\n            i += 2\n        else\n            type = Union{type,cur}\n            i += 1\n        end\n    end\n\n    return type\nend\n\n# unify two types to a single type\nfunction promoteunion(::Type{T}, ::Type{S}) where {T,S}\n    new = promote_type(T, S)\n    if !isabstracttype(new) && isconcretetype(new)\n        return new\n    else\n        return unify_union(Union{T,S})\n    end\nend\n\n# get the type of the contents\ntype_or_eltype(::Type{Vector{T}}) where {T} = T\ntype_or_eltype(::Type{T}) where {T} = T\n\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(b::Type{S}, a::Type{T}) where {T,S<:T} = T\nunify(a::Type{T}, b::Type{T}) where {T} = T\nunify(a::Type{Any}, b::Type{T}) where {T} = T\nunify(b::Type{T}, a::Type{Any}) where {T} = T\nunify(a::Type{Any}, b::Type{Any}) = Any\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\nunify(a::Type{NamedTuple{A,T}}, b::Type{NamedTuple{A,T}}) where {A,T<:Tuple} =\n    NamedTuple{A,T}\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\nunify(a::Type{Vector{T}}, b::Type{Vector{T}}) where {T} = Vector{T}\n\n# parse json into a type, maintain field order\n\"\"\"\n    JSON3.generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    if isempty(a)\n        return Vector{Any}\n    end\n\n    t = Set([])\n    nt = Any\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n# remove line number nodes\nfunction remove_line_numbers!(expr::Expr)\n    filter!(x -> !isa(x, LineNumberNode), expr.args)\n    for arg in expr.args\n        remove_line_numbers!(arg)\n    end\nend\nremove_line_numbers!(x) = nothing # no-op fallback\n\n# collapse singleton blocks into just the contained Expr\nfunction collapse_singleton_blocks!(expr::Expr)\n    if expr.head == :block && length(expr.args) == 1\n        expr.head = expr.args[1].head\n        expr.args = expr.args[1].args\n    end\n\n    for arg in expr.args\n        collapse_singleton_blocks!(arg)\n    end\nend\ncollapse_singleton_blocks!(x) = nothing # no-op fallback\n\nisunion(expr::Expr) = expr.head == :curly && length(expr.args) > 0 && expr.args[1] == :Union\nisunion(x) = false # fallback\n\n# Union{A, Union{B, C}} => Union{A, B, C}\nfunction collapse_unions!(expr::Expr)\n    if isunion(expr) && isunion(expr.args[end])\n        u = pop!(expr.args)\n        append!(expr.args, u.args[2:3])\n        collapse_unions!(expr) # catch more nested unions\n    end\n\n    for arg in expr.args\n        collapse_unions!(arg)\n    end\nend\ncollapse_unions!(x) = nothing # no-op fallback\n\n# from https://docs.julialang.org/en/v1/base/base/#Keywords\nconst RESERVED_WORDS = (\n    :baremodule,\n    :begin,\n    :break,\n    :catch,\n    :const,\n    :continue,\n    :do,\n    :else,\n    :elseif,\n    :end,\n    :export,\n    :false,\n    :finally,\n    :for,\n    :function,\n    :global,\n    :if,\n    :import,\n    :let,\n    :local,\n    :macro,\n    :module,\n    :quote,\n    :return,\n    :struct,\n    :true,\n    :try,\n    :using,\n    :while,\n)\n\nis_valid_fieldname(x::Symbol) = Base.isidentifier(x) && !(x in RESERVED_WORDS)\nis_valid_fieldname(x) = true # fallback for cases outside of x::Int\n\n# end::Int => var\"#JSON3_ESCAPE_THIS#end\"::Int (the escape token gets removed later)\nconst JSON3_ESCAPE_TOKEN = \"#JSON3_ESCAPE_THIS#\"\n@static if Base.VERSION < v\"1.3\"\n    function escape_variable_names!(expr::Expr)\n        if expr.head == :(::)\n            if !is_valid_fieldname(expr.args[1])\n                @warn \"\"\"Invalid identifier found: $(expr.args[1]).\n\n                In the types written to file, rename the field in the struct to a valid identifier and add a line `StructTypes.names(::Type{MyType}) = ((:julia_field_name, :json_field_name))` with the affected type, new Julia field name, and original JSON field name.\"\"\"\n            end\n        else\n            for arg in expr.args\n                escape_variable_names!(arg)\n            end\n        end\n    end\nelse\n    function escape_variable_names!(expr::Expr)\n        if expr.head == :(::)\n            if !is_valid_fieldname(expr.args[1])\n                # if the variable name is invalid, it will be escaped by `repr` later. This\n                # token is used to force reserved keywords to be marked as invalid and will\n                # be removed in `write_expr`..\n                expr.args[1] = Symbol(\"$JSON3_ESCAPE_TOKEN$(expr.args[1])\")\n            end\n        else\n            for arg in expr.args\n                escape_variable_names!(arg)\n            end\n        end\n    end\nend\nescape_variable_names!(x) = nothing # no-op fallback\n\n\"\"\"\n    JSON3.write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    remove_line_numbers!(expr)\n    collapse_unions!(expr)\n    collapse_singleton_blocks!(expr)\n    escape_variable_names!(expr)\n\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    str = replace(str, JSON3_ESCAPE_TOKEN => \"\") # remove the escape token\n\n    # better spacing\n    str = replace(str, \"end\\n\" => \"end\\n\\n\")\n    str = replace(str, r\"(module \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = replace(str, r\"(import \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = str[1:end-3] * \"\\nend # module\\n\"\n\n    Base.write(io, str)\n\n    return nothing\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    struct_exprs = filter(e -> e.head == :struct && e.args[2] == struct_name, exprs)\n    if length(struct_exprs) > 0 # already a struct with this name, augment it\n        new_struct_name = replace(String(gensym(struct_name)), \"#\" => \"\")\n        @info \"struct with name $struct_name already exists, changing name to $new_struct_name\"\n        struct_name = Symbol(new_struct_name)\n    end\n\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    struct_name = generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, struct_name)\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    JSON3.generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\n                \"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\",\n            ),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\nread_json_str(json_str) = read(\n    length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) : json_str,\n)\n\n\"\"\"\n    JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string, an array of json strings, or a file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate an AST with the module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str(json_str)\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\nfunction generatetypes(\n    json_str::Vector{<:AbstractString},\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str.(json_str)\n\n    # build a type for the JSON\n    raw_json_type = reduce(unify, type_or_eltype.(generate_type.(json)); init = Any)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    JSON3.@generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable = mutable, root_name = root_name)\n    write_exprs(mod, file_name)\nend\n"}, "source_files_changed": ["src/gentypes.jl"], "test_files_changed": ["test/gentypes.jl"], "lines_changed": 38, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "34cd92ac342ce0fad642ce2302d7315cc3a5ed39", "parent_sha": "76eb977654c81d092c0b19a07a25e8a84973c623", "commit_message": "Don't manually inline read on Struct to avoid excessive compilation (#206)", "commit_date": "2022-03-05T20:21:21-07:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "read", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "76eb977654c81d092c0b19a07a25e8a84973c623", "parent_sha": "a538fc918bb7203829c6a3d6dad258823f4f91c2", "commit_message": "fix: union unification and collapse (#200)", "commit_date": "2022-01-10T21:10:48-05:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/gentypes.jl", "target_symbol": "promoteunion", "signature": null, "confidence": 0.75}, "files_before": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nfunction promoteunion(T, S)\n    new = promote_type(T, S)\n    return isabstracttype(new) ? Union{T,S} : new\nend\n\n# get the type of the contents\ntype_or_eltype(::Type{Vector{T}}) where {T} = T\ntype_or_eltype(::Type{T}) where {T} = T\n\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(b::Type{S}, a::Type{T}) where {T,S<:T} = T\nunify(a::Type{T}, b::Type{T}) where {T} = T\nunify(a::Type{Any}, b::Type{T}) where {T} = T\nunify(b::Type{T}, a::Type{Any}) where {T} = T\nunify(a::Type{Any}, b::Type{Any}) = Any\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\nunify(a::Type{NamedTuple{A,T}}, b::Type{NamedTuple{A,T}}) where {A,T<:Tuple} =\n    NamedTuple{A,T}\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\nunify(a::Type{Vector{T}}, b::Type{Vector{T}}) where {T} = Vector{T}\n\n# parse json into a type, maintain field order\n\"\"\"\n    JSON3.generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    if isempty(a)\n        return Vector{Any}\n    end\n\n    t = Set([])\n    nt = Any\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n# remove line number nodes\nfunction remove_line_numbers!(expr::Expr)\n    filter!(x -> !isa(x, LineNumberNode), expr.args)\n    for arg in expr.args\n        remove_line_numbers!(arg)\n    end\nend\nremove_line_numbers!(x) = nothing # no-op fallback\n\n# collapse singleton blocks into just the contained Expr\nfunction collapse_singleton_blocks!(expr::Expr)\n    if expr.head == :block && length(expr.args) == 1\n        expr.head = expr.args[1].head\n        expr.args = expr.args[1].args\n    end\n\n    for arg in expr.args\n        collapse_singleton_blocks!(arg)\n    end\nend\ncollapse_singleton_blocks!(x) = nothing # no-op fallback\n\n# Union{A, Union{B, C}} => Union{A, B, C}\nfunction collapse_unions!(expr::Expr)\n    if expr.head == :curly && length(expr.args) > 0 && expr.args[1] == :Union\n        if isa(expr.args[end], Expr) # nested union\n            u = pop!(expr.args)\n            append!(expr.args, u.args[2:3])\n            collapse_unions!(expr) # catch more nested unions\n        end\n    end\n\n    for arg in expr.args\n        collapse_unions!(arg)\n    end\nend\ncollapse_unions!(x) = nothing # no-op fallback\n\n# from https://docs.julialang.org/en/v1/base/base/#Keywords\nconst RESERVED_WORDS = (\n    :baremodule,\n    :begin,\n    :break,\n    :catch,\n    :const,\n    :continue,\n    :do,\n    :else,\n    :elseif,\n    :end,\n    :export,\n    :false,\n    :finally,\n    :for,\n    :function,\n    :global,\n    :if,\n    :import,\n    :let,\n    :local,\n    :macro,\n    :module,\n    :quote,\n    :return,\n    :struct,\n    :true,\n    :try,\n    :using,\n    :while,\n)\n\nis_valid_fieldname(x::Symbol) = Base.isidentifier(x) && !(x in RESERVED_WORDS)\nis_valid_fieldname(x) = true # fallback for cases outside of x::Int\n\n# end::Int => var\"#JSON3_ESCAPE_THIS#end\"::Int (the escape token gets removed later)\nconst JSON3_ESCAPE_TOKEN = \"#JSON3_ESCAPE_THIS#\"\n@static if Base.VERSION < v\"1.3\"\n    function escape_variable_names!(expr::Expr)\n        if expr.head == :(::)\n            if !is_valid_fieldname(expr.args[1])\n                @warn \"\"\"Invalid identifier found: $(expr.args[1]).\n\n                In the types written to file, rename the field in the struct to a valid identifier and add a line `StructTypes.names(::Type{MyType}) = ((:julia_field_name, :json_field_name))` with the affected type, new Julia field name, and original JSON field name.\"\"\"\n            end\n        else\n            for arg in expr.args\n                escape_variable_names!(arg)\n            end\n        end\n    end\nelse\n    function escape_variable_names!(expr::Expr)\n        if expr.head == :(::)\n            if !is_valid_fieldname(expr.args[1])\n                # if the variable name is invalid, it will be escaped by `repr` later. This\n                # token is used to force reserved keywords to be marked as invalid and will\n                # be removed in `write_expr`..\n                expr.args[1] = Symbol(\"$JSON3_ESCAPE_TOKEN$(expr.args[1])\")\n            end\n        else\n            for arg in expr.args\n                escape_variable_names!(arg)\n            end\n        end\n    end\nend\nescape_variable_names!(x) = nothing # no-op fallback\n\n\"\"\"\n    JSON3.write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    remove_line_numbers!(expr)\n    collapse_unions!(expr)\n    collapse_singleton_blocks!(expr)\n    escape_variable_names!(expr)\n\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    str = replace(str, JSON3_ESCAPE_TOKEN => \"\") # remove the escape token\n\n    # better spacing\n    str = replace(str, \"end\\n\" => \"end\\n\\n\")\n    str = replace(str, r\"(module \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = replace(str, r\"(import \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = str[1:end-3] * \"\\nend # module\\n\"\n\n    Base.write(io, str)\n\n    return nothing\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    JSON3.generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\n                \"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\",\n            ),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\nread_json_str(json_str) = read(\n    length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) : json_str,\n)\n\n\"\"\"\n    JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string, an array of json strings, or a file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate an AST with the module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str(json_str)\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\nfunction generatetypes(\n    json_str::Vector{<:AbstractString},\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str.(json_str)\n\n    # build a type for the JSON\n    raw_json_type = reduce(unify, type_or_eltype.(generate_type.(json)); init = Any)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    JSON3.@generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable = mutable, root_name = root_name)\n    write_exprs(mod, file_name)\nend\n"}, "files_after": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# if a union contains two named tuples, unify them\n# if union length is > 2, u.b will have continuing fields\nfunction unify_union(u)\n    if !isa(u.b, Union)\n        # because of unify methods, only need to worry about unions with len > 2\n        return u\n    end\n\n    # unions are sorted alphabetically, so pairs of super types will always be adjacent\n    type = Union{}\n    union_types = Base.uniontypes(u)\n    i = 1\n    while i <= Base.unionlen(u)\n        cur = union_types[i]\n\n        # no more nexts to compare to\n        if i == Base.unionlen(u)\n            type = Union{type,cur}\n            break\n        end\n\n        next = union_types[i+1]\n        if cur <: Vector && next <: Vector\n            type = Union{type,unify(cur, next)}\n            i += 2\n        elseif cur <: NamedTuple && next <: NamedTuple\n            type = Union{type,unify(cur, next)}\n            i += 2\n        else\n            type = Union{type,cur}\n            i += 1\n        end\n    end\n\n    return type\nend\n\n# unify two types to a single type\nfunction promoteunion(::Type{T}, ::Type{S}) where {T,S}\n    new = promote_type(T, S)\n    if !isabstracttype(new) && isconcretetype(new)\n        return new\n    else\n        return unify_union(Union{T,S})\n    end\nend\n\n# get the type of the contents\ntype_or_eltype(::Type{Vector{T}}) where {T} = T\ntype_or_eltype(::Type{T}) where {T} = T\n\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(b::Type{S}, a::Type{T}) where {T,S<:T} = T\nunify(a::Type{T}, b::Type{T}) where {T} = T\nunify(a::Type{Any}, b::Type{T}) where {T} = T\nunify(b::Type{T}, a::Type{Any}) where {T} = T\nunify(a::Type{Any}, b::Type{Any}) = Any\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\nunify(a::Type{NamedTuple{A,T}}, b::Type{NamedTuple{A,T}}) where {A,T<:Tuple} =\n    NamedTuple{A,T}\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\nunify(a::Type{Vector{T}}, b::Type{Vector{T}}) where {T} = Vector{T}\n\n# parse json into a type, maintain field order\n\"\"\"\n    JSON3.generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    if isempty(a)\n        return Vector{Any}\n    end\n\n    t = Set([])\n    nt = Any\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n# remove line number nodes\nfunction remove_line_numbers!(expr::Expr)\n    filter!(x -> !isa(x, LineNumberNode), expr.args)\n    for arg in expr.args\n        remove_line_numbers!(arg)\n    end\nend\nremove_line_numbers!(x) = nothing # no-op fallback\n\n# collapse singleton blocks into just the contained Expr\nfunction collapse_singleton_blocks!(expr::Expr)\n    if expr.head == :block && length(expr.args) == 1\n        expr.head = expr.args[1].head\n        expr.args = expr.args[1].args\n    end\n\n    for arg in expr.args\n        collapse_singleton_blocks!(arg)\n    end\nend\ncollapse_singleton_blocks!(x) = nothing # no-op fallback\n\nisunion(expr::Expr) = expr.head == :curly && length(expr.args) > 0 && expr.args[1] == :Union\nisunion(x) = false # fallback\n\n# Union{A, Union{B, C}} => Union{A, B, C}\nfunction collapse_unions!(expr::Expr)\n    if isunion(expr) && isunion(expr.args[end])\n        u = pop!(expr.args)\n        append!(expr.args, u.args[2:3])\n        collapse_unions!(expr) # catch more nested unions\n    end\n\n    for arg in expr.args\n        collapse_unions!(arg)\n    end\nend\ncollapse_unions!(x) = nothing # no-op fallback\n\n# from https://docs.julialang.org/en/v1/base/base/#Keywords\nconst RESERVED_WORDS = (\n    :baremodule,\n    :begin,\n    :break,\n    :catch,\n    :const,\n    :continue,\n    :do,\n    :else,\n    :elseif,\n    :end,\n    :export,\n    :false,\n    :finally,\n    :for,\n    :function,\n    :global,\n    :if,\n    :import,\n    :let,\n    :local,\n    :macro,\n    :module,\n    :quote,\n    :return,\n    :struct,\n    :true,\n    :try,\n    :using,\n    :while,\n)\n\nis_valid_fieldname(x::Symbol) = Base.isidentifier(x) && !(x in RESERVED_WORDS)\nis_valid_fieldname(x) = true # fallback for cases outside of x::Int\n\n# end::Int => var\"#JSON3_ESCAPE_THIS#end\"::Int (the escape token gets removed later)\nconst JSON3_ESCAPE_TOKEN = \"#JSON3_ESCAPE_THIS#\"\n@static if Base.VERSION < v\"1.3\"\n    function escape_variable_names!(expr::Expr)\n        if expr.head == :(::)\n            if !is_valid_fieldname(expr.args[1])\n                @warn \"\"\"Invalid identifier found: $(expr.args[1]).\n\n                In the types written to file, rename the field in the struct to a valid identifier and add a line `StructTypes.names(::Type{MyType}) = ((:julia_field_name, :json_field_name))` with the affected type, new Julia field name, and original JSON field name.\"\"\"\n            end\n        else\n            for arg in expr.args\n                escape_variable_names!(arg)\n            end\n        end\n    end\nelse\n    function escape_variable_names!(expr::Expr)\n        if expr.head == :(::)\n            if !is_valid_fieldname(expr.args[1])\n                # if the variable name is invalid, it will be escaped by `repr` later. This\n                # token is used to force reserved keywords to be marked as invalid and will\n                # be removed in `write_expr`..\n                expr.args[1] = Symbol(\"$JSON3_ESCAPE_TOKEN$(expr.args[1])\")\n            end\n        else\n            for arg in expr.args\n                escape_variable_names!(arg)\n            end\n        end\n    end\nend\nescape_variable_names!(x) = nothing # no-op fallback\n\n\"\"\"\n    JSON3.write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    remove_line_numbers!(expr)\n    collapse_unions!(expr)\n    collapse_singleton_blocks!(expr)\n    escape_variable_names!(expr)\n\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    str = replace(str, JSON3_ESCAPE_TOKEN => \"\") # remove the escape token\n\n    # better spacing\n    str = replace(str, \"end\\n\" => \"end\\n\\n\")\n    str = replace(str, r\"(module \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = replace(str, r\"(import \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = str[1:end-3] * \"\\nend # module\\n\"\n\n    Base.write(io, str)\n\n    return nothing\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    JSON3.generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\n                \"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\",\n            ),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\nread_json_str(json_str) = read(\n    length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) : json_str,\n)\n\n\"\"\"\n    JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string, an array of json strings, or a file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate an AST with the module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str(json_str)\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\nfunction generatetypes(\n    json_str::Vector{<:AbstractString},\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str.(json_str)\n\n    # build a type for the JSON\n    raw_json_type = reduce(unify, type_or_eltype.(generate_type.(json)); init = Any)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    JSON3.@generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable = mutable, root_name = root_name)\n    write_exprs(mod, file_name)\nend\n"}, "source_files_changed": ["src/gentypes.jl"], "test_files_changed": ["test/gentypes.jl"], "lines_changed": 70, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "a538fc918bb7203829c6a3d6dad258823f4f91c2", "parent_sha": "da19d8e724af4376f2a3198a794bcf9ebe39b66c", "commit_message": "fix: escape reserved keywords when writing structs to file (#199)", "commit_date": "2022-01-10T21:06:48-05:00", "action": {"type": "ADD_METHOD", "target_file": "src/gentypes.jl", "target_symbol": "is_valid_fieldname", "signature": null, "confidence": 0.85}, "files_before": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nfunction promoteunion(T, S)\n    new = promote_type(T, S)\n    return isabstracttype(new) ? Union{T,S} : new\nend\n\n# get the type of the contents\ntype_or_eltype(::Type{Vector{T}}) where {T} = T\ntype_or_eltype(::Type{T}) where {T} = T\n\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(b::Type{S}, a::Type{T}) where {T,S<:T} = T\nunify(a::Type{T}, b::Type{T}) where {T} = T\nunify(a::Type{Any}, b::Type{T}) where {T} = T\nunify(b::Type{T}, a::Type{Any}) where {T} = T\nunify(a::Type{Any}, b::Type{Any}) = Any\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\nunify(a::Type{NamedTuple{A,T}}, b::Type{NamedTuple{A,T}}) where {A,T<:Tuple} =\n    NamedTuple{A,T}\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\nunify(a::Type{Vector{T}}, b::Type{Vector{T}}) where {T} = Vector{T}\n\n# parse json into a type, maintain field order\n\"\"\"\n    JSON3.generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    if isempty(a)\n        return Vector{Any}\n    end\n\n    t = Set([])\n    nt = Any\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n# remove line number nodes\nfunction remove_line_numbers!(expr::Expr)\n    filter!(x -> !isa(x, LineNumberNode), expr.args)\n    for arg in expr.args\n        remove_line_numbers!(arg)\n    end\nend\nremove_line_numbers!(x) = nothing # no-op fallback\n\n# collapse singleton blocks into just the contained Expr\nfunction collapse_singleton_blocks!(expr::Expr)\n    if expr.head == :block && length(expr.args) == 1\n        expr.head = expr.args[1].head\n        expr.args = expr.args[1].args\n    end\n\n    for arg in expr.args\n        collapse_singleton_blocks!(arg)\n    end\nend\ncollapse_singleton_blocks!(x) = nothing # no-op fallback\n\n# Union{A, Union{B, C}} => Union{A, B, C}\nfunction collapse_unions!(expr::Expr)\n    if expr.head == :curly && length(expr.args) > 0 && expr.args[1] == :Union\n        if isa(expr.args[end], Expr) # nested union\n            u = pop!(expr.args)\n            append!(expr.args, u.args[2:3])\n            collapse_unions!(expr) # catch more nested unions\n        end\n    end\n\n    for arg in expr.args\n        collapse_unions!(arg)\n    end\nend\ncollapse_unions!(x) = nothing # no-op fallback\n\n\"\"\"\n    JSON3.write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    remove_line_numbers!(expr)\n    collapse_unions!(expr)\n    collapse_singleton_blocks!(expr)\n\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n\n    # better spacing\n    str = replace(str, \"end\\n\" => \"end\\n\\n\")\n    str = replace(str, r\"(module \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = replace(str, r\"(import \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = str[1:end-3] * \"\\nend # module\\n\"\n\n    Base.write(io, str)\n\n    return nothing\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    JSON3.generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\n                \"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\",\n            ),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\nread_json_str(json_str) = read(\n    length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) : json_str,\n)\n\n\"\"\"\n    JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string, an array of json strings, or a file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate an AST with the module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str(json_str)\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\nfunction generatetypes(\n    json_str::Vector{<:AbstractString},\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str.(json_str)\n\n    # build a type for the JSON\n    raw_json_type = reduce(unify, type_or_eltype.(generate_type.(json)); init = Any)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    JSON3.@generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable = mutable, root_name = root_name)\n    write_exprs(mod, file_name)\nend\n"}, "files_after": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nfunction promoteunion(T, S)\n    new = promote_type(T, S)\n    return isabstracttype(new) ? Union{T,S} : new\nend\n\n# get the type of the contents\ntype_or_eltype(::Type{Vector{T}}) where {T} = T\ntype_or_eltype(::Type{T}) where {T} = T\n\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(b::Type{S}, a::Type{T}) where {T,S<:T} = T\nunify(a::Type{T}, b::Type{T}) where {T} = T\nunify(a::Type{Any}, b::Type{T}) where {T} = T\nunify(b::Type{T}, a::Type{Any}) where {T} = T\nunify(a::Type{Any}, b::Type{Any}) = Any\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\nunify(a::Type{NamedTuple{A,T}}, b::Type{NamedTuple{A,T}}) where {A,T<:Tuple} =\n    NamedTuple{A,T}\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\nunify(a::Type{Vector{T}}, b::Type{Vector{T}}) where {T} = Vector{T}\n\n# parse json into a type, maintain field order\n\"\"\"\n    JSON3.generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    if isempty(a)\n        return Vector{Any}\n    end\n\n    t = Set([])\n    nt = Any\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n# remove line number nodes\nfunction remove_line_numbers!(expr::Expr)\n    filter!(x -> !isa(x, LineNumberNode), expr.args)\n    for arg in expr.args\n        remove_line_numbers!(arg)\n    end\nend\nremove_line_numbers!(x) = nothing # no-op fallback\n\n# collapse singleton blocks into just the contained Expr\nfunction collapse_singleton_blocks!(expr::Expr)\n    if expr.head == :block && length(expr.args) == 1\n        expr.head = expr.args[1].head\n        expr.args = expr.args[1].args\n    end\n\n    for arg in expr.args\n        collapse_singleton_blocks!(arg)\n    end\nend\ncollapse_singleton_blocks!(x) = nothing # no-op fallback\n\n# Union{A, Union{B, C}} => Union{A, B, C}\nfunction collapse_unions!(expr::Expr)\n    if expr.head == :curly && length(expr.args) > 0 && expr.args[1] == :Union\n        if isa(expr.args[end], Expr) # nested union\n            u = pop!(expr.args)\n            append!(expr.args, u.args[2:3])\n            collapse_unions!(expr) # catch more nested unions\n        end\n    end\n\n    for arg in expr.args\n        collapse_unions!(arg)\n    end\nend\ncollapse_unions!(x) = nothing # no-op fallback\n\n# from https://docs.julialang.org/en/v1/base/base/#Keywords\nconst RESERVED_WORDS = (\n    :baremodule,\n    :begin,\n    :break,\n    :catch,\n    :const,\n    :continue,\n    :do,\n    :else,\n    :elseif,\n    :end,\n    :export,\n    :false,\n    :finally,\n    :for,\n    :function,\n    :global,\n    :if,\n    :import,\n    :let,\n    :local,\n    :macro,\n    :module,\n    :quote,\n    :return,\n    :struct,\n    :true,\n    :try,\n    :using,\n    :while,\n)\n\nis_valid_fieldname(x::Symbol) = Base.isidentifier(x) && !(x in RESERVED_WORDS)\nis_valid_fieldname(x) = true # fallback for cases outside of x::Int\n\n# end::Int => var\"#JSON3_ESCAPE_THIS#end\"::Int (the escape token gets removed later)\nconst JSON3_ESCAPE_TOKEN = \"#JSON3_ESCAPE_THIS#\"\n@static if Base.VERSION < v\"1.3\"\n    function escape_variable_names!(expr::Expr)\n        if expr.head == :(::)\n            if !is_valid_fieldname(expr.args[1])\n                @warn \"\"\"Invalid identifier found: $(expr.args[1]).\n\n                In the types written to file, rename the field in the struct to a valid identifier and add a line `StructTypes.names(::Type{MyType}) = ((:julia_field_name, :json_field_name))` with the affected type, new Julia field name, and original JSON field name.\"\"\"\n            end\n        else\n            for arg in expr.args\n                escape_variable_names!(arg)\n            end\n        end\n    end\nelse\n    function escape_variable_names!(expr::Expr)\n        if expr.head == :(::)\n            if !is_valid_fieldname(expr.args[1])\n                # if the variable name is invalid, it will be escaped by `repr` later. This\n                # token is used to force reserved keywords to be marked as invalid and will\n                # be removed in `write_expr`..\n                expr.args[1] = Symbol(\"$JSON3_ESCAPE_TOKEN$(expr.args[1])\")\n            end\n        else\n            for arg in expr.args\n                escape_variable_names!(arg)\n            end\n        end\n    end\nend\nescape_variable_names!(x) = nothing # no-op fallback\n\n\"\"\"\n    JSON3.write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    remove_line_numbers!(expr)\n    collapse_unions!(expr)\n    collapse_singleton_blocks!(expr)\n    escape_variable_names!(expr)\n\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    str = replace(str, JSON3_ESCAPE_TOKEN => \"\") # remove the escape token\n\n    # better spacing\n    str = replace(str, \"end\\n\" => \"end\\n\\n\")\n    str = replace(str, r\"(module \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = replace(str, r\"(import \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = str[1:end-3] * \"\\nend # module\\n\"\n\n    Base.write(io, str)\n\n    return nothing\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    JSON3.generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\n                \"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\",\n            ),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\nread_json_str(json_str) = read(\n    length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) : json_str,\n)\n\n\"\"\"\n    JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string, an array of json strings, or a file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate an AST with the module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str(json_str)\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\nfunction generatetypes(\n    json_str::Vector{<:AbstractString},\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str.(json_str)\n\n    # build a type for the JSON\n    raw_json_type = reduce(unify, type_or_eltype.(generate_type.(json)); init = Any)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    JSON3.@generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable = mutable, root_name = root_name)\n    write_exprs(mod, file_name)\nend\n"}, "source_files_changed": ["src/gentypes.jl"], "test_files_changed": ["test/gentypes.jl"], "lines_changed": 94, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "da3ca8542440b5e5273a4432eaa06392312ca6ae", "parent_sha": "b409366409910ea3f6ac3f5c59212896fafc4d13", "commit_message": "Fix dispatch of `Real` when parsing in structs (#190)", "commit_date": "2021-11-16T00:32:11-07:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "StructTypes.omitempties", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n# https://github.com/quinnj/JSON3.jl/issues/187\n# without this, `Real` dispatches to the above definition\nread(::NumberType, buf, pos, len, b, ::Type{Real}; kw...) =\n    read(NumberType(), buf, pos, len, b, Union{Float64, Int64}; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 20, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "cfa128d01e42aacbeaa615fea45a83ace277f401", "parent_sha": "5c0d088f5d1174de318fc49021f83149f2bdd4a9", "commit_message": "Improve Union deserialization performance (#184)", "commit_date": "2021-10-01T07:15:09+01:00", "action": {"type": "REMOVE_METHOD", "target_file": "src/structs.jl", "target_symbol": "read", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; jsonlines::Bool=false, kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    if jsonlines\n        if StructType(T) != ArrayType()\n            throw(ArgumentError(\"expect StructType($T) == StructTypes.ArrayType() when jsonlines=true\"))\n        end\n        pos, x = readjsonlines(buf, pos, len, b, T; kw...)\n    else\n        pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    end\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n\n@generated function read(::Struct, buf, pos, len, b, T::Union; kw...)\n    U = first(T.parameters) # Extract Union from Type\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        :(if buf[pos] == UInt8('n')\n            return read(StructType($(U.a)), buf, pos, len, b, $(U.a))\n        else\n            return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n        end)\n    else\n        return :(\n            try\n                return read(StructType($(U.a)), buf, pos, len, b, $(U.a); kw...)\n            catch e\n                return read(StructType($(U.b)), buf, pos, len, b, $(U.b); kw...)\n            end\n        )\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline readjsonlines(buf, pos, len, b, ::Type{T}; kw...) where {T} = readjsonlines(buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline readjsonlines(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readjsonlinesarray(buf, pos, len, b, T, eT; kw...)\n\nfunction readjsonlinesarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    vals = Vector{eT}(undef, 0)\n    while true\n        # positioned at start of value\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        if pos > len\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        @wh_done  # remove spaces and tabs, jump to done on eof\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedNewline\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @goto done\n        end\n        if b == UInt8('\\r')  # Previous byte was \\r, look for \\n\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n@label done\n    return pos, construct(T, vals; kw...)\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 24, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "1f072a484136bc079b4cef5efd337252334c8db5", "parent_sha": "28a3a8b0f15ffa2821d0f208a3ceec2bd6638bbb", "commit_message": "Clarify docstring (#180)", "commit_date": "2021-09-16T16:27:31+02:00", "action": {"type": "UNKNOWN", "target_file": "src/read.jl", "target_symbol": null, "signature": null, "confidence": 0.1}, "files_before": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::Union{IO, Base.AbstractCmd}; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\n\"\"\"\n    JSON3.read(json_str, [type]; kw... )\n\nRead JSON.\n\n## Args\n\n* `json_str`: A string, IO, or bytes (`AbstractVector{UInt8`) containing JSON to read\n* `type`: Optionally, a type to read the JSON into. If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `jsonlines`: A Bool indicating that the `json_str` contains newline delimited JSON strings, which will be read into a `JSON3.Array` of the JSON values.  See [jsonlines](https://jsonlines.org/) for reference. [default `false`]\n* `allow_inf`: Allow reading of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing the format of dates in the JSON so that they can be read into `Date`s, `Time`s, or `DateTime`s when reading into a type. [default `Dates.default_format(T)`]\n* `parsequoted`: When reading into a NumberType, parse quoted values into numbers instead of as stings. [default `false`]\n\"\"\"\nfunction read(str::AbstractString; jsonlines::Bool=false, kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1); kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        obj = Object(buf, tape, Dict{Symbol, Int}())\n        populateinds!(obj)\n        return obj\n    elseif isarray(t)\n        arr = Array{geteltype(tape[2])}(buf, tape, Int[])\n        populateinds!(arr)\n        return arr\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nconst FLOAT_INT_BOUND = 2.0^53\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            !isfinite(float) && !allow_inf && @goto invalid\n            @check\n            # if, for example, we've already parsed floats in an array, just keep them all as floats and don't check for ints\n            if checkint\n                fp, ip = modf(float)\n                if fp == 0 && Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                    # ok great, we know the number is integral and pretty much in Int64 range\n                    if -FLOAT_INT_BOUND < float < FLOAT_INT_BOUND\n                        # easy case, integer w/ less than or equal to 53-bits of precision\n                        int = unsafe_trunc(Int64, float)\n                    else\n                        # if our integral float is > 53-bit precision, we need to reparse the Int so we don't get a lossy conversion\n                        # there are also a few floats that satisfy Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                        # that actually overflow Int64, like -9223372036854775809 and 9223372036854775808\n                        # in those cases, we're going to verify that this Int64 parsing doesn't overflow\n                        int, code, floatpos2 = Parsers.typeparser(Int64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n                        if floatpos2 < floatpos\n                            # ah, but there's one more case we need to handle: a > 53-bit precision integer given in\n                            # exponent form, like 1e17 or 9.007199254740994e15; in those cases, the truncation to Int64 *isn't* lossy\n                            int = unsafe_trunc(Int64, float)\n                        end\n                    end\n                    if code > 0\n                        @inbounds tape[tapeidx] = INT\n                        @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                        return floatpos, tapeidx + 2\n                    end\n                end\n            end\n            @inbounds tape[tapeidx] = FLOAT\n            @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "files_after": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::Union{IO, Base.AbstractCmd}; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\n\"\"\"\n    JSON3.read(json_str, [type]; kw... )\n\nRead JSON.\n\n## Args\n\n* `json_str`: A string, IO, or bytes (`AbstractVector{UInt8`) containing JSON to read\n* `type`: Optionally, a type to read the JSON into. If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `jsonlines`: A Bool indicating that the `json_str` contains newline delimited JSON strings, which will be read into a `JSON3.Array` of the JSON values.  See [jsonlines](https://jsonlines.org/) for reference. [default `false`]\n* `allow_inf`: Allow reading of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing the format of dates in the JSON so that they can be read into `Date`s, `Time`s, or `DateTime`s when reading into a type. [default `Dates.default_format(T)`]\n* `parsequoted`: Accept quoted values when reading into a NumberType. [default `false`]\n\"\"\"\nfunction read(str::AbstractString; jsonlines::Bool=false, kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1); kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        obj = Object(buf, tape, Dict{Symbol, Int}())\n        populateinds!(obj)\n        return obj\n    elseif isarray(t)\n        arr = Array{geteltype(tape[2])}(buf, tape, Int[])\n        populateinds!(arr)\n        return arr\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nconst FLOAT_INT_BOUND = 2.0^53\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            !isfinite(float) && !allow_inf && @goto invalid\n            @check\n            # if, for example, we've already parsed floats in an array, just keep them all as floats and don't check for ints\n            if checkint\n                fp, ip = modf(float)\n                if fp == 0 && Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                    # ok great, we know the number is integral and pretty much in Int64 range\n                    if -FLOAT_INT_BOUND < float < FLOAT_INT_BOUND\n                        # easy case, integer w/ less than or equal to 53-bits of precision\n                        int = unsafe_trunc(Int64, float)\n                    else\n                        # if our integral float is > 53-bit precision, we need to reparse the Int so we don't get a lossy conversion\n                        # there are also a few floats that satisfy Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                        # that actually overflow Int64, like -9223372036854775809 and 9223372036854775808\n                        # in those cases, we're going to verify that this Int64 parsing doesn't overflow\n                        int, code, floatpos2 = Parsers.typeparser(Int64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n                        if floatpos2 < floatpos\n                            # ah, but there's one more case we need to handle: a > 53-bit precision integer given in\n                            # exponent form, like 1e17 or 9.007199254740994e15; in those cases, the truncation to Int64 *isn't* lossy\n                            int = unsafe_trunc(Int64, float)\n                        end\n                    end\n                    if code > 0\n                        @inbounds tape[tapeidx] = INT\n                        @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                        return floatpos, tapeidx + 2\n                    end\n                end\n            end\n            @inbounds tape[tapeidx] = FLOAT\n            @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "source_files_changed": ["src/read.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": false, "validation_errors": ["Low action confidence: 0.1", "Could not infer action type"]}
{"repo": "JSON3.jl", "commit_sha": "28a3a8b0f15ffa2821d0f208a3ceec2bd6638bbb", "parent_sha": "807bc9be86848b761a5f43d58c5b098d33ffc85b", "commit_message": "Treat Union{Bool, Real} as StructTypes.Struct (#174)", "commit_date": "2021-08-02T23:13:12-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "read", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n# https://github.com/quinnj/JSON3.jl/issues/172\n# treat Union{Bool, Real} as non-StructTypes.NumberType so parsing works as expected\nread(::NumberType, buf, pos, len, b, S::Type{Union{Bool, T}}; kw...) where {T <: Real} =\n    read(Struct(), buf, pos, len, b, S; kw...)\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 9, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "a6619e5c333ad8172632077f69963463164af080", "parent_sha": "5cd54400396b63cdcc2a8349d1fa9d89a08cb164", "commit_message": "Array of Samples (#164)", "commit_date": "2021-07-06T20:44:19-04:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/gentypes.jl", "target_symbol": "type_or_eltype", "signature": null, "confidence": 0.5}, "files_before": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nfunction promoteunion(T, S)\n    new = promote_type(T, S)\n    return isabstracttype(new) ? Union{T,S} : new\nend\n\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(b::Type{S}, a::Type{T}) where {T,S<:T} = T\nunify(a::Type{T}, b::Type{T}) where {T} = T\nunify(a::Type{Any}, b::Type{T}) where {T} = T\nunify(b::Type{T}, a::Type{Any}) where {T} = T\nunify(a::Type{Any}, b::Type{Any}) = Any\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\nunify(a::Type{NamedTuple{A,T}}, b::Type{NamedTuple{A,T}}) where {A,T<:Tuple} =\n    NamedTuple{A,T}\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\nunify(a::Type{Vector{T}}, b::Type{Vector{T}}) where {T} = Vector{T}\n\n# parse json into a type, maintain field order\n\"\"\"\n    JSON3.generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    if isempty(a)\n        return Vector{Any}\n    end\n\n    t = Set([])\n    nt = Any\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n# remove line number nodes\nfunction remove_line_numbers!(expr::Expr)\n    filter!(x -> !isa(x, LineNumberNode), expr.args)\n    for arg in expr.args\n        remove_line_numbers!(arg)\n    end\nend\nremove_line_numbers!(x) = nothing # no-op fallback\n\n# collapse singleton blocks into just the contained Expr\nfunction collapse_singleton_blocks!(expr::Expr)\n    if expr.head == :block && length(expr.args) == 1\n        expr.head = expr.args[1].head\n        expr.args = expr.args[1].args\n    end\n\n    for arg in expr.args\n        collapse_singleton_blocks!(arg)\n    end\nend\ncollapse_singleton_blocks!(x) = nothing # no-op fallback\n\n# Union{A, Union{B, C}} => Union{A, B, C}\nfunction collapse_unions!(expr::Expr)\n    if expr.head == :curly && length(expr.args) > 0 && expr.args[1] == :Union\n        if isa(expr.args[end], Expr) # nested union\n            u = pop!(expr.args)\n            append!(expr.args, u.args[2:3])\n            collapse_unions!(expr) # catch more nested unions\n        end\n    end\n\n    for arg in expr.args\n        collapse_unions!(arg)\n    end\nend\ncollapse_unions!(x) = nothing # no-op fallback\n\n\"\"\"\n    JSON3.write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    remove_line_numbers!(expr)\n    collapse_unions!(expr)\n    collapse_singleton_blocks!(expr)\n\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n\n    # better spacing\n    str = replace(str, \"end\\n\" => \"end\\n\\n\")\n    str = replace(str, r\"(module \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = replace(str, r\"(import \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = str[1:end-3] * \"\\nend # module\\n\"\n\n    Base.write(io, str)\n\n    return nothing\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    JSON3.generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\n                \"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\",\n            ),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\n\"\"\"\n    JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string or file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate a module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read(\n        length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) : json_str,\n    )\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    JSON3.@generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable = mutable, root_name = root_name)\n    write_exprs(mod, file_name)\nend\n"}, "files_after": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nfunction promoteunion(T, S)\n    new = promote_type(T, S)\n    return isabstracttype(new) ? Union{T,S} : new\nend\n\n# get the type of the contents\ntype_or_eltype(::Type{Vector{T}}) where {T} = T\ntype_or_eltype(::Type{T}) where {T} = T\n\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(b::Type{S}, a::Type{T}) where {T,S<:T} = T\nunify(a::Type{T}, b::Type{T}) where {T} = T\nunify(a::Type{Any}, b::Type{T}) where {T} = T\nunify(b::Type{T}, a::Type{Any}) where {T} = T\nunify(a::Type{Any}, b::Type{Any}) = Any\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\nunify(a::Type{NamedTuple{A,T}}, b::Type{NamedTuple{A,T}}) where {A,T<:Tuple} =\n    NamedTuple{A,T}\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\nunify(a::Type{Vector{T}}, b::Type{Vector{T}}) where {T} = Vector{T}\n\n# parse json into a type, maintain field order\n\"\"\"\n    JSON3.generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    if isempty(a)\n        return Vector{Any}\n    end\n\n    t = Set([])\n    nt = Any\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n# remove line number nodes\nfunction remove_line_numbers!(expr::Expr)\n    filter!(x -> !isa(x, LineNumberNode), expr.args)\n    for arg in expr.args\n        remove_line_numbers!(arg)\n    end\nend\nremove_line_numbers!(x) = nothing # no-op fallback\n\n# collapse singleton blocks into just the contained Expr\nfunction collapse_singleton_blocks!(expr::Expr)\n    if expr.head == :block && length(expr.args) == 1\n        expr.head = expr.args[1].head\n        expr.args = expr.args[1].args\n    end\n\n    for arg in expr.args\n        collapse_singleton_blocks!(arg)\n    end\nend\ncollapse_singleton_blocks!(x) = nothing # no-op fallback\n\n# Union{A, Union{B, C}} => Union{A, B, C}\nfunction collapse_unions!(expr::Expr)\n    if expr.head == :curly && length(expr.args) > 0 && expr.args[1] == :Union\n        if isa(expr.args[end], Expr) # nested union\n            u = pop!(expr.args)\n            append!(expr.args, u.args[2:3])\n            collapse_unions!(expr) # catch more nested unions\n        end\n    end\n\n    for arg in expr.args\n        collapse_unions!(arg)\n    end\nend\ncollapse_unions!(x) = nothing # no-op fallback\n\n\"\"\"\n    JSON3.write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    remove_line_numbers!(expr)\n    collapse_unions!(expr)\n    collapse_singleton_blocks!(expr)\n\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n\n    # better spacing\n    str = replace(str, \"end\\n\" => \"end\\n\\n\")\n    str = replace(str, r\"(module \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = replace(str, r\"(import \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = str[1:end-3] * \"\\nend # module\\n\"\n\n    Base.write(io, str)\n\n    return nothing\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    JSON3.generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\n                \"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\",\n            ),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\nread_json_str(json_str) = read(\n    length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) : json_str,\n)\n\n\"\"\"\n    JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string, an array of json strings, or a file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate an AST with the module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str(json_str)\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\nfunction generatetypes(\n    json_str::Vector{<:AbstractString},\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read_json_str.(json_str)\n\n    # build a type for the JSON\n    raw_json_type = reduce(unify, type_or_eltype.(generate_type.(json)); init = Any)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    JSON3.@generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable = mutable, root_name = root_name)\n    write_exprs(mod, file_name)\nend\n"}, "source_files_changed": ["src/gentypes.jl"], "test_files_changed": ["test/gentypes.jl", "test/runtests.jl", "test/stringnumber.jl"], "lines_changed": 74, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "5cd54400396b63cdcc2a8349d1fa9d89a08cb164", "parent_sha": "6e73d974bda1e936e263781e779c05a131174a04", "commit_message": "Nicer formatting of generated types (#165)", "commit_date": "2021-07-06T19:05:40-04:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/gentypes.jl", "target_symbol": "pascalcase", "signature": null, "confidence": 0.6}, "files_before": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nfunction promoteunion(T, S)\n    new = promote_type(T, S)\n    return isabstracttype(new) ? Union{T,S} : new\nend\n\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(b::Type{S}, a::Type{T}) where {T,S<:T} = T\nunify(a::Type{T}, b::Type{T}) where {T} = T\nunify(a::Type{Any}, b::Type{T}) where {T} = T\nunify(b::Type{T}, a::Type{Any}) where {T} = T\nunify(a::Type{Any}, b::Type{Any}) = Any\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\nunify(a::Type{NamedTuple{A,T}}, b::Type{NamedTuple{A,T}}) where {A,T<:Tuple} =\n    NamedTuple{A,T}\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\nunify(a::Type{Vector{T}}, b::Type{Vector{T}}) where {T} = Vector{T}\n\n# parse json into a type, maintain field order\n\"\"\"\n    JSON3.generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    if isempty(a)\n        return Vector{Any}\n    end\n\n    t = Set([])\n    nt = Any\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n\"\"\"\n    JSON3.write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    Base.write(io, str)\n    Base.write(io, \"\\n\\n\")\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    JSON3.generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\n                \"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\",\n            ),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\n\"\"\"\n    JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string or file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate a module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read(\n        length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) : json_str,\n    )\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    JSON3.@generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable = mutable, root_name = root_name)\n    write_exprs(mod, file_name)\nend\n"}, "files_after": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nfunction promoteunion(T, S)\n    new = promote_type(T, S)\n    return isabstracttype(new) ? Union{T,S} : new\nend\n\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(b::Type{S}, a::Type{T}) where {T,S<:T} = T\nunify(a::Type{T}, b::Type{T}) where {T} = T\nunify(a::Type{Any}, b::Type{T}) where {T} = T\nunify(b::Type{T}, a::Type{Any}) where {T} = T\nunify(a::Type{Any}, b::Type{Any}) = Any\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\nunify(a::Type{NamedTuple{A,T}}, b::Type{NamedTuple{A,T}}) where {A,T<:Tuple} =\n    NamedTuple{A,T}\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\nunify(a::Type{Vector{T}}, b::Type{Vector{T}}) where {T} = Vector{T}\n\n# parse json into a type, maintain field order\n\"\"\"\n    JSON3.generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    if isempty(a)\n        return Vector{Any}\n    end\n\n    t = Set([])\n    nt = Any\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n# remove line number nodes\nfunction remove_line_numbers!(expr::Expr)\n    filter!(x -> !isa(x, LineNumberNode), expr.args)\n    for arg in expr.args\n        remove_line_numbers!(arg)\n    end\nend\nremove_line_numbers!(x) = nothing # no-op fallback\n\n# collapse singleton blocks into just the contained Expr\nfunction collapse_singleton_blocks!(expr::Expr)\n    if expr.head == :block && length(expr.args) == 1\n        expr.head = expr.args[1].head\n        expr.args = expr.args[1].args\n    end\n\n    for arg in expr.args\n        collapse_singleton_blocks!(arg)\n    end\nend\ncollapse_singleton_blocks!(x) = nothing # no-op fallback\n\n# Union{A, Union{B, C}} => Union{A, B, C}\nfunction collapse_unions!(expr::Expr)\n    if expr.head == :curly && length(expr.args) > 0 && expr.args[1] == :Union\n        if isa(expr.args[end], Expr) # nested union\n            u = pop!(expr.args)\n            append!(expr.args, u.args[2:3])\n            collapse_unions!(expr) # catch more nested unions\n        end\n    end\n\n    for arg in expr.args\n        collapse_unions!(arg)\n    end\nend\ncollapse_unions!(x) = nothing # no-op fallback\n\n\"\"\"\n    JSON3.write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    remove_line_numbers!(expr)\n    collapse_unions!(expr)\n    collapse_singleton_blocks!(expr)\n\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n\n    # better spacing\n    str = replace(str, \"end\\n\" => \"end\\n\\n\")\n    str = replace(str, r\"(module \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = replace(str, r\"(import \\w+)\" => @s_str(\"\\\\1\\n\"))\n    str = str[1:end-3] * \"\\nend # module\\n\"\n\n    Base.write(io, str)\n\n    return nothing\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    JSON3.generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\n                \"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\",\n            ),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\n\"\"\"\n    JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string or file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate a module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read(\n        length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) : json_str,\n    )\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    JSON3.@generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable = mutable, root_name = root_name)\n    write_exprs(mod, file_name)\nend\n"}, "source_files_changed": ["src/gentypes.jl"], "test_files_changed": ["test/gentypes.jl"], "lines_changed": 53, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "6e73d974bda1e936e263781e779c05a131174a04", "parent_sha": "3d9d0866571f60866948905f55194ebfaa499855", "commit_message": "Fix: Empty vector returns `Vector{Any}` (#167)", "commit_date": "2021-07-06T19:04:59-04:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/gentypes.jl", "target_symbol": "unify", "signature": null, "confidence": 0.75}, "files_before": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# top type - unifying a type with top yeilds the type\nstruct Top end\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nfunction promoteunion(T, S)\n    new = promote_type(T, S)\n    return isabstracttype(new) ? Union{T, S} : new\nend\n\nunify(a, b) = unify(b, a)\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(a::Type{Top}, b::Type{T}) where {T} = T\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\n\n# parse json into a type, maintain field order\n\"\"\"\n    JSON3.generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    t = Set([])\n    nt = Top\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n\"\"\"\n    JSON3.write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    Base.write(io, str)\n    Base.write(io, \"\\n\\n\")\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    JSON3.generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\"),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\n\"\"\"\n    JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string or file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate a module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read(\n        length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) :\n            json_str,\n    )\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name=root_name, mutable=mutable)\n    return generate_struct_type_module(\n        json_exprs,\n        module_name\n    )\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    JSON3.@generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable=mutable, root_name=root_name)\n    write_exprs(mod, file_name)\nend\n"}, "files_after": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nfunction promoteunion(T, S)\n    new = promote_type(T, S)\n    return isabstracttype(new) ? Union{T,S} : new\nend\n\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(b::Type{S}, a::Type{T}) where {T,S<:T} = T\nunify(a::Type{T}, b::Type{T}) where {T} = T\nunify(a::Type{Any}, b::Type{T}) where {T} = T\nunify(b::Type{T}, a::Type{Any}) where {T} = T\nunify(a::Type{Any}, b::Type{Any}) = Any\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\nunify(a::Type{NamedTuple{A,T}}, b::Type{NamedTuple{A,T}}) where {A,T<:Tuple} =\n    NamedTuple{A,T}\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\nunify(a::Type{Vector{T}}, b::Type{Vector{T}}) where {T} = Vector{T}\n\n# parse json into a type, maintain field order\n\"\"\"\n    JSON3.generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    if isempty(a)\n        return Vector{Any}\n    end\n\n    t = Set([])\n    nt = Any\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n\"\"\"\n    JSON3.write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    Base.write(io, str)\n    Base.write(io, \"\\n\\n\")\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    JSON3.generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\n                \"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\",\n            ),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\n\"\"\"\n    JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string or file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate a module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read(\n        length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) : json_str,\n    )\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name = root_name, mutable = mutable)\n    return generate_struct_type_module(json_exprs, module_name)\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    JSON3.@generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable = mutable, root_name = root_name)\n    write_exprs(mod, file_name)\nend\n"}, "source_files_changed": ["src/gentypes.jl"], "test_files_changed": ["test/gentypes.jl"], "lines_changed": 77, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "1c692023cdcb9e24038276639fea2ad5a5eb879b", "parent_sha": "35c2661de30aa7af8e5c2b64515039dabcbc2a09", "commit_message": "Fix deprecated .data access on ; kw... (#156)", "commit_date": "2021-05-25T07:58:47+02:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, kw.data)\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, values(kw))\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, values(kw))\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(values(kw), f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, Base.values(kw))\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, values(kw))\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\n\"\"\"\n    JSON3.write([io], x; kw...)\n\nWrite JSON.\n\n## Args\n\n* `io`: Optionally, an `IO` object to write the resulting JSON string to.  By default, will return a `String` if `io` is not provided.\n* `x`: An object to serialize as JSON.  If not a [built in type](#Builtin-types), must have a \"struct mapping\" registered with [StructTypes.jl](#Struct-API).\n\n## Keyword Args\n\n* `allow_inf`: Allow writing of `Inf` and `NaN` values (not part of the JSON standard). [default `false`]\n* `dateformat`: A [`DateFormat`](https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat) describing how to format `Date`s in the object. [default `Dates.default_format(T)`]\n\"\"\"\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(values(kw), f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, values(kw))\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "source_files_changed": ["src/structs.jl", "src/write.jl"], "test_files_changed": [], "lines_changed": 18, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "3ac8ac64f5aa0109b87da16b78453ce0324f8afc", "parent_sha": "3f5d03332dcc619039ad4e85862754da18525770", "commit_message": "Fix issue reported on discourse where allow_inf not being passed thro\u2026 (#159)", "commit_date": "2021-05-24T23:57:00-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "StructTypes.construct", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, kw.data)\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; allow_inf=allow_inf, kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, kw.data)\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": ["test/gentypes.jl", "test/runtests.jl", "test/stringnumber.jl"], "lines_changed": 27, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "3f5d03332dcc619039ad4e85862754da18525770", "parent_sha": "90ca5a27944ba14cd95d1ed7dfe7d8c6e0513596", "commit_message": "goto done instead of returning (#157)", "commit_date": "2021-05-25T00:44:17-03:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, kw.data)\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\nend\n\n\"\"\"\n    JSON3.read!(json_str, x; kw...)\n\nIncrementally update an instance of a mutable object `x` with the contents of `json_str`.  See [`JSON3.read`](@ref) for more details.\n\"\"\"\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, kw.data)\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 7, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "c73edd78e955b41c416d9b6e3134982fbbb4a895", "parent_sha": "fed2ed7f495edbcc243897e428b825619f9cc1a8", "commit_message": "Prefer small unions when generating types from json objects/arrays (#144)", "commit_date": "2021-04-13T08:34:54-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/gentypes.jl", "target_symbol": "unify", "signature": null, "confidence": 0.75}, "files_before": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# top type - unifying a type with top yeilds the type\nstruct Top end\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nunify(a, b) = unify(b, a)\nunify(a::Type{T}, b::Type{S}) where {T,S} = Base.promote_typejoin(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(a::Type{Top}, b::Type{T}) where {T} = T\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\n\n# parse json into a type, maintain field order\n\"\"\"\n    generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    t = Set([])\n    nt = Top\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n\"\"\"\n    write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    Base.write(io, str)\n    Base.write(io, \"\\n\\n\")\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\"),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\n\"\"\"\n    generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string or file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate a module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read(\n        length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) :\n            json_str,\n    )\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name=root_name, mutable=mutable)\n    return generate_struct_type_module(\n        json_exprs,\n        module_name\n    )\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    @generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable=mutable, root_name=root_name)\n    write_exprs(mod, file_name)\nend\n"}, "files_after": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# top type - unifying a type with top yeilds the type\nstruct Top end\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nfunction promoteunion(T, S)\n    new = promote_type(T, S)\n    return isabstracttype(new) ? Union{T, S} : new\nend\n\nunify(a, b) = unify(b, a)\nunify(a::Type{T}, b::Type{S}) where {T,S} = promoteunion(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(a::Type{Top}, b::Type{T}) where {T} = T\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\n\n# parse json into a type, maintain field order\n\"\"\"\n    generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    t = Set([])\n    nt = Top\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n\"\"\"\n    write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    Base.write(io, str)\n    Base.write(io, \"\\n\\n\")\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\"),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\n\"\"\"\n    generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string or file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate a module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read(\n        length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) :\n            json_str,\n    )\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name=root_name, mutable=mutable)\n    return generate_struct_type_module(\n        json_exprs,\n        module_name\n    )\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    @generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable=mutable, root_name=root_name)\n    write_exprs(mod, file_name)\nend\n"}, "source_files_changed": ["src/gentypes.jl"], "test_files_changed": ["test/gentypes.jl"], "lines_changed": 8, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "fed2ed7f495edbcc243897e428b825619f9cc1a8", "parent_sha": "7042caaa89c91e22f30ccf001a181c4eb4410140", "commit_message": "Generate code for immutable structs (#140)", "commit_date": "2021-04-13T07:18:44+02:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/gentypes.jl", "target_symbol": "generatetypes", "signature": null, "confidence": 0.6}, "files_before": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# top type - unifying a type with top yeilds the type\nstruct Top end\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nunify(a, b) = unify(b, a)\nunify(a::Type{T}, b::Type{S}) where {T,S} = Base.promote_typejoin(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(a::Type{Top}, b::Type{T}) where {T} = T\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\n\n# parse json into a type, maintain field order\n\"\"\"\n    generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    t = Set([])\n    nt = Top\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n\"\"\"\n    write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    Base.write(io, str)\n    Base.write(io, \"\\n\\n\")\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\"),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\n\"\"\"\n    generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string or file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate a module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read(\n        length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) :\n            json_str,\n    )\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name=root_name)\n    return generate_struct_type_module(\n        json_exprs,\n        module_name\n    )\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    @generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable=mutable, root_name=root_name)\n    write_exprs(mod, file_name)\nend\n"}, "files_after": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# top type - unifying a type with top yeilds the type\nstruct Top end\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nunify(a, b) = unify(b, a)\nunify(a::Type{T}, b::Type{S}) where {T,S} = Base.promote_typejoin(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(a::Type{Top}, b::Type{T}) where {T} = T\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\n\n# parse json into a type, maintain field order\n\"\"\"\n    generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    t = Set([])\n    nt = Top\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_names => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if length(new_str) > 1 && new_str[end] == 's' && new_str[end-1:end] != \"ss\"\n        new_str = new_str[1:end-1]\n    end\n\n    return Symbol(new_str)\nend\n\n\"\"\"\n    write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    Base.write(io, str)\n    Base.write(io, \"\\n\\n\")\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\"),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\n\"\"\"\n    generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string or file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate a module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read(\n        length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) :\n            json_str,\n    )\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name=root_name, mutable=mutable)\n    return generate_struct_type_module(\n        json_exprs,\n        module_name\n    )\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    @generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    :(Core.eval($__module__, generatetypes($(esc(json_str)), $(esc(module_name)))))\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name::Symbol = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name; mutable=mutable, root_name=root_name)\n    write_exprs(mod, file_name)\nend\n"}, "source_files_changed": ["src/gentypes.jl"], "test_files_changed": ["test/gentypes.jl"], "lines_changed": 3, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "38a20e03c2b0e19f47a163b2a395b6a917ed1c16", "parent_sha": "da03213afe842f35e2b0879fc4d117d9a3dbf3c3", "commit_message": "Support new StructTypes.CustomStruct struct type", "commit_date": "2021-03-20T21:53:13-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "StructTypes.StructType", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\nend\n\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, kw.data)\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, CustomStruct, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, OrderedStruct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\nend\n\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple}; kw...) = read(DictType(), buf, pos, len, b, NamedTuple, Symbol, Any; kw...)\n@inline read(::Struct, buf, pos, len, b, ::Type{NamedTuple{names}}; kw...) where {names} = read(DictType(), buf, pos, len, b, NamedTuple{names}, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::CustomStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    S = StructTypes.lowertype(T)\n    pos, x = read(StructType(S), buf, pos, len, b, S; kw...)\n    return pos, StructTypes.construct(T, x)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    values::Vector{Any}\n    kw::KW\nend\n\nconst DEFAULT_STRUCT_FIELD_COUNT = 32\n\n@inline function (f::StructClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    if i <= DEFAULT_STRUCT_FIELD_COUNT\n        f.values[i] = y_i\n    else\n        push!(f.values, y_i)\n    end\n    return\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    values = Vector{Any}(undef, DEFAULT_STRUCT_FIELD_COUNT)\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = StructClosure(buf, pos, len, b, values, kw.data)\n        if StructTypes.applyfield(c, T, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, StructTypes.construct(values, T)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct OrderedStructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::OrderedStructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::OrderedStruct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = OrderedStructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    types = subtypes(T)\n    if length(types) == 1\n        only_subtype = types[1]\n        return read(StructType(only_subtype), buf, pos, len, b, only_subtype; kw...)\n    end\n    return _read(AbstractType(), buf, pos, len, b, T; kw...)\nend\n\n@inline function _read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\n@inline function write(::CustomStruct, buf, pos, len, x; kw...)\n    y = StructTypes.lower(x)\n    return write(StructType(y), buf, pos, len, y; kw...)\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "source_files_changed": ["src/structs.jl", "src/write.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 25, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "966ba96b6dca78851be22ec4f3cb7d43568d389c", "parent_sha": "b2de5974fa3208fca63277a9f4338144c3e908ea", "commit_message": "refactor: api consistency", "commit_date": "2021-03-06T10:02:24-05:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/gentypes.jl", "target_symbol": "generate_exprs", "signature": null, "confidence": 0.75}, "files_before": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# top type - unifying a type with top yeilds the type\nstruct Top end\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nunify(a, b) = unify(b, a)\nunify(a::Type{T}, b::Type{S}) where {T,S} = Base.promote_typejoin(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(a::Type{Top}, b::Type{T}) where {T} = T\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\n\n# parse json into a type, maintain field order\n\"\"\"\n    generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    t = Set([])\n    nt = Top\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_name => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if new_str[end] == 's'\n        if new_str[end-2:end] == \"ies\"\n            new_str = new_str[1:end-3] * \"y\"\n        else\n            new_str = new_str[1:end-1]\n        end\n    end\n\n    return Symbol(new_str)\nend\n\n\"\"\"\n    write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    Base.write(io, str)\n    Base.write(io, \"\\n\\n\")\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    generate_exprs(raw_type, name=:Root; mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t, name::Symbol = :Root; mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\"),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\n\"\"\"\n    generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string or file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate a module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read(\n        length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) :\n            json_str,\n    )\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type, root_name)\n    return generate_struct_type_module(\n        json_exprs,\n        module_name\n    )\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    @generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    return quote\n        local mod = JSON3.generatetypes($(esc(json_str)), $(esc(module_name)))\n        return Core.eval($__module__, mod)\n    end\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name)\n    write_exprs(mod, file_name)\nend\n"}, "files_after": {"src/gentypes.jl": "@static if Base.VERSION < v\"1.2\"\n    function hasfield(::Type{T}, name::Symbol) where {T}\n        return name in fieldnames(T)\n    end\n    fieldtypes(::Type{T}) where {T} = Tuple(fieldtype(T, i) for i = 1:fieldcount(T))\nend\n\n# top type - unifying a type with top yeilds the type\nstruct Top end\n\n# get the type from a named tuple, given a name\nget_type(NT, k) = hasfield(NT, k) ? fieldtype(NT, k) : Nothing\n\n# unify two types to a single type\nunify(a, b) = unify(b, a)\nunify(a::Type{T}, b::Type{S}) where {T,S} = Base.promote_typejoin(T, S)\nunify(a::Type{T}, b::Type{S}) where {T,S<:T} = T\nunify(a::Type{Top}, b::Type{T}) where {T} = T\n\nfunction unify(\n    a::Type{NamedTuple{A,T}},\n    b::Type{NamedTuple{B,S}},\n) where {A,T<:Tuple,B,S<:Tuple}\n    ks = []\n    ts = []\n    for (k, v) in zip(A, fieldtypes(a))\n        push!(ks, k)\n        push!(ts, unify(v, get_type(b, k)))\n    end\n\n    for (k, v) in zip(B, fieldtypes(b))\n        if !(k in ks)\n            push!(ks, k)\n            push!(ts, unify(v, Nothing))\n        end\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nunify(a::Type{Vector{T}}, b::Type{Vector{S}}) where {T,S} = Vector{unify(T, S)}\n\n# parse json into a type, maintain field order\n\"\"\"\n    generate_type(json)\n\nGiven a JSON3 Object or Array, return a \"raw type\" from it.  A raw type is typically a `NamedTuple`, which can contain further nested `NamedTuples`, concrete, `Array`, or `Union` types.\n\"\"\"\nfunction generate_type(o::JSON3.Object)\n    ks = []\n    ts = []\n    for (k, v) in o\n        push!(ks, k)\n        push!(ts, generate_type(v))\n    end\n\n    return NamedTuple{tuple(ks...),Tuple{ts...}}\nend\n\nfunction generate_type(a::JSON3.Array)\n    t = Set([])\n    nt = Top\n    for item in a\n        it = generate_type(item)\n        if it <: NamedTuple\n            nt = unify(nt, it)\n        else\n            push!(t, it)\n        end\n    end\n\n    return Vector{foldl(unify, t; init = Union{nt})}\nend\n\ngenerate_type(x::T) where {T} = T\n\n# get the AST of a type\nfunction to_ast(::Type{T}) where {T}\n    io = IOBuffer()\n    print(io, T)\n    str = String(take!(io))\n    ast = Meta.parse(str)\n    return ast\nend\n\n# make a field identifer into pascal case for struct name (my_name => MyName)\nfunction pascalcase(s::Symbol)\n    str = String(s)\n    new_str = \"\"\n    next_upper = true\n    for letter in str\n        if next_upper\n            new_str *= uppercase(letter)\n            next_upper = false\n        elseif letter == '_'\n            next_upper = true\n        else\n            new_str *= letter\n        end\n    end\n\n    if new_str[end] == 's'\n        if new_str[end-2:end] == \"ies\"\n            new_str = new_str[1:end-3] * \"y\"\n        else\n            new_str = new_str[1:end-1]\n        end\n    end\n\n    return Symbol(new_str)\nend\n\n\"\"\"\n    write_exprs(expr, f)\n\nWrite an `Expr` or `Vector{Expr}` to file.  Formatted so that it can be used with `include`.\n\"\"\"\nfunction write_exprs(expr::Expr, io::IOStream)\n    str = repr(expr)[3:end-1] # removes :( and )\n    str = replace(str, \"\\n  \" => \"\\n\") # un-tab each line\n    Base.write(io, str)\n    Base.write(io, \"\\n\\n\")\nend\n\nfunction write_exprs(exprs::Vector, fname::AbstractString)\n    open(fname, \"w\") do io\n        for expr in exprs\n            write_exprs(expr, io)\n        end\n    end\nend\n\nfunction write_exprs(expr::Expr, fname::AbstractString)\n    open(fname, \"w\") do io\n        write_exprs(expr, io)\n    end\nend\n\n# entry function for turning a \"raw\" type from `generate_type` to Exprs\n\"\"\"\n    generate_exprs(raw_type; root_name=:Root, mutable=true)\n\nGenerate a vector of `Expr` from a \"raw_type\".  This will un-nest any sub-types within the root type.\n\nThe name of the root type is from the `name` variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.\n\nIf `mutable` is `true`, an empty constructor is included in the struct definition. This allows the mutable structs to be used with `StructTypes.Mutable()` out of the box.\n\"\"\"\nfunction generate_exprs(t; root_name::Symbol = :Root, mutable = true)\n    exprs = []\n    generate_expr!(exprs, t, root_name; mutable = mutable)\n    return exprs\nend\n\n# turn a \"raw\" type into an AST for a struct\nfunction generate_expr!(\n    exprs,\n    nt::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    mutable::Bool = true,\n) where {N,T<:Tuple}\n    sub_exprs = []\n    for (n, t) in zip(N, fieldtypes(nt))\n        push!(sub_exprs, generate_field_expr!(exprs, t, n; mutable = mutable))\n    end\n\n    struct_name = pascalcase(root_name)\n    if mutable\n        push!(sub_exprs, Meta.parse(\"$struct_name() = new()\"))\n    end\n\n    push!(exprs, Expr(:struct, mutable, struct_name, Expr(:block, sub_exprs...)))\n    return struct_name\nend\n\n# should only hit this in the case of the array being the root of the type\nfunction generate_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T<:NamedTuple,N}\n    return generate_expr!(exprs, T, root_name; kwargs...)\nend\n\nfunction generate_expr!(exprs, t::Type{T}, root_name::Symbol; kwargs...) where {T}\n    if T isa Union\n        return Expr(\n            :curly,\n            :Union,\n            generate_expr!(exprs, t.a, root_name; kwargs...),\n            generate_expr!(exprs, t.b, root_name; kwargs...),\n        )\n    else\n        return to_ast(T)\n    end\nend\n\n# given the type of a field of a struct, return a node for that field's name/type\nfunction generate_field_expr!(\n    exprs,\n    t::Type{NamedTuple{N,T}},\n    root_name::Symbol;\n    kwargs...,\n) where {N,T}\n    generate_expr!(exprs, t, root_name; kwargs...)\n    return Expr(:(::), root_name, pascalcase(root_name))\nend\n\nfunction generate_field_expr!(\n    exprs,\n    ::Type{Base.Array{T,N}},\n    root_name::Symbol;\n    kwargs...,\n) where {T,N}\n    return Expr(\n        :(::),\n        root_name,\n        Expr(:curly, :Array, generate_expr!(exprs, T, root_name; kwargs...), 1),\n    )\nend\n\nfunction generate_field_expr!(exprs, ::Type{T}, root_name::Symbol; kwargs...) where {T}\n    return Expr(:(::), root_name, generate_expr!(exprs, T, root_name; kwargs...))\nend\n\n# create a module with the struct declarations as well as the StructType declarations\n\"\"\"\n    generate_struct_type_module(exprs, module_name)\n\nGiven a vector of `exprs` (output of [`generate_exprs`](@ref)), return an `Expr` containing the AST for a module with name `module_name`.  The module will map all types to the appropriate `StructType`, so the result can immediately used with `JSON3.read(json, T)`.\n\"\"\"\nfunction generate_struct_type_module(exprs, module_name)\n    mutable = exprs[1].args[1]\n    struct_type_import = Meta.parse(\"import StructTypes\")\n    struct_type = mutable ? \"Mutable\" : \"Struct\"\n    struct_type_decls = []\n    for expr in exprs\n        push!(\n            struct_type_decls,\n            Meta.parse(\"StructTypes.StructType(::Type{$(expr.args[2])}) = StructTypes.$struct_type()\"),\n        )\n    end\n    type_block = Expr(:block, struct_type_import, exprs..., struct_type_decls...)\n    return Expr(:module, true, module_name, type_block)\nend\n\n\"\"\"\n    generatetypes(json, module_name; mutable=true, root_name=:Root)\n\nConvenience function to go from a json string or file name to an AST with a module of structs.\n\nPerforms the following:\n1. If the JSON is a file, read to string\n2. Call `JSON3.read` on the JSON string\n3. Get the \"raw type\" from [`generate_type`](@ref)\n4. Parse the \"raw type\" into a vector of `Expr` ([`generate_exprs`](@ref))\n5. Generate a module containg the structs ([`generate_struct_type_module`](@ref))\n\"\"\"\nfunction generatetypes(\n    json_str::AbstractString,\n    module_name::Symbol;\n    mutable::Bool = true,\n    root_name::Symbol = :Root,\n)\n    # either a JSON.Array or JSON.Object\n    json = read(\n        length(json_str) < 255 && isfile(json_str) ? Base.read(json_str, String) :\n            json_str,\n    )\n\n    # build a type for the JSON\n    raw_json_type = generate_type(json)\n    json_exprs = generate_exprs(raw_json_type; root_name=root_name)\n    return generate_struct_type_module(\n        json_exprs,\n        module_name\n    )\nend\n\n# macro to create a module with types generated from a json string\n\"\"\"\n    @generatetypes json [module_name]\n\nEvaluate the result of the [`generatetypes`](@ref) function in the current scope.\n\"\"\"\nmacro generatetypes(json_str, module_name)\n    return quote\n        local mod = JSON3.generatetypes($(esc(json_str)), $(esc(module_name)))\n        return Core.eval($__module__, mod)\n    end\nend\n\nmacro generatetypes(json)\n    :(@generatetypes $(esc(json)) :JSONTypes)\nend\n\n# convenience function to go from json_string, to file with module\n\"\"\"\n    writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)\n\nWrite the result of the [`generatetypes`](@ref) function to file.\n\"\"\"\nfunction writetypes(\n    json,\n    file_name;\n    module_name::Symbol = :JSONTypes,\n    root_name = :Root,\n    mutable::Bool = true,\n)\n    mod = generatetypes(json, module_name)\n    write_exprs(mod, file_name)\nend\n"}, "source_files_changed": ["src/gentypes.jl"], "test_files_changed": ["test/gentypes.jl"], "lines_changed": 12, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "d4672e3deef912a46cc6da7a757e80e0a9eb8441", "parent_sha": "4ff5d84563c64ce9ad5338bb2e74108323bc37df", "commit_message": "Support read(::AbstractCommand)", "commit_date": "2021-03-05T17:55:13+00:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/read.jl", "target_symbol": "read", "signature": null, "confidence": 0.75}, "files_before": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::IO; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\nfunction read(str::AbstractString; jsonlines::Bool=false, kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1); kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        obj = Object(buf, tape, Dict{Symbol, Int}())\n        populateinds!(obj)\n        return obj\n    elseif isarray(t)\n        arr = Array{geteltype(tape[2])}(buf, tape, Int[])\n        populateinds!(arr)\n        return arr\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nconst FLOAT_INT_BOUND = 2.0^53\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            !isfinite(float) && !allow_inf && @goto invalid\n            @check\n            # if, for example, we've already parsed floats in an array, just keep them all as floats and don't check for ints\n            if checkint\n                fp, ip = modf(float)\n                if fp == 0 && Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                    # ok great, we know the number is integral and pretty much in Int64 range\n                    if -FLOAT_INT_BOUND < float < FLOAT_INT_BOUND\n                        # easy case, integer w/ less than or equal to 53-bits of precision\n                        int = unsafe_trunc(Int64, float)\n                    else\n                        # if our integral float is > 53-bit precision, we need to reparse the Int so we don't get a lossy conversion\n                        # there are also a few floats that satisfy Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                        # that actually overflow Int64, like -9223372036854775809 and 9223372036854775808\n                        # in those cases, we're going to verify that this Int64 parsing doesn't overflow\n                        int, code, floatpos2 = Parsers.typeparser(Int64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n                        if floatpos2 < floatpos\n                            # ah, but there's one more case we need to handle: a > 53-bit precision integer given in\n                            # exponent form, like 1e17 or 9.007199254740994e15; in those cases, the truncation to Int64 *isn't* lossy\n                            int = unsafe_trunc(Int64, float)\n                        end\n                    end\n                    if code > 0\n                        @inbounds tape[tapeidx] = INT\n                        @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                        return floatpos, tapeidx + 2\n                    end\n                end\n            end\n            @inbounds tape[tapeidx] = FLOAT\n            @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "files_after": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::Union{IO, Base.AbstractCmd}; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\nfunction read(str::AbstractString; jsonlines::Bool=false, kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1); kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        obj = Object(buf, tape, Dict{Symbol, Int}())\n        populateinds!(obj)\n        return obj\n    elseif isarray(t)\n        arr = Array{geteltype(tape[2])}(buf, tape, Int[])\n        populateinds!(arr)\n        return arr\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nconst FLOAT_INT_BOUND = 2.0^53\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            !isfinite(float) && !allow_inf && @goto invalid\n            @check\n            # if, for example, we've already parsed floats in an array, just keep them all as floats and don't check for ints\n            if checkint\n                fp, ip = modf(float)\n                if fp == 0 && Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                    # ok great, we know the number is integral and pretty much in Int64 range\n                    if -FLOAT_INT_BOUND < float < FLOAT_INT_BOUND\n                        # easy case, integer w/ less than or equal to 53-bits of precision\n                        int = unsafe_trunc(Int64, float)\n                    else\n                        # if our integral float is > 53-bit precision, we need to reparse the Int so we don't get a lossy conversion\n                        # there are also a few floats that satisfy Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                        # that actually overflow Int64, like -9223372036854775809 and 9223372036854775808\n                        # in those cases, we're going to verify that this Int64 parsing doesn't overflow\n                        int, code, floatpos2 = Parsers.typeparser(Int64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n                        if floatpos2 < floatpos\n                            # ah, but there's one more case we need to handle: a > 53-bit precision integer given in\n                            # exponent form, like 1e17 or 9.007199254740994e15; in those cases, the truncation to Int64 *isn't* lossy\n                            int = unsafe_trunc(Int64, float)\n                        end\n                    end\n                    if code > 0\n                        @inbounds tape[tapeidx] = INT\n                        @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                        return floatpos, tapeidx + 2\n                    end\n                end\n            end\n            @inbounds tape[tapeidx] = FLOAT\n            @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "source_files_changed": ["src/read.jl"], "test_files_changed": ["test/json.jl"], "lines_changed": 7, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "c8fde8ab46068cdf3d9a786bc332b98a9a146291", "parent_sha": "566bdefdd7aef976a7596216d008490b0b3bb250", "commit_message": "More robust algorithm for parsing number as Int64 vs. Float64", "commit_date": "2021-02-26T23:48:06-07:00", "action": {"type": "ADD_FIELD", "target_file": "src/read.jl", "target_symbol": "FLOAT_INT_BOUND", "signature": null, "confidence": 0.75}, "files_before": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::IO; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\nfunction read(str::AbstractString; jsonlines::Bool=false, kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1); kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        obj = Object(buf, tape, Dict{Symbol, Int}())\n        populateinds!(obj)\n        return obj\n    elseif isarray(t)\n        arr = Array{geteltype(tape[2])}(buf, tape, Int[])\n        populateinds!(arr)\n        return arr\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            !isfinite(float) && !allow_inf && @goto invalid\n            @check\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "files_after": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::IO; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\nfunction read(str::AbstractString; jsonlines::Bool=false, kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1); kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        obj = Object(buf, tape, Dict{Symbol, Int}())\n        populateinds!(obj)\n        return obj\n    elseif isarray(t)\n        arr = Array{geteltype(tape[2])}(buf, tape, Int[])\n        populateinds!(arr)\n        return arr\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nconst FLOAT_INT_BOUND = 2.0^53\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            !isfinite(float) && !allow_inf && @goto invalid\n            @check\n            # if, for example, we've already parsed floats in an array, just keep them all as floats and don't check for ints\n            if checkint\n                fp, ip = modf(float)\n                if fp == 0 && Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                    # ok great, we know the number is integral and pretty much in Int64 range\n                    if -FLOAT_INT_BOUND < float < FLOAT_INT_BOUND\n                        # easy case, integer w/ less than or equal to 53-bits of precision\n                        int = unsafe_trunc(Int64, float)\n                    else\n                        # if our integral float is > 53-bit precision, we need to reparse the Int so we don't get a lossy conversion\n                        # there are also a few floats that satisfy Float64(typemin(Int64)) <= float <= Float64(typemax(Int64))\n                        # that actually overflow Int64, like -9223372036854775809 and 9223372036854775808\n                        # in those cases, we're going to verify that this Int64 parsing doesn't overflow\n                        int, code, floatpos2 = Parsers.typeparser(Int64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n                        if floatpos2 < floatpos\n                            # ah, but there's one more case we need to handle: a > 53-bit precision integer given in\n                            # exponent form, like 1e17 or 9.007199254740994e15; in those cases, the truncation to Int64 *isn't* lossy\n                            int = unsafe_trunc(Int64, float)\n                        end\n                    end\n                    if code > 0\n                        @inbounds tape[tapeidx] = INT\n                        @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                        return floatpos, tapeidx + 2\n                    end\n                end\n            end\n            @inbounds tape[tapeidx] = FLOAT\n            @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "source_files_changed": ["src/read.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 51, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "15bce73ccdf842fd4be867d90626b4f48f83c1c2", "parent_sha": "4b689c082ac20c10458269b5a6262216649ec590", "commit_message": "Add JSON3.write(filename, contents)", "commit_date": "2021-01-12T20:28:40-05:00", "action": {"type": "ADD_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.85}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction write(fname::String, obj::T; kw...) where {T}\n    open(fname, \"w\") do io\n        write(io, obj; kw...)\n    end\n    fname\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 7, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "5d8a4f3950a9c6f6bf0745a29c185159ba2c64e8", "parent_sha": "bf24f8ebd54669257ee482c91e51361d6ca7b20d", "commit_message": "Ensure with allow_inf=false, we don't parse `-Inf` as valid", "commit_date": "2020-11-19T21:38:40-07:00", "action": {"type": "UNKNOWN", "target_file": "src/read.jl", "target_symbol": null, "signature": null, "confidence": 0.1}, "files_before": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::IO; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\nfunction read(str::AbstractString; jsonlines::Bool=false, kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1); kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            @check\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "files_after": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::IO; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\nfunction read(str::AbstractString; jsonlines::Bool=false, kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1); kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            !isfinite(float) && !allow_inf && @goto invalid\n            @check\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "source_files_changed": ["src/read.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 4, "is_valid": false, "validation_errors": ["Low action confidence: 0.1", "Could not infer action type"]}
{"repo": "JSON3.jl", "commit_sha": "b61633b09f6c5429d1a63f7dfb2a6b7a168f8adc", "parent_sha": "ea4752bbf5ca90124c38aa42065e7327ce5f8487", "commit_message": "Print Inf as Infinity", "commit_date": "2020-11-19T17:21:27-05:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    if isinf(x)\n        # Although this is non-standard JSON, \"Infinity\" is commonly used.\n        # See https://docs.python.org/3/library/json.html#infinite-and-nan-number-values.\n        if sign(x) == -1\n            @writechar '-'\n        end\n        @writechar 'I' 'n' 'f' 'i' 'n' 'i' 't' 'y'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": ["test/json.jl", "test/runtests.jl"], "lines_changed": 19, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "765cccad3e450bc69fe6fefa933f14b4ae744eb5", "parent_sha": "8215991030d351b37633c74919467336c1f08b05", "commit_message": "Add jsonlines keyword argument to JSON3.read(json)", "commit_date": "2020-11-11T01:22:28-07:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/read.jl", "target_symbol": "read", "signature": null, "confidence": 0.75}, "files_before": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::IO; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\nfunction read(str::AbstractString; kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    pos, tapeidx = read!(buf, Int64(1), len, b, tape, Int64(1), Any; kw...)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            @check\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "files_after": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::IO; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\nfunction read(str::AbstractString; jsonlines::Bool=false, kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    if jsonlines\n        pos, tapeidx = jsonlines!(buf, pos, len, b, tape, Int64(1); kw...)\n    else\n        pos, tapeidx = read!(buf, pos, len, b, tape, Int64(1), Any; kw...)\n    end\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            @check\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction jsonlines!(buf, pos, len, b, tape, tapeidx; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    if pos > len\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        @wh\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        b = getbyte(buf, pos)\n        if b != UInt8('\\n') && b != UInt8('\\r')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        if pos > len\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            @goto done\n        end\n        if b == UInt8('\\r')\n            b = getbyte(buf, pos)\n            if b == UInt8('\\n')\n                pos += 1\n                if pos > len\n                    @check\n                    @inbounds tape[arridx] = array(tapeidx - arridx)\n                    @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n                    @goto done\n                end\n            end\n        end\n        b = getbyte(buf, pos)\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "source_files_changed": ["src/read.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 86, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "6cc6f823095dadcabe4c9af7979f5193725caa62", "parent_sha": "6b228c393dce069834f1378b4e086e87fd3637ca", "commit_message": "Add some `@inline` annotations", "commit_date": "2020-10-20T19:10:20-04:00", "action": {"type": "REMOVE_METHOD", "target_file": "src/structs.jl", "target_symbol": "read", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\nend\n\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\nfunction read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = StructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\nend\n\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\n@inline function read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = StructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\n@inline function write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n"}, "source_files_changed": ["src/structs.jl", "src/write.jl"], "test_files_changed": [], "lines_changed": 5, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "6b228c393dce069834f1378b4e086e87fd3637ca", "parent_sha": "77bebd589b0d8b0b70783b29b86d34589624903a", "commit_message": "Introduce a JSON3-specific StructType: RawType", "commit_date": "2020-10-20T11:21:03-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "read", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\nend\n\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = StructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nstruct RawType <: StructType end\n\nstruct RawValue{S}\n    bytes::S\n    pos::Int\n    len::Int\nend\n\nfunction rawbytes end\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction _prepare_read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    return buf, pos, len, b\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\nend\n\nfunction read!(str::AbstractString, x::T; kw...) where {T}\n    buf, pos, len, b = _prepare_read(str, T)\n    pos, x = read!(StructType(T), buf, pos, len, b, T, x; kw...)\n    return x\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\nconst GLOBAL_IGNORED_TAPE = zeros(UInt64, 1024)\n\nfunction read(::RawType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    newpos, _ = read!(buf, pos, len, b, GLOBAL_IGNORED_TAPE, 1, Any; kw...)\n    return newpos, construct(T, RawValue(buf, pos, newpos - pos))\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x = T()\n    pos, x = read!(Mutable(), buf, pos, len, b, T, x; kw...)\n    return pos, x\nend\n\n@inline function read!(::Any, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    throw(ArgumentError(\"read! is only defined when T is of the `Mutable` struct type\"))\nend\n\n@inline function read!(::Mutable, buf, pos, len, b, ::Type{T}, x::T; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = StructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction write(::RawType, buf, pos, len, x::T; kw...) where {T}\n    bytes = rawbytes(x)\n    @check length(bytes)\n    for b in bytes\n        @inbounds buf[pos] = b\n        pos += 1\n    end\n    return buf, pos, len\nend\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n\n"}, "source_files_changed": ["src/structs.jl", "src/write.jl"], "test_files_changed": [], "lines_changed": 27, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "aeb5fa8ca4c9bb7652d6ffee173761ff723e7e33", "parent_sha": "a7426d57f693afdf11ded1dd2b47ff91f0c3b7e7", "commit_message": "Ensure keyword args pass through JSON3.pretty correctly", "commit_date": "2020-10-06T16:39:11-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": "read", "signature": null, "confidence": 0.6}, "files_before": {"src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = StructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; allow_inf::Bool=false, kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any}; kw...)\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any}; kw...)\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String; kw...)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing; kw...)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool; kw...)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = StructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 21, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "e53636b251401391bb20d6beb9f6000bea1958fb", "parent_sha": "0412c7402d4cf1047f3f3f9d807282b75665c35f", "commit_message": "Allow typed parsing of NumberType to be quoted (via keyword arg)", "commit_date": "2020-09-21T22:08:07-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": "read", "signature": null, "confidence": 0.75}, "files_before": {"src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = StructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; parsequoted::Bool=false, kw...) where {T}\n    quoted = false\n    if parsequoted && b == UInt8('\"')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        quoted = true\n    end\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if quoted\n        b = getbyte(buf, pos)\n        @assert b == UInt8('\"')\n        pos += 1\n    end\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = StructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 20, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "f906d2393ae5ee492ab6cb64bda5b0d514f5223a", "parent_sha": "792c73c00ec0aeb3bfb09184a87d8515f3ed0a5f", "commit_message": "Use StructTypes.construct", "commit_date": "2020-08-31T18:01:01+02:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.75}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, convert(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, convert(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, StructTypes.construct(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, StructTypes.construct(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 4, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "792c73c00ec0aeb3bfb09184a87d8515f3ed0a5f", "parent_sha": "0b1c03a23ca6ebf8fc52a539991fa984ccc06581", "commit_message": "Same for Bool", "commit_date": "2020-08-28T15:09:17+02:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.75}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, convert(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, convert(Bool, x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, convert(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "0b1c03a23ca6ebf8fc52a539991fa984ccc06581", "parent_sha": "35a5e19a01505328ba2a9d8c874afae71939e378", "commit_message": "Use `convert(T, x)` instead of `T(x)`", "commit_date": "2020-08-28T15:00:10+02:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.75}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} =\n    write(NumberType(), buf, pos, len, convert(StructTypes.numbertype(T), x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 3, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "bda1550f4e4d5e7644388ac71584c28307e2afa6", "parent_sha": "23e8ea34ad4d36d717326ebae91dc2b650c6df82", "commit_message": "Remove debug statement", "commit_date": "2020-07-16T08:46:12-06:00", "action": {"type": "UNKNOWN", "target_file": "src/pretty.jl", "target_symbol": null, "signature": null, "confidence": 0.1}, "files_before": {"src/pretty.jl": "macro pretty(json)\n    return esc(:(JSON3.pretty($json)))\nend\n\npretty(str; kw...) = pretty(stdout, str; kw...)\npretty(out::IO, x) = pretty(out, JSON3.write(x))\nfunction pretty(out::IO, str::String, indent=0, offset=0; kw...)\n    @show str\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        return\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    # printing object?\n    if b == UInt8('{')\n        Base.write(out, b)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            Base.write(out, b)\n            return\n        end\n        Base.write(out, '\\n')\n        indent += 1\n        keys = []\n        vals = []\n        # loop thru all key-value pairs, keeping track of longest key to pad others\n        while b != UInt8('}')\n            pos, str = JSON3.read(StructTypes.StringType(), buf, pos, len, b, String; kw...)\n            push!(keys, str)\n            @eof\n            b = getbyte(buf, pos) # ':'\n            @wh\n            pos += 1\n            @eof\n            b = getbyte(buf, pos)\n            @wh\n            pos, x = JSON3.read(StructTypes.Struct(), buf, pos, len, b, Any; kw...)\n            push!(vals, x)\n            @eof\n            b = getbyte(buf, pos) # ',' or '}'\n            @wh\n            if b == UInt8('}')\n                break\n            end\n            pos += 1\n            @eof\n            b = getbyte(buf, pos)\n            @wh\n        end\n        maxlen = maximum(map(sizeof, keys)) + 5\n        # @show maxlen\n        for i = 1:length(keys)\n            Base.write(out, \"  \"^indent)\n            Base.write(out, lpad(\"\\\"$(keys[i])\\\"\" * \": \", maxlen + offset, ' '))\n            pretty(out, JSON3.write(vals[i]; kw...), indent, maxlen + offset; kw...)\n            if i == length(keys)\n                indent -= 1\n                Base.write(out, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"}\")\n            else\n                Base.write(out, \",\\n\")\n            end\n        end\n\n    # printing array?\n    elseif b == UInt8('[')\n        Base.write(out, b)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            Base.write(out, b)\n            return\n        end\n        Base.write(out, '\\n')\n        indent += 1\n        vals = []\n        while b != UInt8(']')\n            pos, x = JSON3.read(StructTypes.Struct(), buf, pos, len, b, Any; kw...)\n            push!(vals, x)\n            @eof\n            b = getbyte(buf, pos) # ',' or ']'\n            @wh\n            if b == UInt8(']')\n                break\n            end\n            pos += 1\n            @eof\n            b = getbyte(buf, pos)\n            @wh\n        end\n        for (i, val) in enumerate(vals)\n            Base.write(out, \"  \"^indent * \" \"^offset)\n            pretty(out, JSON3.write(vals[i]; kw...), indent, offset; kw...)\n            if i == length(vals)\n                indent -= 1\n                Base.write(out, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"]\")\n            else\n                Base.write(out, \",\\n\")\n            end\n        end\n\n    # printing constant?\n    else\n        Base.write(out, str)\n    end\n    return\n@label invalid\n    Base.error(\"error pretty-fying json: $error\")\nend"}, "files_after": {"src/pretty.jl": "macro pretty(json)\n    return esc(:(JSON3.pretty($json)))\nend\n\npretty(str; kw...) = pretty(stdout, str; kw...)\npretty(out::IO, x) = pretty(out, JSON3.write(x))\nfunction pretty(out::IO, str::String, indent=0, offset=0; kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        return\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    # printing object?\n    if b == UInt8('{')\n        Base.write(out, b)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            Base.write(out, b)\n            return\n        end\n        Base.write(out, '\\n')\n        indent += 1\n        keys = []\n        vals = []\n        # loop thru all key-value pairs, keeping track of longest key to pad others\n        while b != UInt8('}')\n            pos, str = JSON3.read(StructTypes.StringType(), buf, pos, len, b, String; kw...)\n            push!(keys, str)\n            @eof\n            b = getbyte(buf, pos) # ':'\n            @wh\n            pos += 1\n            @eof\n            b = getbyte(buf, pos)\n            @wh\n            pos, x = JSON3.read(StructTypes.Struct(), buf, pos, len, b, Any; kw...)\n            push!(vals, x)\n            @eof\n            b = getbyte(buf, pos) # ',' or '}'\n            @wh\n            if b == UInt8('}')\n                break\n            end\n            pos += 1\n            @eof\n            b = getbyte(buf, pos)\n            @wh\n        end\n        maxlen = maximum(map(sizeof, keys)) + 5\n        # @show maxlen\n        for i = 1:length(keys)\n            Base.write(out, \"  \"^indent)\n            Base.write(out, lpad(\"\\\"$(keys[i])\\\"\" * \": \", maxlen + offset, ' '))\n            pretty(out, JSON3.write(vals[i]; kw...), indent, maxlen + offset; kw...)\n            if i == length(keys)\n                indent -= 1\n                Base.write(out, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"}\")\n            else\n                Base.write(out, \",\\n\")\n            end\n        end\n\n    # printing array?\n    elseif b == UInt8('[')\n        Base.write(out, b)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            Base.write(out, b)\n            return\n        end\n        Base.write(out, '\\n')\n        indent += 1\n        vals = []\n        while b != UInt8(']')\n            pos, x = JSON3.read(StructTypes.Struct(), buf, pos, len, b, Any; kw...)\n            push!(vals, x)\n            @eof\n            b = getbyte(buf, pos) # ',' or ']'\n            @wh\n            if b == UInt8(']')\n                break\n            end\n            pos += 1\n            @eof\n            b = getbyte(buf, pos)\n            @wh\n        end\n        for (i, val) in enumerate(vals)\n            Base.write(out, \"  \"^indent * \" \"^offset)\n            pretty(out, JSON3.write(vals[i]; kw...), indent, offset; kw...)\n            if i == length(vals)\n                indent -= 1\n                Base.write(out, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"]\")\n            else\n                Base.write(out, \",\\n\")\n            end\n        end\n\n    # printing constant?\n    else\n        Base.write(out, str)\n    end\n    return\n@label invalid\n    Base.error(\"error pretty-fying json: $error\")\nend"}, "source_files_changed": ["src/pretty.jl"], "test_files_changed": [], "lines_changed": 1, "is_valid": false, "validation_errors": ["Low action confidence: 0.1", "Could not infer action type"]}
{"repo": "JSON3.jl", "commit_sha": "ae7e2c8f72ec6a6cd824d7ea64c2519b0f98a8e4", "parent_sha": "97d4e8fb4972212f6b981ff767e27d5bf8a3fba5", "commit_message": "Fix tests", "commit_date": "2020-07-14T23:59:11-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/pretty.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/pretty.jl": "macro pretty(json)\n    return esc(:(JSON3.pretty($json)))\nend\n\npretty(str; kw...) = pretty(stdout, str; kw...)\npretty(out::IO, x) = pretty(out, JSON3.write(x))\nfunction pretty(out::IO, str::String, indent=0, offset=0; kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        return\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    # printing object?\n    if b == UInt8('{')\n        Base.write(out, b)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            Base.write(out, b)\n            return\n        end\n        Base.write(out, '\\n')\n        indent += 1\n        keys = []\n        vals = []\n        # loop thru all key-value pairs, keeping track of longest key to pad others\n        while b != UInt8('}')\n            pos, str = JSON3.read(StructTypes.StringType(), buf, pos, len, b, String; kw...)\n            push!(keys, str)\n            @eof\n            b = getbyte(buf, pos) # ':'\n            @wh\n            pos += 1\n            @eof\n            b = getbyte(buf, pos)\n            @wh\n            pos, x = JSON3.read(StructTypes.Struct(), buf, pos, len, b, Any; kw...)\n            push!(vals, x)\n            @eof\n            b = getbyte(buf, pos) # ',' or '}'\n            @wh\n            if b == UInt8('}')\n                break\n            end\n            pos += 1\n            @eof\n            b = getbyte(buf, pos)\n            @wh\n        end\n        maxlen = maximum(map(sizeof, keys)) + 5\n        # @show maxlen\n        for i = 1:length(keys)\n            Base.write(out, \"  \"^indent)\n            Base.write(out, lpad(\"\\\"$(keys[i])\\\"\" * \": \", maxlen + offset, ' '))\n            pretty(out, JSON3.write(vals[i]; kw...), indent, maxlen + offset; kw...)\n            if i == length(keys)\n                indent -= 1\n                Base.write(out, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"}\")\n            else\n                Base.write(out, \",\\n\")\n            end\n        end\n\n    # printing array?\n    elseif b == UInt8('[')\n        Base.write(out, b)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            Base.write(out, b)\n            return\n        end\n        Base.write(out, '\\n')\n        indent += 1\n        vals = []\n        while b != UInt8(']')\n            pos, x = JSON3.read(StructTypes.Struct(), buf, pos, len, b, Any; kw...)\n            push!(vals, x)\n            @eof\n            b = getbyte(buf, pos) # ',' or ']'\n            @wh\n            if b == UInt8(']')\n                break\n            end\n            pos += 1\n            @eof\n            b = getbyte(buf, pos)\n            @wh\n        end\n        for (i, val) in enumerate(vals)\n            Base.write(out, \"  \"^indent * \" \"^offset)\n            pretty(out, JSON3.write(vals[i]; kw...), indent, offset; kw...)\n            if i == length(vals)\n                indent -= 1\n                Base.write(out, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"]\")\n            else\n                Base.write(out, \",\\n\")\n            end\n        end\n\n    # printing constant?\n    else\n        Base.write(out, str)\n    end\n    return\n@label invalid\n    Base.error(\"error pretty-fying json: $error\")\nend"}, "files_after": {"src/pretty.jl": "macro pretty(json)\n    return esc(:(JSON3.pretty($json)))\nend\n\npretty(str; kw...) = pretty(stdout, str; kw...)\npretty(out::IO, x) = pretty(out, JSON3.write(x))\nfunction pretty(out::IO, str::String, indent=0, offset=0; kw...)\n    @show str\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        return\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    # printing object?\n    if b == UInt8('{')\n        Base.write(out, b)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            Base.write(out, b)\n            return\n        end\n        Base.write(out, '\\n')\n        indent += 1\n        keys = []\n        vals = []\n        # loop thru all key-value pairs, keeping track of longest key to pad others\n        while b != UInt8('}')\n            pos, str = JSON3.read(StructTypes.StringType(), buf, pos, len, b, String; kw...)\n            push!(keys, str)\n            @eof\n            b = getbyte(buf, pos) # ':'\n            @wh\n            pos += 1\n            @eof\n            b = getbyte(buf, pos)\n            @wh\n            pos, x = JSON3.read(StructTypes.Struct(), buf, pos, len, b, Any; kw...)\n            push!(vals, x)\n            @eof\n            b = getbyte(buf, pos) # ',' or '}'\n            @wh\n            if b == UInt8('}')\n                break\n            end\n            pos += 1\n            @eof\n            b = getbyte(buf, pos)\n            @wh\n        end\n        maxlen = maximum(map(sizeof, keys)) + 5\n        # @show maxlen\n        for i = 1:length(keys)\n            Base.write(out, \"  \"^indent)\n            Base.write(out, lpad(\"\\\"$(keys[i])\\\"\" * \": \", maxlen + offset, ' '))\n            pretty(out, JSON3.write(vals[i]; kw...), indent, maxlen + offset; kw...)\n            if i == length(keys)\n                indent -= 1\n                Base.write(out, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"}\")\n            else\n                Base.write(out, \",\\n\")\n            end\n        end\n\n    # printing array?\n    elseif b == UInt8('[')\n        Base.write(out, b)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            Base.write(out, b)\n            return\n        end\n        Base.write(out, '\\n')\n        indent += 1\n        vals = []\n        while b != UInt8(']')\n            pos, x = JSON3.read(StructTypes.Struct(), buf, pos, len, b, Any; kw...)\n            push!(vals, x)\n            @eof\n            b = getbyte(buf, pos) # ',' or ']'\n            @wh\n            if b == UInt8(']')\n                break\n            end\n            pos += 1\n            @eof\n            b = getbyte(buf, pos)\n            @wh\n        end\n        for (i, val) in enumerate(vals)\n            Base.write(out, \"  \"^indent * \" \"^offset)\n            pretty(out, JSON3.write(vals[i]; kw...), indent, offset; kw...)\n            if i == length(vals)\n                indent -= 1\n                Base.write(out, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"]\")\n            else\n                Base.write(out, \",\\n\")\n            end\n        end\n\n    # printing constant?\n    else\n        Base.write(out, str)\n    end\n    return\n@label invalid\n    Base.error(\"error pretty-fying json: $error\")\nend"}, "source_files_changed": ["src/pretty.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 38, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "f71d66b84577593ad6c10c1ecbb015aea74b1981", "parent_sha": "6887f90052cfc268ac79a3559d14c5ccbc405f5d", "commit_message": "Allow reading NaN values via keyword arg", "commit_date": "2020-07-14T21:24:30-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/read.jl", "target_symbol": "read", "signature": null, "confidence": 0.75}, "files_before": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    pos, tapeidx = read!(buf, Int64(1), len, b, tape, Int64(1), Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            @check\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL))\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "files_after": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::IO; kw...) = read(Base.read(io, String); kw...)\nread(bytes::AbstractVector{UInt8}; kw...) = read(VectorString(bytes); kw...)\n\nfunction read(str::AbstractString; kw...)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    pos, tapeidx = read!(buf, Int64(1), len, b, tape, Int64(1), Any; kw...)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true; allow_inf::Bool=false)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object; allow_inf=allow_inf)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array; allow_inf=allow_inf)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+') || (allow_inf && (b == UInt8('N') || b == UInt8('I')))\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            @check\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object}; kw...)\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array}; kw...)\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL); kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "source_files_changed": ["src/read.jl"], "test_files_changed": ["test/json.jl"], "lines_changed": 30, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "6887f90052cfc268ac79a3559d14c5ccbc405f5d", "parent_sha": "3f6efcfc443e939c40a160bbc23b2218212f487a", "commit_message": "For larger json reads, save up to 10x memory", "commit_date": "2020-07-14T21:50:44-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/read.jl", "target_symbol": "check", "signature": null, "confidence": 0.85}, "files_before": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, Int64(1), len, b, tape, Int64(1), Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL))\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "files_after": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len < 1000 ? Vector{UInt64}(undef, len + 4) :\n        Vector{UInt64}(undef, div(len, 10))\n    pos, tapeidx = read!(buf, Int64(1), len, b, tape, Int64(1), Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nmacro check()\n    esc(quote\n        if (tapeidx + 1) > length(tape)\n            newsize = ceil(Int64, ((1 - pos / len) + 1) * tapeidx) + 20\n            # println(\"resizing tape from $(pointer(tape)) $tapeidx to $newsize\")\n            resize!(tape, newsize)\n        end\n    end)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            @check\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @check\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @check\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @check\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @check\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @check\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @check\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @check\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL))\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @check\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "source_files_changed": ["src/read.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 25, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "3f6efcfc443e939c40a160bbc23b2218212f487a", "parent_sha": "0da73d19e4768d721f6e42d8848026e81b4b7e1b", "commit_message": "Fix #63 by making sure we escape Symbols like Strings (#64)", "commit_date": "2020-06-28T21:40:54-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.75}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nwrite(::StringType, buf, pos, len, x::Symbol; kw...) = write(StringType(), buf, pos, len, String(x); kw...)\n\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 28, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "f31a8005c1d0920bea24ac61d7fcaeed87c712e5", "parent_sha": "304ae9fd910a57d8453fbb3de22676f6fa2deed4", "commit_message": "Fix uint8 overflow", "commit_date": "2020-05-30T23:57:53-05:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.6}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 1]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": ["test/json.jl"], "lines_changed": 13, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "7b68091f386368641ed10e1a1ac586fc6365f1c1", "parent_sha": "23cd5116a91e9c13c1be1b7a21cc23aa8c87cd1f", "commit_message": "Throw a more informative error on invalid numbers. Fixes #57.", "commit_date": "2020-05-06T08:16:00-06:00", "action": {"type": "UNKNOWN", "target_file": "src/JSON3.jl", "target_symbol": null, "signature": null, "confidence": 0.1}, "files_before": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap, UUIDs, Dates, StructTypes\n\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(Int64(2)), 0])\n\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\nend\n\nArray{T}(buf::S, tape::TT) where {T, S, TT} = Array{T, S, TT}(buf, tape)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedClosingArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, key, default)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol, default::T)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = v isa Object || v isa Array ? copy(v) : v\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\nBase.copy(arr::Array) = map(x->x isa Object || x isa Array ? copy(x) : x, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n", "src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, Int64(1), len, b, tape, Int64(1), Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL))\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "files_after": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap, UUIDs, Dates, StructTypes\n\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(Int64(2)), 0])\n\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\nend\n\nArray{T}(buf::S, tape::TT) where {T, S, TT} = Array{T, S, TT}(buf, tape)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedClosingArrayChar ExpectedComma ExpectedSemiColon InvalidChar InvalidNumber\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, key, default)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol, default::T)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = v isa Object || v isa Array ? copy(v) : v\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\nBase.copy(arr::Array) = map(x->x isa Object || x isa Array ? copy(x) : x, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n", "src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, Int64(1), len, b, tape, Int64(1), Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n        invalid(InvalidNumber, buf, pos, Float64)\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL))\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "source_files_changed": ["src/JSON3.jl", "src/read.jl"], "test_files_changed": [], "lines_changed": 3, "is_valid": false, "validation_errors": ["Low action confidence: 0.1", "Could not infer action type"]}
{"repo": "JSON3.jl", "commit_sha": "23cd5116a91e9c13c1be1b7a21cc23aa8c87cd1f", "parent_sha": "b1db39a8ecaf739571f43a3edc9d8585387f7c9d", "commit_message": "Take off a probably incorrect inbounds when writing integer minus sign", "commit_date": "2020-04-17T22:51:27-06:00", "action": {"type": "UNKNOWN", "target_file": "src/write.jl", "target_symbol": null, "signature": null, "confidence": 0.1}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": false, "validation_errors": ["Low action confidence: 0.1", "Could not infer action type"]}
{"repo": "JSON3.jl", "commit_sha": "168b7578d2ac7b1a93346676c7a95912ebe49617", "parent_sha": "38a6efd9aca4133dfffd978ae8dc64d107b9ba7e", "commit_message": "Allow bypassing the json spec by serializing infinite floats", "commit_date": "2020-02-16T14:34:09+00:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.75}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; kw...)\n    isfinite(x) || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; allow_inf::Bool=false, kw...)\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; allow_inf::Bool=false, kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || allow_inf || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": ["test/json.jl"], "lines_changed": 15, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "27b4335fe3dcd74a1745c1c8c7e41a08f6fc9258", "parent_sha": "fad6527c3a9f30e4815adac15a9f33d2d754ea95", "commit_message": "[BREAKING]: don't allow serializing non finite floats as per JSON spec. Fixes #49", "commit_date": "2020-02-15T17:28:48-07:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.6}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; kw...)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; kw...) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; kw...)\n    isfinite(x) || error(\"$x not allowed to be written in JSON spec\")\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; kw...) where {T <: Base.IEEEFloat}\n    isfinite(x) || error(\"$x not allowed to be written in JSON spec\")\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": ["test/json.jl"], "lines_changed": 14, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "0e3e5858aa5b6c17aebb269eb8537ff6aabfd8bd", "parent_sha": "81c5c4cff993c33a1380580e16e9d4273cc87c69", "commit_message": "Fix another use of merge on keyword args for write", "commit_date": "2020-02-09T22:54:57-07:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = StructClosure(buf, pos, len, kw)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; kw...)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; kw...) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw.data)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = StructClosure(buf, pos, len, kw.data)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw.data, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw.data)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; kw...)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; kw...) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/structs.jl", "src/write.jl"], "test_files_changed": [], "lines_changed": 8, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "4f60d69c8fe231030382a8d86cf959775e0ef2e6", "parent_sha": "760748ca2f33497f3da388735f98f5c36f5aec1e", "commit_message": "Cleanup", "commit_date": "2020-02-07T00:25:11-07:00", "action": {"type": "UNKNOWN", "target_file": "src/read.jl", "target_symbol": null, "signature": null, "confidence": 0.1}, "files_before": {"src/read.jl": "struct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n# Base.ncodeunits(s::VectorString) = length(s.bytes)\n# Base.codeunit(s::VectorString) = UInt8\n# Base.length(s::VectorString) = ncodeunits(s)\n# function Base.codeunit(s::VectorString, i::Int)\n#     @inbounds b = s.bytes[i]\n#     return b\n# end\n# Base.pointer(v::VectorString) = pointer(v.bytes)\n# Base.pointer(v::VectorString, i::Integer) = pointer(v.bytes, i)\n# Base.unsafe_convert(::Type{Ptr{UInt8}}, v::VectorString) = pointer(v)\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, Int64(1), len, b, tape, Int64(1), Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL))\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "files_after": {"src/read.jl": "# temporary wrapper to pass byte vector through\nstruct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, Int64(1), len, b, tape, Int64(1), Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL))\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "source_files_changed": ["src/read.jl"], "test_files_changed": [], "lines_changed": 11, "is_valid": false, "validation_errors": ["Low action confidence: 0.1", "Could not infer action type"]}
{"repo": "JSON3.jl", "commit_sha": "760748ca2f33497f3da388735f98f5c36f5aec1e", "parent_sha": "347cdfa1bf0d818136fb8924d50914edf6be9f68", "commit_message": "Improve Mutable read perf by ensuring we merge NamedTuples and not fallback to Dict merging. Fixes #41", "commit_date": "2020-02-07T00:21:08-07:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/read.jl", "target_symbol": "JSON3.StructType", "signature": null, "confidence": 0.5}, "files_before": {"src/read.jl": "struct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.ncodeunits(s::VectorString) = length(s.bytes)\nBase.codeunit(s::VectorString) = UInt8\nBase.length(s::VectorString) = ncodeunits(s)\nfunction Base.codeunit(s::VectorString, i::Int)\n    @inbounds b = s.bytes[i]\n    return b\nend\nBase.pointer(v::VectorString) = pointer(v.bytes)\nBase.pointer(v::VectorString, i::Integer) = pointer(v.bytes, i)\nBase.unsafe_convert(::Type{Ptr{UInt8}}, v::VectorString) = pointer(v)\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, Int64(1), len, b, tape, Int64(1), Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL))\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n", "src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = StructClosure(buf, pos, len, kw)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/utils.jl": "_symbol(ptr, len) = ccall(:jl_symbol_n, Ref{Symbol}, (Ptr{UInt8}, Int), ptr, len)\n\nfunction getbyte(buf, pos)\n    unsafe_load(pointer(buf.s), pos)\nend\n\nmacro eof()\n    esc(quote\n        if pos > len\n            error = UnexpectedEOF\n            @goto invalid\n        end\n    end)\nend\n\nmacro wh()\n    esc(quote\n        while b == UInt8('\\t') || b == UInt8(' ') || b == UInt8('\\n') || b == UInt8('\\r')\n            pos += 1\n            if pos > len\n                error = UnexpectedEOF\n                @goto invalid\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nconst EMPTY   = UInt64(0b00000000) << 56\nconst OBJECT  = UInt64(0b00000001) << 56\nconst ARRAY   = UInt64(0b00000010) << 56\nconst STRING  = UInt64(0b00000100) << 56\nconst INT     = UInt64(0b00001000) << 56\nconst FLOAT   = UInt64(0b00010000) << 56\nconst BOOL    = UInt64(0b00100000) << 56\nconst NULL    = UInt64(0b01000000) << 56\nconst ANY     = UInt64(0b10000000) << 56\n\nconst TYPEMASK = 0xff00000000000000\n\nempty(x::UInt64) = (x & TYPEMASK) == EMPTY\nisany(x::UInt64) = (x & TYPEMASK) == ANY\nisobject(x::UInt64) = (x & TYPEMASK) == OBJECT\nisarray(x::UInt64) = (x & TYPEMASK) == ARRAY\nisstring(x::UInt64) = (x & TYPEMASK) == STRING\nisint(x::UInt64) = (x & TYPEMASK) == INT\nisfloat(x::UInt64) = (x & TYPEMASK) == FLOAT\nisbool(x::UInt64) = (x & TYPEMASK) == BOOL\nisnull(x::UInt64) = (x & TYPEMASK) == NULL\nisintfloat(x::UInt64) = (x & TYPEMASK) == (INT | FLOAT)\nnonnull(x::UInt64) = (x & TYPEMASK) & ~NULL\n\nfunction geteltype(T)\n    if empty(T); return Union{}\n    elseif isany(T); return Any\n    elseif isobject(T); return Object\n    elseif isarray(T); return Array\n    elseif isstring(T); return String\n    elseif isint(T); return Int64\n    elseif isfloat(T); return Float64\n    elseif isbool(T); return Bool\n    elseif isnull(T); return Nothing\n    elseif isintfloat(T); return Union{Int64, Float64}\n    else return Union{geteltype(nonnull(T)), Nothing}\n    end\nend\n\nobject(tapelen) = OBJECT | Core.bitcast(UInt64, tapelen)\narray(tapelen)  = ARRAY  | Core.bitcast(UInt64, tapelen)\neltypelen(T, len) = T | Core.bitcast(UInt64, len)\nstring(len) = STRING | Core.bitcast(UInt64, len)\nconst ESCAPE_BIT = UInt64(1) << 63\n\nfunction promoteeltype(A, B)\n    if A == B\n        return A\n    elseif A == EMPTY\n        return B\n    elseif (A | B) == A\n        return A\n    elseif A == INT && B == FLOAT\n        return A | B\n    elseif A == FLOAT && B == INT\n        return A | B\n    elseif A == (INT | NULL) && B == FLOAT\n        return A | B\n    elseif A == (FLOAT | NULL) && B == INT\n        return A | B\n    elseif A == NULL || B == NULL\n        return A | B\n    else\n        return ANY\n    end\nend\n\ngettypemask(x::UInt64) = x & TYPEMASK\ngetnontypemask(x::UInt64) = Core.bitcast(Int64, x & ~TYPEMASK)\ngetpos(x::UInt64) = Core.bitcast(Int64, getnontypemask(x) >> 16)\ngetlen(x::UInt64) = Core.bitcast(Int64, x & 0x000000000000ffff)\n\ngettapelen(T, x::UInt64) = ifelse(isobject(x) | isarray(x), getnontypemask(x), 2)\ngettapelen(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = 2\n\nregularstride(T) = false\nregularstride(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = true\nregularstride(::Type{Union{Int64, Float64}}) = true\n\ngetvalue(::Type{Object}, buf, tape, tapeidx, t) = Object(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)))\ngetvalue(::Type{Array}, buf, tape, tapeidx, t) = Array{geteltype(tape[tapeidx+1])}(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)))\n\nfunction getvalue(::Type{Symbol}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return Symbol(unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t))))\n    else\n        return _symbol(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{String}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t)))\n    else\n        return unsafe_string(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{Int64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Int64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Float64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Float64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Union{Int64, Float64}}, buf, tape, tapeidx, t)\n    @inbounds x = tape[tapeidx+1]\n    return Core.bitcast(ifelse(isint(t), Int64, Float64), x)\nend\ngetvalue(::Type{Bool}, buf, tape, tapeidx, t) = getnontypemask(t) == UInt64(1)\ngetvalue(::Type{Nothing}, buf, tape, tapeidx, t) = nothing\n@inline function getvalue(T, buf, tape, tapeidx, t)\n    if isobject(t)\n        return getvalue(Object, buf, tape, tapeidx, t)\n    elseif isarray(t)\n        return getvalue(Array, buf, tape, tapeidx, t)\n    elseif isstring(t)\n        return getvalue(String, buf, tape, tapeidx, t)\n    elseif isint(t)\n        return getvalue(Int64, buf, tape, tapeidx, t)\n    elseif isfloat(t)\n        return getvalue(Float64, buf, tape, tapeidx, t)\n    elseif isbool(t)\n        return getvalue(Bool, buf, tape, tapeidx, t)\n    elseif isnull(t)\n        return nothing\n    end\nend\n\nBase.@pure function symbolin(names::Tuple{Vararg{Symbol}}, name::Symbol)\n    for nm in names\n        nm === name && return true\n    end\n    return false\nend\n"}, "files_after": {"src/read.jl": "struct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.codeunits(x::VectorString) = x.bytes\n# Base.ncodeunits(s::VectorString) = length(s.bytes)\n# Base.codeunit(s::VectorString) = UInt8\n# Base.length(s::VectorString) = ncodeunits(s)\n# function Base.codeunit(s::VectorString, i::Int)\n#     @inbounds b = s.bytes[i]\n#     return b\n# end\n# Base.pointer(v::VectorString) = pointer(v.bytes)\n# Base.pointer(v::VectorString, i::Integer) = pointer(v.bytes, i)\n# Base.unsafe_convert(::Type{Ptr{UInt8}}, v::VectorString) = pointer(v)\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, Int64(1), len, b, tape, Int64(1), Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL))\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n", "src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw.data, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw.data)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = StructClosure(buf, pos, len, kw)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/utils.jl": "_symbol(ptr, len) = ccall(:jl_symbol_n, Ref{Symbol}, (Ptr{UInt8}, Int), ptr, len)\n\nfunction getbyte(buf, pos)\n    unsafe_load(pointer(buf.s), pos)\nend\n\nfunction getbyte(buf::AbstractVector{UInt8}, pos)\n    @inbounds b = buf[pos]\n    return b\nend\n\nmacro eof()\n    esc(quote\n        if pos > len\n            error = UnexpectedEOF\n            @goto invalid\n        end\n    end)\nend\n\nmacro wh()\n    esc(quote\n        while b == UInt8('\\t') || b == UInt8(' ') || b == UInt8('\\n') || b == UInt8('\\r')\n            pos += 1\n            if pos > len\n                error = UnexpectedEOF\n                @goto invalid\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nconst EMPTY   = UInt64(0b00000000) << 56\nconst OBJECT  = UInt64(0b00000001) << 56\nconst ARRAY   = UInt64(0b00000010) << 56\nconst STRING  = UInt64(0b00000100) << 56\nconst INT     = UInt64(0b00001000) << 56\nconst FLOAT   = UInt64(0b00010000) << 56\nconst BOOL    = UInt64(0b00100000) << 56\nconst NULL    = UInt64(0b01000000) << 56\nconst ANY     = UInt64(0b10000000) << 56\n\nconst TYPEMASK = 0xff00000000000000\n\nempty(x::UInt64) = (x & TYPEMASK) == EMPTY\nisany(x::UInt64) = (x & TYPEMASK) == ANY\nisobject(x::UInt64) = (x & TYPEMASK) == OBJECT\nisarray(x::UInt64) = (x & TYPEMASK) == ARRAY\nisstring(x::UInt64) = (x & TYPEMASK) == STRING\nisint(x::UInt64) = (x & TYPEMASK) == INT\nisfloat(x::UInt64) = (x & TYPEMASK) == FLOAT\nisbool(x::UInt64) = (x & TYPEMASK) == BOOL\nisnull(x::UInt64) = (x & TYPEMASK) == NULL\nisintfloat(x::UInt64) = (x & TYPEMASK) == (INT | FLOAT)\nnonnull(x::UInt64) = (x & TYPEMASK) & ~NULL\n\nfunction geteltype(T)\n    if empty(T); return Union{}\n    elseif isany(T); return Any\n    elseif isobject(T); return Object\n    elseif isarray(T); return Array\n    elseif isstring(T); return String\n    elseif isint(T); return Int64\n    elseif isfloat(T); return Float64\n    elseif isbool(T); return Bool\n    elseif isnull(T); return Nothing\n    elseif isintfloat(T); return Union{Int64, Float64}\n    else return Union{geteltype(nonnull(T)), Nothing}\n    end\nend\n\nobject(tapelen) = OBJECT | Core.bitcast(UInt64, tapelen)\narray(tapelen)  = ARRAY  | Core.bitcast(UInt64, tapelen)\neltypelen(T, len) = T | Core.bitcast(UInt64, len)\nstring(len) = STRING | Core.bitcast(UInt64, len)\nconst ESCAPE_BIT = UInt64(1) << 63\n\nfunction promoteeltype(A, B)\n    if A == B\n        return A\n    elseif A == EMPTY\n        return B\n    elseif (A | B) == A\n        return A\n    elseif A == INT && B == FLOAT\n        return A | B\n    elseif A == FLOAT && B == INT\n        return A | B\n    elseif A == (INT | NULL) && B == FLOAT\n        return A | B\n    elseif A == (FLOAT | NULL) && B == INT\n        return A | B\n    elseif A == NULL || B == NULL\n        return A | B\n    else\n        return ANY\n    end\nend\n\ngettypemask(x::UInt64) = x & TYPEMASK\ngetnontypemask(x::UInt64) = Core.bitcast(Int64, x & ~TYPEMASK)\ngetpos(x::UInt64) = Core.bitcast(Int64, getnontypemask(x) >> 16)\ngetlen(x::UInt64) = Core.bitcast(Int64, x & 0x000000000000ffff)\n\ngettapelen(T, x::UInt64) = ifelse(isobject(x) | isarray(x), getnontypemask(x), 2)\ngettapelen(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = 2\n\nregularstride(T) = false\nregularstride(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = true\nregularstride(::Type{Union{Int64, Float64}}) = true\n\ngetvalue(::Type{Object}, buf, tape, tapeidx, t) = Object(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)))\ngetvalue(::Type{Array}, buf, tape, tapeidx, t) = Array{geteltype(tape[tapeidx+1])}(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)))\n\nfunction getvalue(::Type{Symbol}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return Symbol(unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t))))\n    else\n        return _symbol(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{String}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t)))\n    else\n        return unsafe_string(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{Int64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Int64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Float64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Float64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Union{Int64, Float64}}, buf, tape, tapeidx, t)\n    @inbounds x = tape[tapeidx+1]\n    return Core.bitcast(ifelse(isint(t), Int64, Float64), x)\nend\ngetvalue(::Type{Bool}, buf, tape, tapeidx, t) = getnontypemask(t) == UInt64(1)\ngetvalue(::Type{Nothing}, buf, tape, tapeidx, t) = nothing\n@inline function getvalue(T, buf, tape, tapeidx, t)\n    if isobject(t)\n        return getvalue(Object, buf, tape, tapeidx, t)\n    elseif isarray(t)\n        return getvalue(Array, buf, tape, tapeidx, t)\n    elseif isstring(t)\n        return getvalue(String, buf, tape, tapeidx, t)\n    elseif isint(t)\n        return getvalue(Int64, buf, tape, tapeidx, t)\n    elseif isfloat(t)\n        return getvalue(Float64, buf, tape, tapeidx, t)\n    elseif isbool(t)\n        return getvalue(Bool, buf, tape, tapeidx, t)\n    elseif isnull(t)\n        return nothing\n    end\nend\n\nBase.@pure function symbolin(names::Tuple{Vararg{Symbol}}, name::Symbol)\n    for nm in names\n        nm === name && return true\n    end\n    return false\nend\n"}, "source_files_changed": ["src/read.jl", "src/structs.jl", "src/utils.jl"], "test_files_changed": [], "lines_changed": 66, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "e51d1b56f6b4abe704fd34efedeb71c7fbe2110a", "parent_sha": "7d43bc71a2cbc6bebc4c7534dbb76299ffdb76e8", "commit_message": "Write DictTypes even when length(pairs(dict_type)) undefined", "commit_date": "2020-01-05T20:39:47-05:00", "action": {"type": "ADD_METHOD", "target_file": "src/write.jl", "target_symbol": "Base.pairs", "signature": null, "confidence": 0.85}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n    n = length(pairs)\n    i = 1\n    for (k, v) in pairs\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; kw...)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; kw...) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n\n    next = iterate(pairs)\n    while next !== nothing\n        (k, v), state = next\n\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n\n        next = iterate(pairs, state)\n        next === nothing || @writechar ','\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; kw...)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; kw...) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 24, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "0cd3ba0dab62f51ea75d8c7617161884c59db1d1", "parent_sha": "76d2060b9df9653e4167d8ab05682dda1de0c981", "commit_message": "Fix 32-bit", "commit_date": "2019-12-31T15:26:12-07:00", "action": {"type": "MODIFY_FIELD", "target_file": "src/structs.jl", "target_symbol": null, "signature": null, "confidence": 0.6}, "files_before": {"src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int64\n    len::Int64\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int64\n    len::Int64\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int64\n    len::Int64\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = StructClosure(buf, pos, len, kw)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int64\n    len::Int64\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n    n = length(pairs)\n    i = 1\n    for (k, v) in pairs\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; kw...)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; kw...) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/structs.jl": "import StructTypes: StructType, DictType, ArrayType, StringType, NumberType, BoolType, NullType, NoStructType, Struct, Mutable, construct, AbstractType, subtypes, subtypekey\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; kw...)\n    if b == UInt8('{')\n        return read(DictType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x, code, pos = Parsers.typeparser(StructTypes.numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct TupleClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::TupleClosure)(i, nm, TT)\n    buf, pos, len, b = f.buf, f.pos, f.len, f.b\n    pos, x = read(StructType(TT), buf, pos, len, b, TT; f.kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        f.pos = pos + 1\n        return x\n    elseif b == UInt8(',')\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        f.pos = pos\n        f.b = b\n        return x\n    else\n        error = ExpectedComma\n        @goto invalid\n    end\n@label invalid\n    invalid(error, buf, pos, TT)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    c = TupleClosure(buf, pos, len, b, kw)\n    x = StructTypes.construct(c, T)\n\n    return c.pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(DictType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{Dict}; kw...) = read(DictType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::DictType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(DictType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::DictType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nmutable struct MutableClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    b::UInt8\n    kw::KW\nend\n\n@inline function (f::MutableClosure)(i, nm, TT; kw...)\n    kw2 = merge(kw, f.kw)\n    pos_i, y_i = read(StructType(TT), f.buf, f.pos, f.len, f.b, TT; kw2...)\n    f.pos = pos_i\n    return y_i\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        c = MutableClosure(buf, pos, len, b, kw)\n        if StructTypes.applyfield!(c, x, key)\n            pos = c.pos\n        else\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nmutable struct StructClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    kw::KW\nend\n\n@inline function (f::StructClosure)(i, nm, TT)\n    pos_i, x_i = readvalue(f.buf, f.pos, f.len, TT; f.kw...)\n    f.pos = pos_i\n    return x_i\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    c = StructClosure(buf, pos, len, kw)\n    x = StructTypes.construct(c, T)\n    return c.pos, x\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in StructTypes.keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T; kw...) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj; kw...)\n    return String(resize!(buf, pos - 1))\nend\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::DictType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}; kw...) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `StructTypes.StructType`\"))\n\nmutable struct WriteClosure{T, KW}\n    buf::T\n    pos::Int\n    len::Int\n    afterfirst::Bool\n    kw::KW\nend\n\n@inline function (f::WriteClosure)(i, nm, TT, v; kw...)\n    buf, pos, len = f.buf, f.pos, f.len\n    if f.afterfirst\n        @writechar ','\n    else\n        f.afterfirst = true\n    end\n    kw2 = merge(kw, f.kw)\n    buf, pos, len = write(StringType(), buf, pos, len, nm; kw2...)\n    @writechar ':'\n    buf, pos, len = write(StructType(v), buf, pos, len, v; kw2...)\n    f.buf = buf\n    f.pos = pos\n    f.len = len\n    return\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    c = WriteClosure(buf, pos, len, false, kw)\n    StructTypes.foreachfield(c, x)\n    buf = c.buf\n    pos = c.pos\n    len = c.len\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::DictType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '{'\n    pairs = StructTypes.keyvaluepairs(x)\n    n = length(pairs)\n    i = 1\n    for (k, v) in pairs\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T; kw...) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y; kw...)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x; kw...)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x; kw...) = write(BoolType(), buf, pos, len, Bool(x); kw...)\nfunction write(::BoolType, buf, pos, len, x::Bool; kw...)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer; kw...)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T; kw...) where {T} = write(NumberType(), buf, pos, len, StructTypes.numbertype(T)(x); kw...)\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat; kw...)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T; kw...) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x::T; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = write(StringType(), buf, pos, len, Dates.format(x, dateformat); kw...)\nwrite(::StringType, buf, pos, len, x; kw...) = write(StringType(), buf, pos, len, Base.string(x); kw...)\nfunction write(::StringType, buf, pos, len, x::AbstractString; kw...)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol; kw...)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/structs.jl", "src/write.jl"], "test_files_changed": [], "lines_changed": 16, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "bba49ace809ffbc5c7b87cac96c03edd3308e02b", "parent_sha": "ea9ae4860abf8c39aea699942340ba83d9558ed1", "commit_message": "Cleanup docs", "commit_date": "2019-11-16T01:40:34-07:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "JSON3.keywordargs", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialized, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n\n\"\"\"\nfunction keywordargs end\n\nkeywordargs(x::T) where {T} = keywordargs(T)\nkeywordargs(::Type{T}) where {T} = NamedTuple()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSON\n  * `JSON3.construct(::Type{MyType}, x::Dict; kw...)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector; kw...)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String; kw...)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int; kw...)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool; kw...)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing; kw...)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; kw...)\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\nStructType(::Type{UUID}) = StringType()\nStructType(::Type{T}) where {T <: Dates.TimeType} = StringType()\n\nfunction construct(::Type{Char}, str::String; kw...)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int; kw...) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String; kw...) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int; kw...) = construct(T, unsafe_string(ptr, len); kw...)\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int; kw...) = _symbol(ptr, len)\nconstruct(::Type{T}, str::String; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = T(str, dateformat)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool; kw...) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing; kw...) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real; kw...) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}; kw...) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        # positioned at start of value\n        eT_i = fieldtype(T, i)\n        pos, x_i = read(StructType(eT_i), buf, pos, len, b, eT_i; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if N == i\n            if b == UInt8(']')\n                return pos + 1, Base.@ncall i tuple x\n            else\n                error = ExpectedClosingArrayChar\n                @goto invalid\n            end\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n    vals = []\n    for i = 33:N\n        eT_i = fieldtype(T, i)\n        pos, y = read(StructType(eT_i), buf, pos, len, b, eT_i; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            pos += 1\n            break\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n    return pos, (x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15, x_16,\n                  x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29, x_30, x_31, x_32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}; kw...) where {K, V} = x\nconstruct(T, x::Dict{K, V}; kw...) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict; kw...) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict; kw...) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict; kw...) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}; kw...) = read(ObjectType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    kwargs = keywordargs(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        # unroll the first 32 field checks to avoid dynamic dispatch if possible\n        Base.@nif(\n            32,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT_i = fieldtype(T, i)\n                if isempty(kwargs)\n                    pos, y_i = read(StructType(FT_i), buf, pos, len, b, FT_i; kw...)\n                else\n                    pos, y_i = read(StructType(FT_i), buf, pos, len, b, FT_i; kwargs[fieldname(T, i)]...)\n                end\n                is_included && setfield!(x, i, y_i)\n            end,\n            i -> begin\n                is_field_still_unread = true\n                for j in 33:N\n                    fieldname(T, j) === key || continue\n                    FT_j = fieldtype(T, j)\n                    if isempty(kwargs)\n                        pos, y_j = read(StructType(FT_j), buf, pos, len, b, FT_j; kw...)\n                    else\n                        pos, y_j = read(StructType(FT_j), buf, pos, len, b, FT_j; kwargs[fieldname(T, j)]...)\n                    end\n                    is_included && setfield!(x, j, y_j)\n                    is_field_still_unread = false\n                    break\n                end\n                if is_field_still_unread\n                    pos, _ = read(Struct(), buf, pos, len, b, Any)\n                end\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i); kw...)\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i); kw...)\n        push!(vals, y)\n    end\n    return pos, T(x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15, x_16,\n                  x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29, x_30, x_31, x_32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialized, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.keywordargs(::Type{MyType}) = (field1=(dateformat=dateformat\"mm/dd/yyyy\",), field2=(dateformat=dateformat\"HH MM SS\",))\n\nSpecify for a `JSON3.Mutable` `StructType` the keyword arguments by field, given as a `NamedTuple` of `NamedTuple`s, that should be passed\nto the `JSON3.construct` method when deserializing `MyType`. This essentially allows defining specific keyword arguments you'd like to be passed for each field\nin your struct. Note that keyword arguments can be passed when reading, like `JSON3.read(source, MyType; dateformat=...)` and they will be passed down to each `JSON3.construct` method.\n`JSON3.keywordargs` just allows the defining of specific keyword arguments per field.\n\"\"\"\nfunction keywordargs end\n\nkeywordargs(x::T) where {T} = keywordargs(T)\nkeywordargs(::Type{T}) where {T} = NamedTuple()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSON\n  * `JSON3.construct(::Type{MyType}, x::Dict; kw...)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector; kw...)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String; kw...)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int; kw...)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool; kw...)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing; kw...)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}; kw...) where {T} = read(Base.read(io, String), T; kw...)\nread(bytes::AbstractVector{UInt8}, ::Type{T}; kw...) where {T} = read(VectorString(bytes), T; kw...)\n\nfunction read(str::AbstractString, ::Type{T}; kw...) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T; kw...)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}; kw...) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union; kw...)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a; kw...)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b; kw...)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any}; kw...)\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\nStructType(::Type{UUID}) = StringType()\nStructType(::Type{T}) where {T <: Dates.TimeType} = StringType()\n\nfunction construct(::Type{Char}, str::String; kw...)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int; kw...) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String; kw...) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int; kw...) = construct(T, unsafe_string(ptr, len); kw...)\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int; kw...) = _symbol(ptr, len)\nconstruct(::Type{T}, str::String; dateformat::Dates.DateFormat=Dates.default_format(T), kw...) where {T <: Dates.TimeType} = T(str, dateformat)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen)); kw...) : construct(T, ptr, strlen; kw...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool; kw...) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true; kw...)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false; kw...)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing; kw...) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing; kw...)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real; kw...) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x; kw...)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}; kw...) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any; kw...)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT} = readarray(buf, pos, len, b, T, eT; kw...)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}; kw...) where {eT} = readarray(buf, pos, len, b, Tuple, eT; kw...)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals; kw...)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}; kw...) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        # positioned at start of value\n        eT_i = fieldtype(T, i)\n        pos, x_i = read(StructType(eT_i), buf, pos, len, b, eT_i; kw...)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if N == i\n            if b == UInt8(']')\n                return pos + 1, Base.@ncall i tuple x\n            else\n                error = ExpectedClosingArrayChar\n                @goto invalid\n            end\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n    vals = []\n    for i = 33:N\n        eT_i = fieldtype(T, i)\n        pos, y = read(StructType(eT_i), buf, pos, len, b, eT_i; kw...)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            pos += 1\n            break\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n    return pos, (x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15, x_16,\n                  x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29, x_30, x_31, x_32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}; kw...) where {K, V} = x\nconstruct(T, x::Dict{K, V}; kw...) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict; kw...) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict; kw...) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict; kw...) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}; kw...) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}; kw...) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any; kw...)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}; kw...) = read(ObjectType(), buf, pos, len, b, Dict, String, Any; kw...)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}; kw...) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T); kw...)\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}; kw...) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x; kw...)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V; kw...)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x; kw...)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    kwargs = keywordargs(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        # unroll the first 32 field checks to avoid dynamic dispatch if possible\n        Base.@nif(\n            32,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT_i = fieldtype(T, i)\n                if isempty(kwargs)\n                    pos, y_i = read(StructType(FT_i), buf, pos, len, b, FT_i; kw...)\n                else\n                    pos, y_i = read(StructType(FT_i), buf, pos, len, b, FT_i; kwargs[fieldname(T, i)]...)\n                end\n                is_included && setfield!(x, i, y_i)\n            end,\n            i -> begin\n                is_field_still_unread = true\n                for j in 33:N\n                    fieldname(T, j) === key || continue\n                    FT_j = fieldtype(T, j)\n                    if isempty(kwargs)\n                        pos, y_j = read(StructType(FT_j), buf, pos, len, b, FT_j; kw...)\n                    else\n                        pos, y_j = read(StructType(FT_j), buf, pos, len, b, FT_j; kwargs[fieldname(T, j)]...)\n                    end\n                    is_included && setfield!(x, j, y_j)\n                    is_field_still_unread = false\n                    break\n                end\n                if is_field_still_unread\n                    pos, _ = read(Struct(), buf, pos, len, b, Any)\n                end\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i); kw...)\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i); kw...)\n        push!(vals, y)\n    end\n    return pos, T(x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15, x_16,\n                  x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29, x_30, x_31, x_32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}; kw...) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T; kw...)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}; kw...) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT; kw...)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 30, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "bc73d23525ce13d8f918a9ba97c315c044eff04a", "parent_sha": "de7e11508e0d74bc4fe0f949cc93bfbca13ecc60", "commit_message": "Fix tuple reading issue in a struct", "commit_date": "2019-10-27T00:08:48-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "JSON3.StructType", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(::Type{Int}, str::String) = Parsers.parse(Int, str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT} = readarray(buf, pos, len, b, T, eT)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}) where {eT} = readarray(buf, pos, len, b, Tuple, eT)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        # positioned at start of value\n        eT_i = fieldtype(T, i)\n        pos, x_i = read(StructType(eT_i), buf, pos, len, b, eT_i)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if N == i\n            if b == UInt8(']')\n                return pos, Base.@ncall i tuple x\n            else\n                error = ExpectedClosingArrayChar\n                @goto invalid\n            end\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n    vals = []\n    for i = 33:N\n        eT_i = fieldtype(T, i)\n        pos, y = read(StructType(eT_i), buf, pos, len, b, eT_i)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            pos += 1\n            break\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n    return pos, (x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15, x_16,\n                  x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29, x_30, x_31, x_32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        # unroll the first 32 field checks to avoid dynamic dispatch if possible\n        Base.@nif(\n            32,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT_i = fieldtype(T, i)\n                pos, y_i = read(StructType(FT_i), buf, pos, len, b, FT_i)\n                is_included && setfield!(x, i, y_i)\n            end,\n            i -> begin\n                is_field_still_unread = true\n                for j in 33:N\n                    fieldname(T, j) === key || continue\n                    FT_j = fieldtype(T, j)\n                    pos, y_j = read(StructType(FT_j), buf, pos, len, b, FT_j)\n                    is_included && setfield!(x, j, y_j)\n                    is_field_still_unread = false\n                    break\n                end\n                if is_field_still_unread\n                    pos, _ = read(Struct(), buf, pos, len, b, Any)\n                end\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15, x_16,\n                  x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29, x_30, x_31, x_32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(::Type{Int}, str::String) = Parsers.parse(Int, str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT} = readarray(buf, pos, len, b, T, eT)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}) where {eT} = readarray(buf, pos, len, b, Tuple, eT)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        # positioned at start of value\n        eT_i = fieldtype(T, i)\n        pos, x_i = read(StructType(eT_i), buf, pos, len, b, eT_i)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if N == i\n            if b == UInt8(']')\n                return pos + 1, Base.@ncall i tuple x\n            else\n                error = ExpectedClosingArrayChar\n                @goto invalid\n            end\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n    vals = []\n    for i = 33:N\n        eT_i = fieldtype(T, i)\n        pos, y = read(StructType(eT_i), buf, pos, len, b, eT_i)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            pos += 1\n            break\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n    return pos, (x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15, x_16,\n                  x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29, x_30, x_31, x_32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        # unroll the first 32 field checks to avoid dynamic dispatch if possible\n        Base.@nif(\n            32,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT_i = fieldtype(T, i)\n                pos, y_i = read(StructType(FT_i), buf, pos, len, b, FT_i)\n                is_included && setfield!(x, i, y_i)\n            end,\n            i -> begin\n                is_field_still_unread = true\n                for j in 33:N\n                    fieldname(T, j) === key || continue\n                    FT_j = fieldtype(T, j)\n                    pos, y_j = read(StructType(FT_j), buf, pos, len, b, FT_j)\n                    is_included && setfield!(x, j, y_j)\n                    is_field_still_unread = false\n                    break\n                end\n                if is_field_still_unread\n                    pos, _ = read(Struct(), buf, pos, len, b, Any)\n                end\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15, x_16,\n                  x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29, x_30, x_31, x_32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        @show pos, y, Char(b)\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 10, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "50b2534edb01913df68e46f88495ee858e0cd9c5", "parent_sha": "e6c56412eb653893245e6854cf902818a0fb822f", "commit_message": "Fix failing test and remove appveyor", "commit_date": "2019-10-15T20:36:10-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "read", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(::Type{Int}, str::String) = Parsers.parse(Int, str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        # positioned at start of value\n        eT_i = fieldtype(T, i)\n        pos, x_i = read(StructType(eT_i), buf, pos, len, b, eT_i)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if N == i\n            if b == UInt8(']')\n                return pos, Base.@ncall i tuple x\n            else\n                error = ExpectedClosingArrayChar\n                @goto invalid\n            end\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n    vals = []\n    for i = 33:N\n        eT_i = fieldtype(T, i)\n        pos, y = read(StructType(eT_i), buf, pos, len, b, eT_i)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            pos += 1\n            break\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n    return pos, (x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15, x_16,\n                  x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29, x_30, x_31, x_32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        # unroll the first 32 field checks to avoid dynamic dispatch if possible\n        Base.@nif(\n            32,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT_i = fieldtype(T, i)\n                pos, y_i = read(StructType(FT_i), buf, pos, len, b, FT_i)\n                is_included && setfield!(x, i, y_i)\n            end,\n            i -> begin\n                is_field_still_unread = true\n                for j in 33:N\n                    fieldname(T, j) === key || continue\n                    FT_j = fieldtype(T, j)\n                    pos, y_j = read(StructType(FT_j), buf, pos, len, b, FT_j)\n                    is_included && setfield!(x, j, y_j)\n                    is_field_still_unread = false\n                    break\n                end\n                if is_field_still_unread\n                    pos, _ = read(Struct(), buf, pos, len, b, Any)\n                end\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15, x_16,\n                  x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29, x_30, x_31, x_32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(::Type{Int}, str::String) = Parsers.parse(Int, str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT} = readarray(buf, pos, len, b, T, eT)\nread(::ArrayType, buf, pos, len, b, ::Type{Tuple}, ::Type{eT}) where {eT} = readarray(buf, pos, len, b, Tuple, eT)\n\n@inline function readarray(buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, construct(T, vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T <: Tuple, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        pos += 1\n        return pos, T()\n    end\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        # positioned at start of value\n        eT_i = fieldtype(T, i)\n        pos, x_i = read(StructType(eT_i), buf, pos, len, b, eT_i)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if N == i\n            if b == UInt8(']')\n                return pos, Base.@ncall i tuple x\n            else\n                error = ExpectedClosingArrayChar\n                @goto invalid\n            end\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n    vals = []\n    for i = 33:N\n        eT_i = fieldtype(T, i)\n        pos, y = read(StructType(eT_i), buf, pos, len, b, eT_i)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            pos += 1\n            break\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n    return pos, (x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15, x_16,\n                  x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29, x_30, x_31, x_32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        # unroll the first 32 field checks to avoid dynamic dispatch if possible\n        Base.@nif(\n            32,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT_i = fieldtype(T, i)\n                pos, y_i = read(StructType(FT_i), buf, pos, len, b, FT_i)\n                is_included && setfield!(x, i, y_i)\n            end,\n            i -> begin\n                is_field_still_unread = true\n                for j in 33:N\n                    fieldname(T, j) === key || continue\n                    FT_j = fieldtype(T, j)\n                    pos, y_j = read(StructType(FT_j), buf, pos, len, b, FT_j)\n                    is_included && setfield!(x, j, y_j)\n                    is_field_still_unread = false\n                    break\n                end\n                if is_field_still_unread\n                    pos, _ = read(Struct(), buf, pos, len, b, Any)\n                end\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15, x_16,\n                  x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29, x_30, x_31, x_32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 59, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "0ef582a0930f9e35804c59551faa6119537c4e5a", "parent_sha": "25c5f34cdbc4ad2617f12bdad021c643de02577f", "commit_message": "Allow parsing Ints as object keys", "commit_date": "2019-10-13T02:04:40-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "construct", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        # unroll the first 32 field checks to avoid dynamic dispatch if possible\n        Base.@nif(\n            32,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT_i = fieldtype(T, i)\n                pos, y_i = read(StructType(FT_i), buf, pos, len, b, FT_i)\n                is_included && setfield!(x, i, y_i)\n            end,\n            i -> begin\n                is_field_still_unread = true\n                for j in 33:N\n                    fieldname(T, j) === key || continue\n                    FT_j = fieldtype(T, j)\n                    pos, y_j = read(StructType(FT_j), buf, pos, len, b, FT_j)\n                    is_included && setfield!(x, j, y_j)\n                    is_field_still_unread = false\n                    break\n                end\n                if is_field_still_unread\n                    pos, _ = read(Struct(), buf, pos, len, b, Any)\n                end\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(::Type{Int}, str::String) = Parsers.parse(Int, str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        # unroll the first 32 field checks to avoid dynamic dispatch if possible\n        Base.@nif(\n            32,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT_i = fieldtype(T, i)\n                pos, y_i = read(StructType(FT_i), buf, pos, len, b, FT_i)\n                is_included && setfield!(x, i, y_i)\n            end,\n            i -> begin\n                is_field_still_unread = true\n                for j in 33:N\n                    fieldname(T, j) === key || continue\n                    FT_j = fieldtype(T, j)\n                    pos, y_j = read(StructType(FT_j), buf, pos, len, b, FT_j)\n                    is_included && setfield!(x, j, y_j)\n                    is_field_still_unread = false\n                    break\n                end\n                if is_field_still_unread\n                    pos, _ = read(Struct(), buf, pos, len, b, Any)\n                end\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 1, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "a787cf11a7174ab8f2d7f04db7e9e3338c171666", "parent_sha": "c4f2257e67a7ce67a8b087208e22b8999bbd744c", "commit_message": "Fix writing to io objects", "commit_date": "2019-08-26T06:50:01-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.6}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return String(resize!(buf, pos - 1))\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{Object, Array, AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ObjectType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            y = _getfield(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                y = _getfield(x, i)\n                buf, pos, len = write(StructType(y), buf, pos, len, y)\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    pairs = keyvaluepairs(x)\n    n = length(pairs)\n    i = 1\n    for (k, v) in pairs\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T) where {T} = write(NumberType(), buf, pos, len, numbertype(T)(x))\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::AbstractString)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return Base.write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return String(resize!(buf, pos - 1))\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{Object, Array, AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ObjectType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            y = _getfield(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                y = _getfield(x, i)\n                buf, pos, len = write(StructType(y), buf, pos, len, y)\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    pairs = keyvaluepairs(x)\n    n = length(pairs)\n    i = 1\n    for (k, v) in pairs\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T) where {T} = write(NumberType(), buf, pos, len, numbertype(T)(x))\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::AbstractString)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "c4f2257e67a7ce67a8b087208e22b8999bbd744c", "parent_sha": "096316c2909352f0730dec97f479aff859aeae6d", "commit_message": "Switch to ryu float writing algorithm pending in Parsers for 3x+ speedup in float writing", "commit_date": "2019-08-24T23:59:25-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/write.jl", "target_symbol": "defaultminimum", "signature": null, "confidence": 0.85}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf Base.unsafe_write(io, pointer(buf), pos - 1)\nend\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{Object, Array, AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ObjectType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            y = _getfield(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                y = _getfield(x, i)\n                buf, pos, len = write(StructType(y), buf, pos, len, y)\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    pairs = keyvaluepairs(x)\n    n = length(pairs)\n    i = 1\n    for (k, v) in pairs\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T) where {T} = write(NumberType(), buf, pos, len, numbertype(T)(x))\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::AbstractString)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(::T) where {T <: Base.IEEEFloat} = Parsers.neededdigits(T)\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return write(io, resize!(buf, pos - 1))\nend\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = Base.StringVector(len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return String(resize!(buf, pos - 1))\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{Object, Array, AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = zeros(UInt8, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ObjectType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            y = _getfield(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                y = _getfield(x, i)\n                buf, pos, len = write(StructType(y), buf, pos, len, y)\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    pairs = keyvaluepairs(x)\n    n = length(pairs)\n    i = 1\n    for (k, v) in pairs\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T) where {T} = write(NumberType(), buf, pos, len, numbertype(T)(x))\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\n@inline function write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    @check Parsers.neededdigits(T)\n    pos = Parsers.writeshortest(buf, pos, x)\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::AbstractString)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 21, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "a6553249430b6ab7c2c0749136c13b576992eb17", "parent_sha": "e93665758ca65c6763905787f29be48216545f16", "commit_message": "Fix copy for String/nothing which don't have copy methods", "commit_date": "2019-08-15T14:45:30-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/JSON3.jl", "target_symbol": "Base.copy", "signature": null, "confidence": 0.75}, "files_before": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(Int64(2)), 0])\n\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\nend\n\nArray{T}(buf::S, tape::TT) where {T, S, TT} = Array{T, S, TT}(buf, tape)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, key, default)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol, default::T)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = copy(v)\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\nBase.copy(arr::Array) = map(copy, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n"}, "files_after": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(Int64(2)), 0])\n\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\nend\n\nArray{T}(buf::S, tape::TT) where {T, S, TT} = Array{T, S, TT}(buf, tape)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, key, default)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol, default::T)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = v isa Object || v isa Array ? copy(v) : v\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\nBase.copy(arr::Array) = map(x->x isa Object || x isa Array ? copy(x) : x, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n"}, "source_files_changed": ["src/JSON3.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 8, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "38ebd30d956af96960e445f3ecc4af71f77b58de", "parent_sha": "568a12c2bae1bcc1be3b4bab23783283fc2b9318", "commit_message": "use Base show for Array", "commit_date": "2019-08-13T17:57:40+02:00", "action": {"type": "REMOVE_METHOD", "target_file": "src/show.jl", "target_symbol": "Base.show", "signature": null, "confidence": 0.85}, "files_before": {"src/show.jl": "Base.show(io::IO, j::Object) = _show(io, j)\nBase.show(io::IO, j::Array) = _show(io, j)\n_show(io::IO, x, indent=0, offset=0) = show(io, x)\n\nfunction _show(io::IO, obj::Object, indent=0, offset=0)\n    if isempty(obj)\n        print(io, \"{}\")\n        return\n    end\n    println(io, \"{\")\n    indent += 1\n    keyvals = collect(obj)\n    keys = map(x->x[1], keyvals)\n    vals = map(x->x[2], keyvals)\n    maxlen = maximum(map(sizeof, keys)) + 5\n    # @show maxlen\n    for i = 1:length(keys)\n        Base.write(io, \"  \"^indent)\n        Base.write(io, lpad(\"\\\"$(keys[i])\\\"\" * \": \", maxlen + offset, ' '))\n        _show(io, vals[i], indent, maxlen + offset)\n        if i == length(keys)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"}\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n\nfunction _show(io::IO, arr::Array, indent=0, offset=0)\n    if isempty(arr)\n        print(io, \"[]\")\n        return\n    end\n    println(io, \"[\")\n    indent += 1\n    vals = collect(arr)\n    for (i, val) in enumerate(vals)\n        Base.write(io, \"  \"^indent * \" \"^offset)\n        _show(io, vals[i], indent, offset)\n        if i == length(vals)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"]\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n"}, "files_after": {"src/show.jl": "Base.show(io::IO, j::Object) = _show(io, j)\n# use the Base fallback AbstractArray show method instead\n# Base.show(io::IO, j::Array) = _show(io, j)\n_show(io::IO, x, indent=0, offset=0) = show(io, x)\n\nfunction _show(io::IO, obj::Object, indent=0, offset=0)\n    if isempty(obj)\n        print(io, \"{}\")\n        return\n    end\n    println(io, \"{\")\n    indent += 1\n    keyvals = collect(obj)\n    keys = map(x->x[1], keyvals)\n    vals = map(x->x[2], keyvals)\n    maxlen = maximum(map(sizeof, keys)) + 5\n    # @show maxlen\n    for i = 1:length(keys)\n        Base.write(io, \"  \"^indent)\n        Base.write(io, lpad(\"\\\"$(keys[i])\\\"\" * \": \", maxlen + offset, ' '))\n        _show(io, vals[i], indent, maxlen + offset)\n        if i == length(keys)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"}\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n\nfunction _show(io::IO, arr::Array, indent=0, offset=0)\n    if isempty(arr)\n        print(io, \"[]\")\n        return\n    end\n    println(io, \"[\")\n    indent += 1\n    vals = collect(arr)\n    for (i, val) in enumerate(vals)\n        Base.write(io, \"  \"^indent * \" \"^offset)\n        _show(io, vals[i], indent, offset)\n        if i == length(vals)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"]\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n"}, "source_files_changed": ["src/show.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 9, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "568a12c2bae1bcc1be3b4bab23783283fc2b9318", "parent_sha": "e6464ba24bfb563b4d88ac35111e7bf245714940", "commit_message": "overload Array show", "commit_date": "2019-08-13T17:49:25+02:00", "action": {"type": "ADD_METHOD", "target_file": "src/show.jl", "target_symbol": "Base.show", "signature": null, "confidence": 0.85}, "files_before": {"src/show.jl": "Base.show(io::IO, j::Object) = _show(io, j)\n_show(io::IO, x, indent=0, offset=0) = show(io, x)\n\nfunction _show(io::IO, obj::Object, indent=0, offset=0)\n    if isempty(obj)\n        print(io, \"{}\")\n        return\n    end\n    println(io, \"{\")\n    indent += 1\n    keyvals = collect(obj)\n    keys = map(x->x[1], keyvals)\n    vals = map(x->x[2], keyvals)\n    maxlen = maximum(map(sizeof, keys)) + 5\n    # @show maxlen\n    for i = 1:length(keys)\n        Base.write(io, \"  \"^indent)\n        Base.write(io, lpad(\"\\\"$(keys[i])\\\"\" * \": \", maxlen + offset, ' '))\n        _show(io, vals[i], indent, maxlen + offset)\n        if i == length(keys)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"}\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n\nfunction _show(io::IO, arr::Array, indent=0, offset=0)\n    if isempty(arr)\n        print(io, \"[]\")\n        return\n    end\n    println(io, \"[\")\n    indent += 1\n    vals = collect(arr)\n    for (i, val) in enumerate(vals)\n        Base.write(io, \"  \"^indent * \" \"^offset)\n        _show(io, vals[i], indent, offset)\n        if i == length(vals)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"]\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n"}, "files_after": {"src/show.jl": "Base.show(io::IO, j::Object) = _show(io, j)\nBase.show(io::IO, j::Array) = _show(io, j)\n_show(io::IO, x, indent=0, offset=0) = show(io, x)\n\nfunction _show(io::IO, obj::Object, indent=0, offset=0)\n    if isempty(obj)\n        print(io, \"{}\")\n        return\n    end\n    println(io, \"{\")\n    indent += 1\n    keyvals = collect(obj)\n    keys = map(x->x[1], keyvals)\n    vals = map(x->x[2], keyvals)\n    maxlen = maximum(map(sizeof, keys)) + 5\n    # @show maxlen\n    for i = 1:length(keys)\n        Base.write(io, \"  \"^indent)\n        Base.write(io, lpad(\"\\\"$(keys[i])\\\"\" * \": \", maxlen + offset, ' '))\n        _show(io, vals[i], indent, maxlen + offset)\n        if i == length(keys)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"}\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n\nfunction _show(io::IO, arr::Array, indent=0, offset=0)\n    if isempty(arr)\n        print(io, \"[]\")\n        return\n    end\n    println(io, \"[\")\n    indent += 1\n    vals = collect(arr)\n    for (i, val) in enumerate(vals)\n        Base.write(io, \"  \"^indent * \" \"^offset)\n        _show(io, vals[i], indent, offset)\n        if i == length(vals)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"]\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n"}, "source_files_changed": ["src/show.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 12, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "e6464ba24bfb563b4d88ac35111e7bf245714940", "parent_sha": "37ab02e420692965ff33cfd8a343a5b43c97c338", "commit_message": "use Int64 for all integers that end up bitcast to UInt64", "commit_date": "2019-08-13T16:58:05+02:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/JSON3.jl", "target_symbol": "Object", "signature": null, "confidence": 0.75}, "files_before": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(2), 0])\n\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\nend\n\nArray{T}(buf::S, tape::TT) where {T, S, TT} = Array{T, S, TT}(buf, tape)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, key, default)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol, default::T)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = copy(v)\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\nBase.copy(arr::Array) = map(copy, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n", "src/read.jl": "struct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.ncodeunits(s::VectorString) = length(s.bytes)\nBase.codeunit(s::VectorString) = UInt8\nBase.length(s::VectorString) = ncodeunits(s)\nfunction Base.codeunit(s::VectorString, i::Int)\n    @inbounds b = s.bytes[i]\n    return b\nend\nBase.pointer(v::VectorString) = pointer(v.bytes)\nBase.pointer(v::VectorString, i::Integer) = pointer(v.bytes, i)\nBase.unsafe_convert(::Type{Ptr{UInt8}}, v::VectorString) = pointer(v)\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = 0\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = 0\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL))\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "files_after": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(Int64(2)), 0])\n\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\nend\n\nArray{T}(buf::S, tape::TT) where {T, S, TT} = Array{T, S, TT}(buf, tape)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, key, default)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol, default::T)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = copy(v)\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\nBase.copy(arr::Array) = map(copy, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n", "src/read.jl": "struct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.ncodeunits(s::VectorString) = length(s.bytes)\nBase.codeunit(s::VectorString) = UInt8\nBase.length(s::VectorString) = ncodeunits(s)\nfunction Base.codeunit(s::VectorString, i::Int)\n    @inbounds b = s.bytes[i]\n    return b\nend\nBase.pointer(v::VectorString) = pointer(v.bytes)\nBase.pointer(v::VectorString, i::Integer) = pointer(v.bytes, i)\nBase.unsafe_convert(::Type{Ptr{UInt8}}, v::VectorString) = pointer(v)\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, Int64(1), len, b, tape, Int64(1), Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = Int64(0)\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        keypos = pos\n        keylen = Int64(0)\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(Int64(2))\n        @inbounds tape[tapeidx+1] = eltypelen(eT, Int64(0))\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = Int64(0)\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL))\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "source_files_changed": ["src/JSON3.jl", "src/read.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 26, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "3a9c584bc26664279a8e65fe714ac79f7ffe3df5", "parent_sha": "9d7dc2013e54f641de72ef7d18ff806087111e32", "commit_message": "cosmetic touch up", "commit_date": "2019-08-03T19:44:50+02:00", "action": {"type": "UNKNOWN", "target_file": "src/strings.jl", "target_symbol": null, "signature": null, "confidence": 0.1}, "files_before": {"src/strings.jl": "struct PointerString <: AbstractString\n    ptr::Ptr{UInt8}\n    len::Int\nend\n\nfunction Base.hash(s::PointerString, h::UInt)\n    h += Base.memhash_seed\n    ccall(Base.memhash, UInt, (Ptr{UInt8}, Csize_t, UInt32), s.ptr, s.len, h % UInt32) + h\nend\n\nimport Base: ==\nfunction ==(x::String, y::PointerString)\n    sizeof(x) == y.len && ccall(:memcmp, Cint, (Ptr{UInt8}, Ptr{UInt8}, Csize_t), pointer(x), y.ptr, y.len) == 0\nend\n==(y::PointerString, x::String) = x == y\n\nBase.codeunit(s::PointerString) = UInt8\nBase.ncodeunits(s::PointerString) = s.len\n@inline function Base.codeunit(s::PointerString, i::Integer)\n    @boundscheck checkbounds(s, i)\n    unsafe_load(s.ptr + i - 1)\nend\nBase.String(x::PointerString) = unsafe_string(x.ptr, x.len)\n\nfunction reverseescapechar(b)\n    b == UInt8('\"')     && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('/')  && return UInt8('/')\n    b == UInt8('b')  && return UInt8('\\b')\n    b == UInt8('f')  && return UInt8('\\f')\n    b == UInt8('n')  && return UInt8('\\n')\n    b == UInt8('r')  && return UInt8('\\r')\n    b == UInt8('t')  && return UInt8('\\t')\n    return 0x00\nend\n\nutf16_is_surrogate(c::UInt16) = (c & 0xf800) == 0xd800\nutf16_get_supplementary(lead::UInt16, trail::UInt16) = Char(UInt32(lead-0xd7f7)<<10 + trail)\n\ncharvalue(b) = (UInt8('0') <= b <= UInt8('9')) ? b - UInt8('0') :\n               (UInt8('a') <= b <= UInt8('f')) ? b - (UInt8('a') - 0x0a) :\n               (UInt8('A') <= b <= UInt8('F')) ? b - (UInt8('A') - 0x0a) :\n               throw(ArgumentError(\"JSON invalid unicode hex value\"))\n\n@noinline invalid_escape(str) = throw(ArgumentError(\"encountered invalid escape character in json string: \\\"$(String(str))\\\"\"))\n@noinline unescaped_control(b) = throw(ArgumentError(\"encountered unescaped control character in json: '$(escape_string(Base.string(Char(b))))'\"))\n\nfunction unescape(s)\n    n = ncodeunits(s)\n    buf = Base.StringVector(n)\n    len = 1\n    i = 1\n    @inbounds begin\n        while i <= n\n            b = codeunit(s, i)\n            if b == UInt8('\\\\')\n                i += 1\n                i > n && invalid_escape(s)\n                b = codeunit(s, i)\n                if b == UInt8('u')\n                    c = 0x0000\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    if utf16_is_surrogate(c)\n                        i += 3\n                        i > n && invalid_escape(s)\n                        c2 = 0x0000\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        ch = utf16_get_supplementary(c, c2)\n                    else\n                        ch = Char(c)\n                    end\n                    st = codeunits(Base.string(ch))\n                    for j = 1:length(st)-1\n                        @inbounds buf[len] = st[j]\n                        len += 1\n                    end\n                    b = st[end]\n                else\n                    b = reverseescapechar(b)\n                    b == 0x00 && invalid_escape(s)\n                end\n            end\n            @inbounds buf[len] = b\n            len += 1\n            i += 1\n        end\n    end\n    resize!(buf, len - 1)\n    return String(buf)\nend\n"}, "files_after": {"src/strings.jl": "struct PointerString <: AbstractString\n    ptr::Ptr{UInt8}\n    len::Int\nend\n\nfunction Base.hash(s::PointerString, h::UInt)\n    h += Base.memhash_seed\n    ccall(Base.memhash, UInt, (Ptr{UInt8}, Csize_t, UInt32), s.ptr, s.len, h % UInt32) + h\nend\n\nimport Base: ==\nfunction ==(x::String, y::PointerString)\n    sizeof(x) == y.len && ccall(:memcmp, Cint, (Ptr{UInt8}, Ptr{UInt8}, Csize_t), pointer(x), y.ptr, y.len) == 0\nend\n==(y::PointerString, x::String) = x == y\n\nBase.codeunit(s::PointerString) = UInt8\nBase.ncodeunits(s::PointerString) = s.len\n@inline function Base.codeunit(s::PointerString, i::Integer)\n    @boundscheck checkbounds(s, i)\n    unsafe_load(s.ptr + i - 1)\nend\nBase.String(x::PointerString) = unsafe_string(x.ptr, x.len)\n\nfunction reverseescapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('/')  && return UInt8('/')\n    b == UInt8('b')  && return UInt8('\\b')\n    b == UInt8('f')  && return UInt8('\\f')\n    b == UInt8('n')  && return UInt8('\\n')\n    b == UInt8('r')  && return UInt8('\\r')\n    b == UInt8('t')  && return UInt8('\\t')\n    return 0x00\nend\n\nutf16_is_surrogate(c::UInt16) = (c & 0xf800) == 0xd800\nutf16_get_supplementary(lead::UInt16, trail::UInt16) = Char(UInt32(lead-0xd7f7)<<10 + trail)\n\ncharvalue(b) = (UInt8('0') <= b <= UInt8('9')) ? b - UInt8('0') :\n               (UInt8('a') <= b <= UInt8('f')) ? b - (UInt8('a') - 0x0a) :\n               (UInt8('A') <= b <= UInt8('F')) ? b - (UInt8('A') - 0x0a) :\n               throw(ArgumentError(\"JSON invalid unicode hex value\"))\n\n@noinline invalid_escape(str) = throw(ArgumentError(\"encountered invalid escape character in json string: \\\"$(String(str))\\\"\"))\n@noinline unescaped_control(b) = throw(ArgumentError(\"encountered unescaped control character in json: '$(escape_string(Base.string(Char(b))))'\"))\n\nfunction unescape(s)\n    n = ncodeunits(s)\n    buf = Base.StringVector(n)\n    len = 1\n    i = 1\n    @inbounds begin\n        while i <= n\n            b = codeunit(s, i)\n            if b == UInt8('\\\\')\n                i += 1\n                i > n && invalid_escape(s)\n                b = codeunit(s, i)\n                if b == UInt8('u')\n                    c = 0x0000\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    if utf16_is_surrogate(c)\n                        i += 3\n                        i > n && invalid_escape(s)\n                        c2 = 0x0000\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        ch = utf16_get_supplementary(c, c2)\n                    else\n                        ch = Char(c)\n                    end\n                    st = codeunits(Base.string(ch))\n                    for j = 1:length(st)-1\n                        @inbounds buf[len] = st[j]\n                        len += 1\n                    end\n                    b = st[end]\n                else\n                    b = reverseescapechar(b)\n                    b == 0x00 && invalid_escape(s)\n                end\n            end\n            @inbounds buf[len] = b\n            len += 1\n            i += 1\n        end\n    end\n    resize!(buf, len - 1)\n    return String(buf)\nend\n"}, "source_files_changed": ["src/strings.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": false, "validation_errors": ["Low action confidence: 0.1", "Could not infer action type"]}
{"repo": "JSON3.jl", "commit_sha": "526f10ecde42bb3eecc2dc50a55371a5761cb598", "parent_sha": "7756d8d3766765e3e59333b190e60063191932a8", "commit_message": "Fix #19 by making sure we treat forward slash as a valid escaped character", "commit_date": "2019-08-01T20:20:09-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/strings.jl", "target_symbol": "Base.String", "signature": null, "confidence": 0.6}, "files_before": {"src/strings.jl": "struct PointerString <: AbstractString\n    ptr::Ptr{UInt8}\n    len::Int\nend\n\nfunction Base.hash(s::PointerString, h::UInt)\n    h += Base.memhash_seed\n    ccall(Base.memhash, UInt, (Ptr{UInt8}, Csize_t, UInt32), s.ptr, s.len, h % UInt32) + h\nend\n\nimport Base: ==\nfunction ==(x::String, y::PointerString)\n    sizeof(x) == y.len && ccall(:memcmp, Cint, (Ptr{UInt8}, Ptr{UInt8}, Csize_t), pointer(x), y.ptr, y.len) == 0\nend\n==(y::PointerString, x::String) = x == y\n\nBase.codeunit(s::PointerString) = UInt8\nBase.ncodeunits(s::PointerString) = s.len\n@inline function Base.codeunit(s::PointerString, i::Integer)\n    @boundscheck checkbounds(s, i)\n    unsafe_load(s.ptr + i - 1)\nend\nBase.String(x::PointerString) = unsafe_string(x.ptr, x.len)\n\nfunction reverseescapechar(b)\n    b == UInt8('\"')     && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('b')  && return UInt8('\\b')\n    b == UInt8('f')  && return UInt8('\\f')\n    b == UInt8('n')  && return UInt8('\\n')\n    b == UInt8('r')  && return UInt8('\\r')\n    b == UInt8('t')  && return UInt8('\\t')\n    return 0x00\nend\n\nutf16_is_surrogate(c::UInt16) = (c & 0xf800) == 0xd800\nutf16_get_supplementary(lead::UInt16, trail::UInt16) = Char(UInt32(lead-0xd7f7)<<10 + trail)\n\ncharvalue(b) = (UInt8('0') <= b <= UInt8('9')) ? b - UInt8('0') :\n               (UInt8('a') <= b <= UInt8('f')) ? b - (UInt8('a') - 0x0a) :\n               (UInt8('A') <= b <= UInt8('F')) ? b - (UInt8('A') - 0x0a) :\n               throw(ArgumentError(\"JSON invalid unicode hex value\"))\n\n@noinline invalid_escape(str) = throw(ArgumentError(\"encountered invalid escape character in json string: \\\"$(String(str))\\\"\"))\n@noinline unescaped_control(b) = throw(ArgumentError(\"encountered unescaped control character in json: '$(escape_string(Base.string(Char(b))))'\"))\n\nfunction unescape(s)\n    n = ncodeunits(s)\n    buf = Base.StringVector(n)\n    len = 1\n    i = 1\n    @inbounds begin\n        while i <= n\n            b = codeunit(s, i)\n            if b == UInt8('\\\\')\n                i += 1\n                i > n && invalid_escape(s)\n                b = codeunit(s, i)\n                if b == UInt8('u')\n                    c = 0x0000\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    if utf16_is_surrogate(c)\n                        i += 3\n                        i > n && invalid_escape(s)\n                        c2 = 0x0000\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        ch = utf16_get_supplementary(c, c2)\n                    else\n                        ch = Char(c)\n                    end\n                    st = codeunits(Base.string(ch))\n                    for j = 1:length(st)-1\n                        @inbounds buf[len] = st[j]\n                        len += 1\n                    end\n                    b = st[end]\n                else\n                    b = reverseescapechar(b)\n                    b == 0x00 && invalid_escape(s)\n                end\n            end\n            @inbounds buf[len] = b\n            len += 1\n            i += 1\n        end\n    end\n    resize!(buf, len - 1)\n    return String(buf)\nend\n"}, "files_after": {"src/strings.jl": "struct PointerString <: AbstractString\n    ptr::Ptr{UInt8}\n    len::Int\nend\n\nfunction Base.hash(s::PointerString, h::UInt)\n    h += Base.memhash_seed\n    ccall(Base.memhash, UInt, (Ptr{UInt8}, Csize_t, UInt32), s.ptr, s.len, h % UInt32) + h\nend\n\nimport Base: ==\nfunction ==(x::String, y::PointerString)\n    sizeof(x) == y.len && ccall(:memcmp, Cint, (Ptr{UInt8}, Ptr{UInt8}, Csize_t), pointer(x), y.ptr, y.len) == 0\nend\n==(y::PointerString, x::String) = x == y\n\nBase.codeunit(s::PointerString) = UInt8\nBase.ncodeunits(s::PointerString) = s.len\n@inline function Base.codeunit(s::PointerString, i::Integer)\n    @boundscheck checkbounds(s, i)\n    unsafe_load(s.ptr + i - 1)\nend\nBase.String(x::PointerString) = unsafe_string(x.ptr, x.len)\n\nfunction reverseescapechar(b)\n    b == UInt8('\"')     && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('/')  && return UInt8('/')\n    b == UInt8('b')  && return UInt8('\\b')\n    b == UInt8('f')  && return UInt8('\\f')\n    b == UInt8('n')  && return UInt8('\\n')\n    b == UInt8('r')  && return UInt8('\\r')\n    b == UInt8('t')  && return UInt8('\\t')\n    return 0x00\nend\n\nutf16_is_surrogate(c::UInt16) = (c & 0xf800) == 0xd800\nutf16_get_supplementary(lead::UInt16, trail::UInt16) = Char(UInt32(lead-0xd7f7)<<10 + trail)\n\ncharvalue(b) = (UInt8('0') <= b <= UInt8('9')) ? b - UInt8('0') :\n               (UInt8('a') <= b <= UInt8('f')) ? b - (UInt8('a') - 0x0a) :\n               (UInt8('A') <= b <= UInt8('F')) ? b - (UInt8('A') - 0x0a) :\n               throw(ArgumentError(\"JSON invalid unicode hex value\"))\n\n@noinline invalid_escape(str) = throw(ArgumentError(\"encountered invalid escape character in json string: \\\"$(String(str))\\\"\"))\n@noinline unescaped_control(b) = throw(ArgumentError(\"encountered unescaped control character in json: '$(escape_string(Base.string(Char(b))))'\"))\n\nfunction unescape(s)\n    n = ncodeunits(s)\n    buf = Base.StringVector(n)\n    len = 1\n    i = 1\n    @inbounds begin\n        while i <= n\n            b = codeunit(s, i)\n            if b == UInt8('\\\\')\n                i += 1\n                i > n && invalid_escape(s)\n                b = codeunit(s, i)\n                if b == UInt8('u')\n                    c = 0x0000\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    if utf16_is_surrogate(c)\n                        i += 3\n                        i > n && invalid_escape(s)\n                        c2 = 0x0000\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        ch = utf16_get_supplementary(c, c2)\n                    else\n                        ch = Char(c)\n                    end\n                    st = codeunits(Base.string(ch))\n                    for j = 1:length(st)-1\n                        @inbounds buf[len] = st[j]\n                        len += 1\n                    end\n                    b = st[end]\n                else\n                    b = reverseescapechar(b)\n                    b == 0x00 && invalid_escape(s)\n                end\n            end\n            @inbounds buf[len] = b\n            len += 1\n            i += 1\n        end\n    end\n    resize!(buf, len - 1)\n    return String(buf)\nend\n"}, "source_files_changed": ["src/strings.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 2, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "ce835bd54661c20900aebb8d6d09ac4544fe799e", "parent_sha": "cf39d0489234956f59cbb548750c50a29f239005", "commit_message": "add comment, rm unused function", "commit_date": "2019-07-23T11:19:47-04:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": "keyvalue", "signature": null, "confidence": 0.6}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@noinline _throw_100_field_error() = error(\"JSON3 does not yet support struct-based deserialization for structs with more than 100 fields\")\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        Base.@nif(\n            32,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT_i = fieldtype(T, i)\n                pos, y_i = read(StructType(FT_i), buf, pos, len, b, FT_i)\n                is_included && setfield!(x, i, y_i)\n            end,\n            i -> begin\n                is_field_still_unread = true\n                for j in 33:N\n                    fieldname(T, j) === key || continue\n                    FT_j = fieldtype(T, j)\n                    pos, y_j = read(StructType(FT_j), buf, pos, len, b, FT_j)\n                    is_included && setfield!(x, j, y_j)\n                    is_field_still_unread = false\n                    break\n                end\n                if is_field_still_unread\n                    pos, _ = read(Struct(), buf, pos, len, b, Any)\n                end\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        # unroll the first 32 field checks to avoid dynamic dispatch if possible\n        Base.@nif(\n            32,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT_i = fieldtype(T, i)\n                pos, y_i = read(StructType(FT_i), buf, pos, len, b, FT_i)\n                is_included && setfield!(x, i, y_i)\n            end,\n            i -> begin\n                is_field_still_unread = true\n                for j in 33:N\n                    fieldname(T, j) === key || continue\n                    FT_j = fieldtype(T, j)\n                    pos, y_j = read(StructType(FT_j), buf, pos, len, b, FT_j)\n                    is_included && setfield!(x, j, y_j)\n                    is_field_still_unread = false\n                    break\n                end\n                if is_field_still_unread\n                    pos, _ = read(Struct(), buf, pos, len, b, Any)\n                end\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 3, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "cf39d0489234956f59cbb548750c50a29f239005", "parent_sha": "e8402dd75f81638e1f7b40c1cf325a0684f828ac", "commit_message": "fix N > 32 bug without losing performance", "commit_date": "2019-07-23T11:16:28-04:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@noinline _throw_100_field_error() = error(\"JSON3 does not yet support struct-based deserialization for structs with more than 100 fields\")\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        Base.@nif(\n            32,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT = fieldtype(T, i)\n                pos, y_i = read(StructType(FT), buf, pos, len, b, FT)\n                is_included && setfield!(x, key, y_i)\n            end,\n            i -> begin\n                j = Base.fieldindex(T, key, false)\n                if j > 0\n                    pos, y_j = read(StructType(FT), buf, pos, len, b, FT)\n                    is_included && setfield!(x, key, y_j)\n                else\n                    pos, _ = read(Struct(), buf, pos, len, b, Any)\n                end\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@noinline _throw_100_field_error() = error(\"JSON3 does not yet support struct-based deserialization for structs with more than 100 fields\")\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        Base.@nif(\n            32,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT_i = fieldtype(T, i)\n                pos, y_i = read(StructType(FT_i), buf, pos, len, b, FT_i)\n                is_included && setfield!(x, i, y_i)\n            end,\n            i -> begin\n                is_field_still_unread = true\n                for j in 33:N\n                    fieldname(T, j) === key || continue\n                    FT_j = fieldtype(T, j)\n                    pos, y_j = read(StructType(FT_j), buf, pos, len, b, FT_j)\n                    is_included && setfield!(x, j, y_j)\n                    is_field_still_unread = false\n                    break\n                end\n                if is_field_still_unread\n                    pos, _ = read(Struct(), buf, pos, len, b, Any)\n                end\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 21, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "e8402dd75f81638e1f7b40c1cf325a0684f828ac", "parent_sha": "c276219c1367afdef88f885bc18abfee5508ee67", "commit_message": "remove fieldcount restriction", "commit_date": "2019-07-23T10:33:17-04:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@noinline _throw_100_field_error() = error(\"JSON3 does not yet support struct-based deserialization for structs with more than 100 fields\")\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    N > 100 && _throw_100_field_error()\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        Base.@nif(\n            100,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT = fieldtype(T, i)\n                pos, y = read(StructType(FT), buf, pos, len, b, FT)\n                is_included && setfield!(x, key, y)\n            end,\n            i -> begin\n                pos, _ = read(Struct(), buf, pos, len, b, Any)\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@noinline _throw_100_field_error() = error(\"JSON3 does not yet support struct-based deserialization for structs with more than 100 fields\")\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        Base.@nif(\n            32,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT = fieldtype(T, i)\n                pos, y_i = read(StructType(FT), buf, pos, len, b, FT)\n                is_included && setfield!(x, key, y_i)\n            end,\n            i -> begin\n                j = Base.fieldindex(T, key, false)\n                if j > 0\n                    pos, y_j = read(StructType(FT), buf, pos, len, b, FT)\n                    is_included && setfield!(x, key, y_j)\n                else\n                    pos, _ = read(Struct(), buf, pos, len, b, Any)\n                end\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 15, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "c276219c1367afdef88f885bc18abfee5508ee67", "parent_sha": "a5d07c3fdbcc293960ffaa983183b7e476c21ecb", "commit_message": "slight speed up via nif macro", "commit_date": "2019-07-23T10:23:26-04:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@noinline _throw_100_field_error() = error(\"JSON3 does not yet support struct-based deserialization for structs with more than 100 fields\")\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    N > 100 && _throw_100_field_error()\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        is_field_still_unread = true\n        Base.@nexprs 100 i -> begin\n            if i <= N && fieldname(T, i) === key\n                FT = fieldtype(T, i)\n                pos, y = read(StructType(FT), buf, pos, len, b, FT)\n                is_included && setfield!(x, key, y)\n                is_field_still_unread = false\n            end\n        end\n        if is_field_still_unread\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@noinline _throw_100_field_error() = error(\"JSON3 does not yet support struct-based deserialization for structs with more than 100 fields\")\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    N > 100 && _throw_100_field_error()\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        Base.@nif(\n            100,\n            i -> (i <= N && fieldname(T, i) === key),\n            i -> begin\n                FT = fieldtype(T, i)\n                pos, y = read(StructType(FT), buf, pos, len, b, FT)\n                is_included && setfield!(x, key, y)\n            end,\n            i -> begin\n                pos, _ = read(Struct(), buf, pos, len, b, Any)\n            end\n        )\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 17, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "a5d07c3fdbcc293960ffaa983183b7e476c21ecb", "parent_sha": "c01f8ccc5786b0f62f8c9a26c6906678e71bd12c", "commit_message": "bump manual generation to 100 field and disable deserialization beyond that", "commit_date": "2019-07-23T10:00:56-04:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": "keyvalue", "signature": null, "confidence": 0.6}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            is_included = !symbolin(excl, key)\n            Base.@nexprs 32 i -> begin\n                if i <= N && fieldname(T, i) === key\n                    FT = fieldtype(T, i)\n                    pos, y = read(StructType(FT), buf, pos, len, b, FT)\n                    is_included && setfield!(x, key, y)\n                end\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@noinline _throw_100_field_error() = error(\"JSON3 does not yet support struct-based deserialization for structs with more than 100 fields\")\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    N > 100 && _throw_100_field_error()\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        is_included = !symbolin(excl, key)\n        is_field_still_unread = true\n        Base.@nexprs 100 i -> begin\n            if i <= N && fieldname(T, i) === key\n                FT = fieldtype(T, i)\n                pos, y = read(StructType(FT), buf, pos, len, b, FT)\n                is_included && setfield!(x, key, y)\n                is_field_still_unread = false\n            end\n        end\n        if is_field_still_unread\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 24, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "c01f8ccc5786b0f62f8c9a26c6906678e71bd12c", "parent_sha": "07d657e2f0822f72a89956e42217f4c16e398ef3", "commit_message": "avoid try-catch block for common Union{T,Missing} fields", "commit_date": "2019-07-22T16:53:16-04:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            is_included = !symbolin(excl, key)\n            Base.@nexprs 32 i -> begin\n                if i <= N && fieldname(T, i) === key\n                    FT = fieldtype(T, i)\n                    pos, y = read(StructType(FT), buf, pos, len, b, FT)\n                    is_included && setfield!(x, key, y)\n                end\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    # Julia implementation detail: Unions are sorted :)\n    # This lets us avoid the below try-catch when U <: Union{Missing,T}\n    if U.a === Nothing || U.a === Missing\n        if buf[pos] == UInt8('n')\n            return read(StructType(U.a), buf, pos, len, b, U.a)\n        else\n            return read(StructType(U.b), buf, pos, len, b, U.b)\n        end\n    end\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            is_included = !symbolin(excl, key)\n            Base.@nexprs 32 i -> begin\n                if i <= N && fieldname(T, i) === key\n                    FT = fieldtype(T, i)\n                    pos, y = read(StructType(FT), buf, pos, len, b, FT)\n                    is_included && setfield!(x, key, y)\n                end\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 9, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "07d657e2f0822f72a89956e42217f4c16e398ef3", "parent_sha": "1e40a6272e23858d085c7028a71b2808f5b976a4", "commit_message": "reduce dynamic dispatches in structured parsing", "commit_date": "2019-07-22T16:34:20-04:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": "excludes", "signature": null, "confidence": 0.6}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written. \n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written. \n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written.\n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols\nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    N = fieldcount(T)\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            is_included = !symbolin(excl, key)\n            Base.@nexprs 32 i -> begin\n                if i <= N && fieldname(T, i) === key\n                    FT = fieldtype(T, i)\n                    pos, y = read(StructType(FT), buf, pos, len, b, FT)\n                    is_included && setfield!(x, key, y)\n                end\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 18, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "1e40a6272e23858d085c7028a71b2808f5b976a4", "parent_sha": "f5cf3bb77f1b9578af3758affdc9fb2a33845f69", "commit_message": "Add custom copy methods for object and array that recursively (materialize) elements", "commit_date": "2019-07-22T07:29:33-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/JSON3.jl", "target_symbol": "Base.copy", "signature": null, "confidence": 0.85}, "files_before": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(2), 0])\n\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\nend\n\nArray{T}(buf::S, tape::TT) where {T, S, TT} = Array{T, S, TT}(buf, tape)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, key, default)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol, default::T)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n"}, "files_after": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(2), 0])\n\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\nend\n\nArray{T}(buf::S, tape::TT) where {T, S, TT} = Array{T, S, TT}(buf, tape)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, key, default)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol, default::T)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\nfunction Base.copy(obj::Object)\n    dict = Dict{Symbol, Any}()\n    for (k, v) in obj\n        dict[k] = copy(v)\n    end\n    return dict\nend\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\nBase.copy(arr::Array) = map(copy, arr)\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n"}, "source_files_changed": ["src/JSON3.jl"], "test_files_changed": [], "lines_changed": 10, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "1e4cd648a6fe3bd4e3cac037773b57ff5b04db42", "parent_sha": "6bc1230d451f5322e96759b13fa0996ffc3d876c", "commit_message": "Remove custom show for array", "commit_date": "2019-07-22T06:32:37-06:00", "action": {"type": "REMOVE_METHOD", "target_file": "src/show.jl", "target_symbol": "Base.show", "signature": null, "confidence": 0.85}, "files_before": {"src/show.jl": "Base.show(io::IO, j::Object) = _show(io, j)\nBase.show(io::IO, j::Array) = _show(io, j)\n_show(io::IO, x, indent=0, offset=0) = show(io, x)\n\nfunction _show(io::IO, obj::Object, indent=0, offset=0)\n    if isempty(obj)\n        print(io, \"{}\")\n        return\n    end\n    println(io, \"{\")\n    indent += 1\n    keyvals = collect(obj)\n    keys = map(x->x[1], keyvals)\n    vals = map(x->x[2], keyvals)\n    maxlen = maximum(map(sizeof, keys)) + 5\n    # @show maxlen\n    for i = 1:length(keys)\n        Base.write(io, \"  \"^indent)\n        Base.write(io, lpad(\"\\\"$(keys[i])\\\"\" * \": \", maxlen + offset, ' '))\n        _show(io, vals[i], indent, maxlen + offset)\n        if i == length(keys)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"}\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n\nfunction _show(io::IO, arr::Array, indent=0, offset=0)\n    if isempty(arr)\n        print(io, \"[]\")\n        return\n    end\n    println(io, \"[\")\n    indent += 1\n    vals = collect(arr)\n    for (i, val) in enumerate(vals)\n        Base.write(io, \"  \"^indent * \" \"^offset)\n        _show(io, vals[i], indent, offset)\n        if i == length(vals)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"]\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n"}, "files_after": {"src/show.jl": "Base.show(io::IO, j::Object) = _show(io, j)\n_show(io::IO, x, indent=0, offset=0) = show(io, x)\n\nfunction _show(io::IO, obj::Object, indent=0, offset=0)\n    if isempty(obj)\n        print(io, \"{}\")\n        return\n    end\n    println(io, \"{\")\n    indent += 1\n    keyvals = collect(obj)\n    keys = map(x->x[1], keyvals)\n    vals = map(x->x[2], keyvals)\n    maxlen = maximum(map(sizeof, keys)) + 5\n    # @show maxlen\n    for i = 1:length(keys)\n        Base.write(io, \"  \"^indent)\n        Base.write(io, lpad(\"\\\"$(keys[i])\\\"\" * \": \", maxlen + offset, ' '))\n        _show(io, vals[i], indent, maxlen + offset)\n        if i == length(keys)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"}\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n\nfunction _show(io::IO, arr::Array, indent=0, offset=0)\n    if isempty(arr)\n        print(io, \"[]\")\n        return\n    end\n    println(io, \"[\")\n    indent += 1\n    vals = collect(arr)\n    for (i, val) in enumerate(vals)\n        Base.write(io, \"  \"^indent * \" \"^offset)\n        _show(io, vals[i], indent, offset)\n        if i == length(vals)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"]\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n"}, "source_files_changed": ["src/show.jl"], "test_files_changed": [], "lines_changed": 1, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "bb24e87fb887070f2f6e7b01ad6580a0fdb11c86", "parent_sha": "1f846fcd4088b6f34392a5ac12729bd467fe12a7", "commit_message": "Further improvements to array promotion", "commit_date": "2019-07-09T23:32:11-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/utils.jl", "target_symbol": "promoteeltype", "signature": null, "confidence": 0.6}, "files_before": {"src/utils.jl": "_symbol(ptr, len) = ccall(:jl_symbol_n, Ref{Symbol}, (Ptr{UInt8}, Int), ptr, len)\n\nfunction getbyte(buf, pos)\n    unsafe_load(pointer(buf.s), pos)\nend\n\nmacro eof()\n    esc(quote\n        if pos > len\n            error = UnexpectedEOF\n            @goto invalid\n        end\n    end)\nend\n\nmacro wh()\n    esc(quote\n        while b == UInt8('\\t') || b == UInt8(' ') || b == UInt8('\\n') || b == UInt8('\\r')\n            pos += 1\n            if pos > len\n                error = UnexpectedEOF\n                @goto invalid\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nconst EMPTY   = UInt64(0b00000000) << 56\nconst OBJECT  = UInt64(0b00000001) << 56\nconst ARRAY   = UInt64(0b00000010) << 56\nconst STRING  = UInt64(0b00000100) << 56\nconst INT     = UInt64(0b00001000) << 56\nconst FLOAT   = UInt64(0b00010000) << 56\nconst BOOL    = UInt64(0b00100000) << 56\nconst NULL    = UInt64(0b01000000) << 56\nconst ANY     = UInt64(0b10000000) << 56\n\nconst TYPEMASK = 0xff00000000000000\n\nempty(x::UInt64) = (x & TYPEMASK) == EMPTY\nisany(x::UInt64) = (x & TYPEMASK) == ANY\nisobject(x::UInt64) = (x & TYPEMASK) == OBJECT\nisarray(x::UInt64) = (x & TYPEMASK) == ARRAY\nisstring(x::UInt64) = (x & TYPEMASK) == STRING\nisint(x::UInt64) = (x & TYPEMASK) == INT\nisfloat(x::UInt64) = (x & TYPEMASK) == FLOAT\nisbool(x::UInt64) = (x & TYPEMASK) == BOOL\nisnull(x::UInt64) = (x & TYPEMASK) == NULL\nisintfloat(x::UInt64) = (x & TYPEMASK) == (INT | FLOAT)\nnonnull(x::UInt64) = (x & TYPEMASK) & ~NULL\n\nfunction geteltype(T)\n    if empty(T); return Union{}\n    elseif isany(T); return Any\n    elseif isobject(T); return Object\n    elseif isarray(T); return Array\n    elseif isstring(T); return String\n    elseif isint(T); return Int64\n    elseif isfloat(T); return Float64\n    elseif isbool(T); return Bool\n    elseif isnull(T); return Nothing\n    elseif isintfloat(T); return Union{Int64, Float64}\n    else return Union{geteltype(nonnull(T)), Nothing}\n    end\nend\n\nobject(tapelen) = OBJECT | Core.bitcast(UInt64, tapelen)\narray(tapelen)  = ARRAY  | Core.bitcast(UInt64, tapelen)\neltypelen(T, len) = T | Core.bitcast(UInt64, len)\nstring(len) = STRING | Core.bitcast(UInt64, len)\nconst ESCAPE_BIT = UInt64(1) << 63\n\nfunction promoteeltype(A, B)\n    if A == B\n        return A\n    elseif A == EMPTY\n        return B\n    elseif (A | B) == A\n        return A\n    elseif A == INT && B == FLOAT\n        return A | B\n    elseif A == FLOAT && B == INT\n        return A | B\n    elseif A == NULL || B == NULL\n        return A | B\n    else\n        return ANY\n    end\nend\n\ngettypemask(x::UInt64) = x & TYPEMASK\ngetnontypemask(x::UInt64) = Core.bitcast(Int64, x & ~TYPEMASK)\ngetpos(x::UInt64) = Core.bitcast(Int64, getnontypemask(x) >> 16)\ngetlen(x::UInt64) = Core.bitcast(Int64, x & 0x000000000000ffff)\n\ngettapelen(T, x::UInt64) = ifelse(isobject(x) | isarray(x), getnontypemask(x), 2)\ngettapelen(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = 2\n\nregularstride(T) = false\nregularstride(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = true\nregularstride(::Type{Union{Int64, Float64}}) = true\n\ngetvalue(::Type{Object}, buf, tape, tapeidx, t) = Object(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)))\ngetvalue(::Type{Array}, buf, tape, tapeidx, t) = Array{geteltype(tape[tapeidx+1])}(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)))\n\nfunction getvalue(::Type{Symbol}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return Symbol(unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t))))\n    else\n        return _symbol(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{String}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t)))\n    else\n        return unsafe_string(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{Int64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Int64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Float64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Float64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Union{Int64, Float64}}, buf, tape, tapeidx, t)\n    @inbounds x = tape[tapeidx+1]\n    return Core.bitcast(ifelse(isint(t), Int64, Float64), x)\nend\ngetvalue(::Type{Bool}, buf, tape, tapeidx, t) = getnontypemask(t) == UInt64(1)\ngetvalue(::Type{Nothing}, buf, tape, tapeidx, t) = nothing\n@inline function getvalue(T, buf, tape, tapeidx, t)\n    if isobject(t)\n        return getvalue(Object, buf, tape, tapeidx, t)\n    elseif isarray(t)\n        return getvalue(Array, buf, tape, tapeidx, t)\n    elseif isstring(t)\n        return getvalue(String, buf, tape, tapeidx, t)\n    elseif isint(t)\n        return getvalue(Int64, buf, tape, tapeidx, t)\n    elseif isfloat(t)\n        return getvalue(Float64, buf, tape, tapeidx, t)\n    elseif isbool(t)\n        return getvalue(Bool, buf, tape, tapeidx, t)\n    elseif isnull(t)\n        return nothing\n    end\nend\n\nBase.@pure function symbolin(names::Tuple{Vararg{Symbol}}, name::Symbol)\n    for nm in names\n        nm === name && return true\n    end\n    return false\nend\n"}, "files_after": {"src/utils.jl": "_symbol(ptr, len) = ccall(:jl_symbol_n, Ref{Symbol}, (Ptr{UInt8}, Int), ptr, len)\n\nfunction getbyte(buf, pos)\n    unsafe_load(pointer(buf.s), pos)\nend\n\nmacro eof()\n    esc(quote\n        if pos > len\n            error = UnexpectedEOF\n            @goto invalid\n        end\n    end)\nend\n\nmacro wh()\n    esc(quote\n        while b == UInt8('\\t') || b == UInt8(' ') || b == UInt8('\\n') || b == UInt8('\\r')\n            pos += 1\n            if pos > len\n                error = UnexpectedEOF\n                @goto invalid\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nconst EMPTY   = UInt64(0b00000000) << 56\nconst OBJECT  = UInt64(0b00000001) << 56\nconst ARRAY   = UInt64(0b00000010) << 56\nconst STRING  = UInt64(0b00000100) << 56\nconst INT     = UInt64(0b00001000) << 56\nconst FLOAT   = UInt64(0b00010000) << 56\nconst BOOL    = UInt64(0b00100000) << 56\nconst NULL    = UInt64(0b01000000) << 56\nconst ANY     = UInt64(0b10000000) << 56\n\nconst TYPEMASK = 0xff00000000000000\n\nempty(x::UInt64) = (x & TYPEMASK) == EMPTY\nisany(x::UInt64) = (x & TYPEMASK) == ANY\nisobject(x::UInt64) = (x & TYPEMASK) == OBJECT\nisarray(x::UInt64) = (x & TYPEMASK) == ARRAY\nisstring(x::UInt64) = (x & TYPEMASK) == STRING\nisint(x::UInt64) = (x & TYPEMASK) == INT\nisfloat(x::UInt64) = (x & TYPEMASK) == FLOAT\nisbool(x::UInt64) = (x & TYPEMASK) == BOOL\nisnull(x::UInt64) = (x & TYPEMASK) == NULL\nisintfloat(x::UInt64) = (x & TYPEMASK) == (INT | FLOAT)\nnonnull(x::UInt64) = (x & TYPEMASK) & ~NULL\n\nfunction geteltype(T)\n    if empty(T); return Union{}\n    elseif isany(T); return Any\n    elseif isobject(T); return Object\n    elseif isarray(T); return Array\n    elseif isstring(T); return String\n    elseif isint(T); return Int64\n    elseif isfloat(T); return Float64\n    elseif isbool(T); return Bool\n    elseif isnull(T); return Nothing\n    elseif isintfloat(T); return Union{Int64, Float64}\n    else return Union{geteltype(nonnull(T)), Nothing}\n    end\nend\n\nobject(tapelen) = OBJECT | Core.bitcast(UInt64, tapelen)\narray(tapelen)  = ARRAY  | Core.bitcast(UInt64, tapelen)\neltypelen(T, len) = T | Core.bitcast(UInt64, len)\nstring(len) = STRING | Core.bitcast(UInt64, len)\nconst ESCAPE_BIT = UInt64(1) << 63\n\nfunction promoteeltype(A, B)\n    if A == B\n        return A\n    elseif A == EMPTY\n        return B\n    elseif (A | B) == A\n        return A\n    elseif A == INT && B == FLOAT\n        return A | B\n    elseif A == FLOAT && B == INT\n        return A | B\n    elseif A == (INT | NULL) && B == FLOAT\n        return A | B\n    elseif A == (FLOAT | NULL) && B == INT\n        return A | B\n    elseif A == NULL || B == NULL\n        return A | B\n    else\n        return ANY\n    end\nend\n\ngettypemask(x::UInt64) = x & TYPEMASK\ngetnontypemask(x::UInt64) = Core.bitcast(Int64, x & ~TYPEMASK)\ngetpos(x::UInt64) = Core.bitcast(Int64, getnontypemask(x) >> 16)\ngetlen(x::UInt64) = Core.bitcast(Int64, x & 0x000000000000ffff)\n\ngettapelen(T, x::UInt64) = ifelse(isobject(x) | isarray(x), getnontypemask(x), 2)\ngettapelen(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = 2\n\nregularstride(T) = false\nregularstride(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = true\nregularstride(::Type{Union{Int64, Float64}}) = true\n\ngetvalue(::Type{Object}, buf, tape, tapeidx, t) = Object(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)))\ngetvalue(::Type{Array}, buf, tape, tapeidx, t) = Array{geteltype(tape[tapeidx+1])}(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)))\n\nfunction getvalue(::Type{Symbol}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return Symbol(unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t))))\n    else\n        return _symbol(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{String}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t)))\n    else\n        return unsafe_string(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{Int64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Int64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Float64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Float64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Union{Int64, Float64}}, buf, tape, tapeidx, t)\n    @inbounds x = tape[tapeidx+1]\n    return Core.bitcast(ifelse(isint(t), Int64, Float64), x)\nend\ngetvalue(::Type{Bool}, buf, tape, tapeidx, t) = getnontypemask(t) == UInt64(1)\ngetvalue(::Type{Nothing}, buf, tape, tapeidx, t) = nothing\n@inline function getvalue(T, buf, tape, tapeidx, t)\n    if isobject(t)\n        return getvalue(Object, buf, tape, tapeidx, t)\n    elseif isarray(t)\n        return getvalue(Array, buf, tape, tapeidx, t)\n    elseif isstring(t)\n        return getvalue(String, buf, tape, tapeidx, t)\n    elseif isint(t)\n        return getvalue(Int64, buf, tape, tapeidx, t)\n    elseif isfloat(t)\n        return getvalue(Float64, buf, tape, tapeidx, t)\n    elseif isbool(t)\n        return getvalue(Bool, buf, tape, tapeidx, t)\n    elseif isnull(t)\n        return nothing\n    end\nend\n\nBase.@pure function symbolin(names::Tuple{Vararg{Symbol}}, name::Symbol)\n    for nm in names\n        nm === name && return true\n    end\n    return false\nend\n"}, "source_files_changed": ["src/utils.jl"], "test_files_changed": [], "lines_changed": 4, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "7834eb7ddaa128100ff737d65c6ccd0e07ec2d5b", "parent_sha": "ed19441683e9d55f475402f12d8aefa524c0b23b", "commit_message": "Further improvements to Array eltype parsing", "commit_date": "2019-07-01T20:57:55-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/read.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/read.jl": "struct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.ncodeunits(s::VectorString) = length(s.bytes)\nBase.codeunit(s::VectorString) = UInt8\nBase.length(s::VectorString) = ncodeunits(s)\nfunction Base.codeunit(s::VectorString, i::Int)\n    @inbounds b = s.bytes[i]\n    return b\nend\nBase.pointer(v::VectorString) = pointer(v.bytes)\nBase.pointer(v::VectorString, i::Integer) = pointer(v.bytes, i)\nBase.unsafe_convert(::Type{Ptr{UInt8}}, v::VectorString) = pointer(v)\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = 0\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = 0\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "files_after": {"src/read.jl": "struct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.ncodeunits(s::VectorString) = length(s.bytes)\nBase.codeunit(s::VectorString) = UInt8\nBase.length(s::VectorString) = ncodeunits(s)\nfunction Base.codeunit(s::VectorString, i::Int)\n    @inbounds b = s.bytes[i]\n    return b\nend\nBase.pointer(v::VectorString) = pointer(v.bytes)\nBase.pointer(v::VectorString, i::Integer) = pointer(v.bytes, i)\nBase.unsafe_convert(::Type{Ptr{UInt8}}, v::VectorString) = pointer(v)\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = 0\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = 0\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT && eT != (FLOAT | NULL))\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n"}, "source_files_changed": ["src/read.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 4, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "6f4fd99f890d3d70ef4f4af982db3652c7d0063a", "parent_sha": "e7e1ed32b4a6e124b9c124bb038362f95d267e49", "commit_message": "Better fix", "commit_date": "2019-07-01T15:35:00-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/JSON3.jl", "target_symbol": "Base.get", "signature": null, "confidence": 0.75}, "files_before": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(2), 0])\n\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\nend\n\nArray{T}(buf::S, tape::TT) where {T, S, TT} = Array{T, S, TT}(buf, tape)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key)\n    k2 = Symbol(key)\n    for (k, v) in obj\n        k == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key, default)\n    k2 = Symbol(key)\n    for (k, v) in obj\n        k == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    k2 = Symbol(key)\n    for (k, v) in obj\n        k == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    k2 = Symbol(key)\n    for (k, v) in obj\n        k == k2 && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n"}, "files_after": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(2), 0])\n\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\nend\n\nArray{T}(buf::S, tape::TT) where {T, S, TT} = Array{T, S, TT}(buf, tape)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key::Symbol, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, key, default)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key::Symbol, default::T)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key::Symbol)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    k2 = Base.string(key)\n    for (k, v) in obj\n        String(k) == k2 && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n"}, "source_files_changed": ["src/JSON3.jl"], "test_files_changed": [], "lines_changed": 54, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "e7e1ed32b4a6e124b9c124bb038362f95d267e49", "parent_sha": "3841adfb3315a2c3ee1214bc27946fb06526477d", "commit_message": "Fix issue with get on objects when key was provided as String instead of Symbol", "commit_date": "2019-07-01T15:29:24-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/JSON3.jl", "target_symbol": "Base.get", "signature": null, "confidence": 0.6}, "files_before": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(2), 0])\n\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\nend\n\nArray{T}(buf::S, tape::TT) where {T, S, TT} = Array{T, S, TT}(buf, tape)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n"}, "files_after": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(2), 0])\n\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\nend\n\nArray{T}(buf::S, tape::TT) where {T, S, TT} = Array{T, S, TT}(buf, tape)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key)\n    k2 = Symbol(key)\n    for (k, v) in obj\n        k == k2 && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key, default)\n    k2 = Symbol(key)\n    for (k, v) in obj\n        k == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    k2 = Symbol(key)\n    for (k, v) in obj\n        k == k2 && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    k2 = Symbol(key)\n    for (k, v) in obj\n        k == k2 && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n"}, "source_files_changed": ["src/JSON3.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 16, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "115d72febb9fe720fa5840e5848d8ebc0781c7e9", "parent_sha": "aab870f0500a9d387dc16d3d0c4a0a3c290722f1", "commit_message": "Fix #9 by making sure dict construction uses the generic StringType construction machinery. This means that basically any type can be the key type of a Dict as long as it (implicitly) satisfies the StringType interface", "commit_date": "2019-06-30T23:38:11-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": "keyvalue", "signature": null, "confidence": 0.75}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written. \n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written. \n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{String}, escaped, ptr, len) = escaped ? unescape(PointerString(ptr, len)) : unsafe_string(ptr, len)\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[K(key)] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written. \n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written. \n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{T}, escaped, ptr, len) where {T} = escaped ? construct(T, unescape(PointerString(ptr, len))) : construct(T, unsafe_string(ptr, len))\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[key] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 13, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "ac9d6f9fe493b23c4204ba5cf4e80727dc0a8208", "parent_sha": "5aa0daf8f2dc9580e840d04e06e658330a6cffba", "commit_message": "Fix array eltype promotions w/ Int/Float", "commit_date": "2019-06-30T20:07:26-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/read.jl", "target_symbol": "read", "signature": null, "confidence": 0.6}, "files_before": {"src/read.jl": "struct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.ncodeunits(s::VectorString) = length(s.bytes)\nBase.codeunit(s::VectorString) = UInt8\nBase.length(s::VectorString) = ncodeunits(s)\nfunction Base.codeunit(s::VectorString, i::Int)\n    @inbounds b = s.bytes[i]\n    return b\nend\nBase.pointer(v::VectorString) = pointer(v.bytes)\nBase.pointer(v::VectorString, i::Integer) = pointer(v.bytes, i)\nBase.unsafe_convert(::Type{Ptr{UInt8}}, v::VectorString) = pointer(v)\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any})\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                @inbounds tape[tapeidx] = INT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = 0\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = 0\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n", "src/utils.jl": "_symbol(ptr, len) = ccall(:jl_symbol_n, Ref{Symbol}, (Ptr{UInt8}, Int), ptr, len)\n\nfunction getbyte(buf, pos)\n    unsafe_load(pointer(buf.s), pos)\nend\n\nmacro eof()\n    esc(quote\n        if pos > len\n            error = UnexpectedEOF\n            @goto invalid\n        end\n    end)\nend\n\nmacro wh()\n    esc(quote\n        while b == UInt8('\\t') || b == UInt8(' ') || b == UInt8('\\n') || b == UInt8('\\r')\n            pos += 1\n            if pos > len\n                error = UnexpectedEOF\n                @goto invalid\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nconst EMPTY   = UInt64(0b00000000) << 56\nconst OBJECT  = UInt64(0b00000001) << 56\nconst ARRAY   = UInt64(0b00000010) << 56\nconst STRING  = UInt64(0b00000100) << 56\nconst INT     = UInt64(0b00001000) << 56\nconst FLOAT   = UInt64(0b00010000) << 56\nconst BOOL    = UInt64(0b00100000) << 56\nconst NULL    = UInt64(0b01000000) << 56\nconst ANY     = UInt64(0b10000000) << 56\n\nconst TYPEMASK = 0xff00000000000000\n\nempty(x::UInt64) = (x & TYPEMASK) == EMPTY\nisany(x::UInt64) = (x & TYPEMASK) == ANY\nisobject(x::UInt64) = (x & TYPEMASK) == OBJECT\nisarray(x::UInt64) = (x & TYPEMASK) == ARRAY\nisstring(x::UInt64) = (x & TYPEMASK) == STRING\nisint(x::UInt64) = (x & TYPEMASK) == INT\nisfloat(x::UInt64) = (x & TYPEMASK) == FLOAT\nisbool(x::UInt64) = (x & TYPEMASK) == BOOL\nisnull(x::UInt64) = (x & TYPEMASK) == NULL\nisintfloat(x::UInt64) = (x & TYPEMASK) == (INT | FLOAT)\nnonnull(x::UInt64) = (x & TYPEMASK) & ~NULL\n\nfunction geteltype(T)\n    if empty(T); return Union{}\n    elseif isany(T); return Any\n    elseif isobject(T); return Object\n    elseif isarray(T); return Array\n    elseif isstring(T); return String\n    elseif isint(T); return Int64\n    elseif isfloat(T); return Float64\n    elseif isbool(T); return Bool\n    elseif isnull(T); return Nothing\n    elseif isintfloat(T); return Union{Int64, Float64}\n    else return Union{geteltype(nonnull(T)), Nothing}\n    end\nend\n\nobject(tapelen) = OBJECT | Core.bitcast(UInt64, tapelen)\narray(tapelen)  = ARRAY  | Core.bitcast(UInt64, tapelen)\neltypelen(T, len) = T | Core.bitcast(UInt64, len)\nstring(len) = STRING | Core.bitcast(UInt64, len)\nconst ESCAPE_BIT = UInt64(1) << 63\n\nfunction promoteeltype(A, B)\n    if A == B\n        return A\n    elseif A == EMPTY\n        return B\n    elseif A == INT && B == FLOAT\n        return A | B\n    elseif A == FLOAT && B == INT\n        return A | B\n    elseif A == NULL || B == NULL\n        return A | B\n    else\n        return ANY\n    end\nend\n\ngettypemask(x::UInt64) = x & TYPEMASK\ngetnontypemask(x::UInt64) = Core.bitcast(Int64, x & ~TYPEMASK)\ngetpos(x::UInt64) = Core.bitcast(Int64, getnontypemask(x) >> 16)\ngetlen(x::UInt64) = Core.bitcast(Int64, x & 0x000000000000ffff)\n\ngettapelen(T, x::UInt64) = ifelse(isobject(x) | isarray(x), getnontypemask(x), 2)\ngettapelen(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = 2\n\nregularstride(T) = false\nregularstride(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = true\nregularstride(::Type{Union{Int64, Float64}}) = true\n\ngetvalue(::Type{Object}, buf, tape, tapeidx, t) = Object(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)))\ngetvalue(::Type{Array}, buf, tape, tapeidx, t) = Array{geteltype(tape[tapeidx+1])}(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)))\n\nfunction getvalue(::Type{Symbol}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return Symbol(unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t))))\n    else\n        return _symbol(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{String}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t)))\n    else\n        return unsafe_string(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{Int64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Int64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Float64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Float64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Union{Int64, Float64}}, buf, tape, tapeidx, t)\n    @inbounds x = tape[tapeidx+1]\n    return Core.bitcast(ifelse(isint(t), Int64, Float64), x)\nend\ngetvalue(::Type{Bool}, buf, tape, tapeidx, t) = getnontypemask(t) == UInt64(1)\ngetvalue(::Type{Nothing}, buf, tape, tapeidx, t) = nothing\n@inline function getvalue(T, buf, tape, tapeidx, t)\n    if isobject(t)\n        return getvalue(Object, buf, tape, tapeidx, t)\n    elseif isarray(t)\n        return getvalue(Array, buf, tape, tapeidx, t)\n    elseif isstring(t)\n        return getvalue(String, buf, tape, tapeidx, t)\n    elseif isint(t)\n        return getvalue(Int64, buf, tape, tapeidx, t)\n    elseif isfloat(t)\n        return getvalue(Float64, buf, tape, tapeidx, t)\n    elseif isbool(t)\n        return getvalue(Bool, buf, tape, tapeidx, t)\n    elseif isnull(t)\n        return nothing\n    end\nend\n\nBase.@pure function symbolin(names::Tuple{Vararg{Symbol}}, name::Symbol)\n    for nm in names\n        nm === name && return true\n    end\n    return false\nend"}, "files_after": {"src/read.jl": "struct VectorString{T <: AbstractVector{UInt8}} <: AbstractString\n    bytes::T\nend\n\nBase.ncodeunits(s::VectorString) = length(s.bytes)\nBase.codeunit(s::VectorString) = UInt8\nBase.length(s::VectorString) = ncodeunits(s)\nfunction Base.codeunit(s::VectorString, i::Int)\n    @inbounds b = s.bytes[i]\n    return b\nend\nBase.pointer(v::VectorString) = pointer(v.bytes)\nBase.pointer(v::VectorString, i::Integer) = pointer(v.bytes, i)\nBase.unsafe_convert(::Type{Ptr{UInt8}}, v::VectorString) = pointer(v)\n\n# high-level user API functions\nread(io::IO) = read(Base.read(io, String))\nread(bytes::AbstractVector{UInt8}) = read(VectorString(bytes))\n\nfunction read(str::AbstractString)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any}, checkint=true)\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            if checkint\n                int = unsafe_trunc(Int64, float)\n                if int == float\n                    @inbounds tape[tapeidx] = INT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n                else\n                    @inbounds tape[tapeidx] = FLOAT\n                    @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n                end\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        elseif b < UInt8(' ')\n            unescaped_control(b)\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = 0\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = 0\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any, eT != FLOAT)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n", "src/utils.jl": "_symbol(ptr, len) = ccall(:jl_symbol_n, Ref{Symbol}, (Ptr{UInt8}, Int), ptr, len)\n\nfunction getbyte(buf, pos)\n    unsafe_load(pointer(buf.s), pos)\nend\n\nmacro eof()\n    esc(quote\n        if pos > len\n            error = UnexpectedEOF\n            @goto invalid\n        end\n    end)\nend\n\nmacro wh()\n    esc(quote\n        while b == UInt8('\\t') || b == UInt8(' ') || b == UInt8('\\n') || b == UInt8('\\r')\n            pos += 1\n            if pos > len\n                error = UnexpectedEOF\n                @goto invalid\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nconst EMPTY   = UInt64(0b00000000) << 56\nconst OBJECT  = UInt64(0b00000001) << 56\nconst ARRAY   = UInt64(0b00000010) << 56\nconst STRING  = UInt64(0b00000100) << 56\nconst INT     = UInt64(0b00001000) << 56\nconst FLOAT   = UInt64(0b00010000) << 56\nconst BOOL    = UInt64(0b00100000) << 56\nconst NULL    = UInt64(0b01000000) << 56\nconst ANY     = UInt64(0b10000000) << 56\n\nconst TYPEMASK = 0xff00000000000000\n\nempty(x::UInt64) = (x & TYPEMASK) == EMPTY\nisany(x::UInt64) = (x & TYPEMASK) == ANY\nisobject(x::UInt64) = (x & TYPEMASK) == OBJECT\nisarray(x::UInt64) = (x & TYPEMASK) == ARRAY\nisstring(x::UInt64) = (x & TYPEMASK) == STRING\nisint(x::UInt64) = (x & TYPEMASK) == INT\nisfloat(x::UInt64) = (x & TYPEMASK) == FLOAT\nisbool(x::UInt64) = (x & TYPEMASK) == BOOL\nisnull(x::UInt64) = (x & TYPEMASK) == NULL\nisintfloat(x::UInt64) = (x & TYPEMASK) == (INT | FLOAT)\nnonnull(x::UInt64) = (x & TYPEMASK) & ~NULL\n\nfunction geteltype(T)\n    if empty(T); return Union{}\n    elseif isany(T); return Any\n    elseif isobject(T); return Object\n    elseif isarray(T); return Array\n    elseif isstring(T); return String\n    elseif isint(T); return Int64\n    elseif isfloat(T); return Float64\n    elseif isbool(T); return Bool\n    elseif isnull(T); return Nothing\n    elseif isintfloat(T); return Union{Int64, Float64}\n    else return Union{geteltype(nonnull(T)), Nothing}\n    end\nend\n\nobject(tapelen) = OBJECT | Core.bitcast(UInt64, tapelen)\narray(tapelen)  = ARRAY  | Core.bitcast(UInt64, tapelen)\neltypelen(T, len) = T | Core.bitcast(UInt64, len)\nstring(len) = STRING | Core.bitcast(UInt64, len)\nconst ESCAPE_BIT = UInt64(1) << 63\n\nfunction promoteeltype(A, B)\n    if A == B\n        return A\n    elseif A == EMPTY\n        return B\n    elseif (A | B) == A\n        return A\n    elseif A == INT && B == FLOAT\n        return A | B\n    elseif A == FLOAT && B == INT\n        return A | B\n    elseif A == NULL || B == NULL\n        return A | B\n    else\n        return ANY\n    end\nend\n\ngettypemask(x::UInt64) = x & TYPEMASK\ngetnontypemask(x::UInt64) = Core.bitcast(Int64, x & ~TYPEMASK)\ngetpos(x::UInt64) = Core.bitcast(Int64, getnontypemask(x) >> 16)\ngetlen(x::UInt64) = Core.bitcast(Int64, x & 0x000000000000ffff)\n\ngettapelen(T, x::UInt64) = ifelse(isobject(x) | isarray(x), getnontypemask(x), 2)\ngettapelen(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = 2\n\nregularstride(T) = false\nregularstride(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = true\nregularstride(::Type{Union{Int64, Float64}}) = true\n\ngetvalue(::Type{Object}, buf, tape, tapeidx, t) = Object(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)))\ngetvalue(::Type{Array}, buf, tape, tapeidx, t) = Array{geteltype(tape[tapeidx+1])}(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)))\n\nfunction getvalue(::Type{Symbol}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return Symbol(unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t))))\n    else\n        return _symbol(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{String}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t)))\n    else\n        return unsafe_string(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{Int64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Int64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Float64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Float64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Union{Int64, Float64}}, buf, tape, tapeidx, t)\n    @inbounds x = tape[tapeidx+1]\n    return Core.bitcast(ifelse(isint(t), Int64, Float64), x)\nend\ngetvalue(::Type{Bool}, buf, tape, tapeidx, t) = getnontypemask(t) == UInt64(1)\ngetvalue(::Type{Nothing}, buf, tape, tapeidx, t) = nothing\n@inline function getvalue(T, buf, tape, tapeidx, t)\n    if isobject(t)\n        return getvalue(Object, buf, tape, tapeidx, t)\n    elseif isarray(t)\n        return getvalue(Array, buf, tape, tapeidx, t)\n    elseif isstring(t)\n        return getvalue(String, buf, tape, tapeidx, t)\n    elseif isint(t)\n        return getvalue(Int64, buf, tape, tapeidx, t)\n    elseif isfloat(t)\n        return getvalue(Float64, buf, tape, tapeidx, t)\n    elseif isbool(t)\n        return getvalue(Bool, buf, tape, tapeidx, t)\n    elseif isnull(t)\n        return nothing\n    end\nend\n\nBase.@pure function symbolin(names::Tuple{Vararg{Symbol}}, name::Symbol)\n    for nm in names\n        nm === name && return true\n    end\n    return false\nend\n"}, "source_files_changed": ["src/read.jl", "src/utils.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 26, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "e5ffc4e96de39652ae4c3b11f739b99c438d964b", "parent_sha": "94cf15f3633bb2c84cca4cc60b6f8c8e8e74e1a7", "commit_message": "Remove default JSON3.Struct for types; instead, we have a NoStructType default which will immediately throw an error when reading/writing. This should ensure users don't get weird surprises when they forget to declare a StructType for a custom type, while still allowing for things to Just Work when they subtype AbstractArray or AbstractDict for example", "commit_date": "2019-06-25T11:59:38-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": "StructType", "signature": null, "confidence": 0.75}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nWhile the default `StructType` for custom types is `JSON3.Struct()`, it is less flexible, yet more performant. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written. \n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written. \n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{String}, escaped, ptr, len) = escaped ? unescape(PointerString(ptr, len)) : unsafe_string(ptr, len)\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[K(key)] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf Base.unsafe_write(io, pointer(buf), pos - 1)\nend\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{Object, Array, AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ObjectType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            y = _getfield(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                y = _getfield(x, i)\n                buf, pos, len = write(StructType(y), buf, pos, len, y)\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    pairs = keyvaluepairs(x)\n    n = length(pairs)\n    i = 1\n    for (k, v) in pairs\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T) where {T} = write(NumberType(), buf, pos, len, numbertype(T)(x))\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::AbstractString)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n\"Default `JSON3.StructType` for types that don't have a `StructType` defined; this ensures any object going in/out of JSON3 has an explicit `StructType`\"\nstruct NoStructType <: StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nThis `StructType` is less flexible, yet more performant than `JSON3.Mutable`. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written. \n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{Any}) = Struct()\nStructType(::Type{T}) where {T} = NoStructType()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written. \n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::AbstractVector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nread(::NoStructType, buf, pos, len, b, ::Type{T}) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{String}, escaped, ptr, len) = escaped ? unescape(PointerString(ptr, len)) : unsafe_string(ptr, len)\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[K(key)] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf Base.unsafe_write(io, pointer(buf), pos - 1)\nend\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{Object, Array, AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ObjectType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NoStructType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\nwrite(::NoStructType, buf, pos, len, ::T) where {T} = throw(ArgumentError(\"$T doesn't have a defined `JSON3.StructType`\"))\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            y = _getfield(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                y = _getfield(x, i)\n                buf, pos, len = write(StructType(y), buf, pos, len, y)\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    pairs = keyvaluepairs(x)\n    n = length(pairs)\n    i = 1\n    for (k, v) in pairs\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T) where {T} = write(NumberType(), buf, pos, len, numbertype(T)(x))\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::AbstractString)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/structs.jl", "src/write.jl"], "test_files_changed": ["test/json.jl", "test/runtests.jl"], "lines_changed": 34, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "f5eb2933f07fc051390215740cd28960acfea20b", "parent_sha": "e81bb3293c25ca02c01cbfe221ca7a99f122672f", "commit_message": "Fix #1 by ensuring our original tape never goes out of scope; we can do this by using proper Views from Base instead of unsafe_wrap", "commit_date": "2019-06-25T11:19:58-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/JSON3.jl", "target_symbol": "getvalue", "signature": null, "confidence": 0.75}, "files_before": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object{S <: AbstractVector{UInt8}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::Vector{UInt64}\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(2), 0])\n\nstruct Array{T, S <: AbstractVector{UInt8}} <: AbstractVector{T}\n    buf::S\n    tape::Vector{UInt64}\nend\n\nArray{T}(buf::S, tape::Vector{UInt64}) where {T, S} = Array{T, S}(buf, tape)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n", "src/utils.jl": "_symbol(ptr, len) = ccall(:jl_symbol_n, Ref{Symbol}, (Ptr{UInt8}, Int), ptr, len)\n\nfunction getbyte(buf, pos)\n    unsafe_load(pointer(buf.s), pos)\nend\n\nmacro eof()\n    esc(quote\n        if pos > len\n            error = UnexpectedEOF\n            @goto invalid\n        end\n    end)\nend\n\nmacro wh()\n    esc(quote\n        while b == UInt8('\\t') || b == UInt8(' ') || b == UInt8('\\n') || b == UInt8('\\r')\n            pos += 1\n            if pos > len\n                error = UnexpectedEOF\n                @goto invalid\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nconst EMPTY   = UInt64(0b00000000) << 56\nconst OBJECT  = UInt64(0b00000001) << 56\nconst ARRAY   = UInt64(0b00000010) << 56\nconst STRING  = UInt64(0b00000100) << 56\nconst INT     = UInt64(0b00001000) << 56\nconst FLOAT   = UInt64(0b00010000) << 56\nconst BOOL    = UInt64(0b00100000) << 56\nconst NULL    = UInt64(0b01000000) << 56\nconst ANY     = UInt64(0b10000000) << 56\n\nconst TYPEMASK = 0xff00000000000000\n\nempty(x::UInt64) = (x & TYPEMASK) == EMPTY\nisany(x::UInt64) = (x & TYPEMASK) == ANY\nisobject(x::UInt64) = (x & TYPEMASK) == OBJECT\nisarray(x::UInt64) = (x & TYPEMASK) == ARRAY\nisstring(x::UInt64) = (x & TYPEMASK) == STRING\nisint(x::UInt64) = (x & TYPEMASK) == INT\nisfloat(x::UInt64) = (x & TYPEMASK) == FLOAT\nisbool(x::UInt64) = (x & TYPEMASK) == BOOL\nisnull(x::UInt64) = (x & TYPEMASK) == NULL\nisintfloat(x::UInt64) = (x & TYPEMASK) == (INT | FLOAT)\nnonnull(x::UInt64) = (x & TYPEMASK) & ~NULL\n\nfunction geteltype(T)\n    if empty(T); return Union{}\n    elseif isany(T); return Any\n    elseif isobject(T); return Object\n    elseif isarray(T); return Array\n    elseif isstring(T); return String\n    elseif isint(T); return Int64\n    elseif isfloat(T); return Float64\n    elseif isbool(T); return Bool\n    elseif isnull(T); return Nothing\n    elseif isintfloat(T); return Union{Int64, Float64}\n    else return Union{geteltype(nonnull(T)), Nothing}\n    end\nend\n\nobject(tapelen) = OBJECT | Core.bitcast(UInt64, tapelen)\narray(tapelen)  = ARRAY  | Core.bitcast(UInt64, tapelen)\neltypelen(T, len) = T | Core.bitcast(UInt64, len)\nstring(len) = STRING | Core.bitcast(UInt64, len)\nconst ESCAPE_BIT = UInt64(1) << 63\n\nfunction promoteeltype(A, B)\n    if A == B\n        return A\n    elseif A == EMPTY\n        return B\n    elseif A == INT && B == FLOAT\n        return A | B\n    elseif A == FLOAT && B == INT\n        return A | B\n    elseif A == NULL || B == NULL\n        return A | B\n    else\n        return ANY\n    end\nend\n\ngettypemask(x::UInt64) = x & TYPEMASK\ngetnontypemask(x::UInt64) = Core.bitcast(Int64, x & ~TYPEMASK)\ngetpos(x::UInt64) = Core.bitcast(Int64, getnontypemask(x) >> 16)\ngetlen(x::UInt64) = Core.bitcast(Int64, x & 0x000000000000ffff)\n\ngettapelen(T, x::UInt64) = ifelse(isobject(x) | isarray(x), getnontypemask(x), 2)\ngettapelen(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = 2\n\nregularstride(T) = false\nregularstride(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = true\nregularstride(::Type{Union{Int64, Float64}}) = true\n\ngetvalue(::Type{Object}, buf, tape, tapeidx, t) = Object(buf,\n    unsafe_wrap(Base.Array, pointer(tape, tapeidx), getnontypemask(t)))\ngetvalue(::Type{Array}, buf, tape, tapeidx, t) = Array{geteltype(tape[tapeidx+1])}(buf,\n    unsafe_wrap(Base.Array, pointer(tape, tapeidx), getnontypemask(t)))\nfunction getvalue(::Type{Symbol}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return Symbol(unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t))))\n    else\n        return _symbol(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{String}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t)))\n    else\n        return unsafe_string(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{Int64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Int64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Float64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Float64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Union{Int64, Float64}}, buf, tape, tapeidx, t)\n    @inbounds x = tape[tapeidx+1]\n    return Core.bitcast(ifelse(isint(t), Int64, Float64), x)\nend\ngetvalue(::Type{Bool}, buf, tape, tapeidx, t) = getnontypemask(t) == UInt64(1)\ngetvalue(::Type{Nothing}, buf, tape, tapeidx, t) = nothing\n@inline function getvalue(T, buf, tape, tapeidx, t)\n    if isobject(t)\n        return getvalue(Object, buf, tape, tapeidx, t)\n    elseif isarray(t)\n        return getvalue(Array, buf, tape, tapeidx, t)\n    elseif isstring(t)\n        return getvalue(String, buf, tape, tapeidx, t)\n    elseif isint(t)\n        return getvalue(Int64, buf, tape, tapeidx, t)\n    elseif isfloat(t)\n        return getvalue(Float64, buf, tape, tapeidx, t)\n    elseif isbool(t)\n        return getvalue(Bool, buf, tape, tapeidx, t)\n    elseif isnull(t)\n        return nothing\n    end\nend\n\nBase.@pure function symbolin(names::Tuple{Vararg{Symbol}}, name::Symbol)\n    for nm in names\n        nm === name && return true\n    end\n    return false\nend"}, "files_after": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object{S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractDict{Symbol, Any}\n    buf::S\n    tape::TT\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(2), 0])\n\nstruct Array{T, S <: AbstractVector{UInt8}, TT <: AbstractVector{UInt64}} <: AbstractVector{T}\n    buf::S\n    tape::TT\nend\n\nArray{T}(buf::S, tape::TT) where {T, S, TT} = Array{T, S, TT}(buf, tape)\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-25):min(end, pos+25)]))\n\"\"\"))\n\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n", "src/utils.jl": "_symbol(ptr, len) = ccall(:jl_symbol_n, Ref{Symbol}, (Ptr{UInt8}, Int), ptr, len)\n\nfunction getbyte(buf, pos)\n    unsafe_load(pointer(buf.s), pos)\nend\n\nmacro eof()\n    esc(quote\n        if pos > len\n            error = UnexpectedEOF\n            @goto invalid\n        end\n    end)\nend\n\nmacro wh()\n    esc(quote\n        while b == UInt8('\\t') || b == UInt8(' ') || b == UInt8('\\n') || b == UInt8('\\r')\n            pos += 1\n            if pos > len\n                error = UnexpectedEOF\n                @goto invalid\n            end\n            b = getbyte(buf, pos)\n        end\n    end)\nend\n\nconst EMPTY   = UInt64(0b00000000) << 56\nconst OBJECT  = UInt64(0b00000001) << 56\nconst ARRAY   = UInt64(0b00000010) << 56\nconst STRING  = UInt64(0b00000100) << 56\nconst INT     = UInt64(0b00001000) << 56\nconst FLOAT   = UInt64(0b00010000) << 56\nconst BOOL    = UInt64(0b00100000) << 56\nconst NULL    = UInt64(0b01000000) << 56\nconst ANY     = UInt64(0b10000000) << 56\n\nconst TYPEMASK = 0xff00000000000000\n\nempty(x::UInt64) = (x & TYPEMASK) == EMPTY\nisany(x::UInt64) = (x & TYPEMASK) == ANY\nisobject(x::UInt64) = (x & TYPEMASK) == OBJECT\nisarray(x::UInt64) = (x & TYPEMASK) == ARRAY\nisstring(x::UInt64) = (x & TYPEMASK) == STRING\nisint(x::UInt64) = (x & TYPEMASK) == INT\nisfloat(x::UInt64) = (x & TYPEMASK) == FLOAT\nisbool(x::UInt64) = (x & TYPEMASK) == BOOL\nisnull(x::UInt64) = (x & TYPEMASK) == NULL\nisintfloat(x::UInt64) = (x & TYPEMASK) == (INT | FLOAT)\nnonnull(x::UInt64) = (x & TYPEMASK) & ~NULL\n\nfunction geteltype(T)\n    if empty(T); return Union{}\n    elseif isany(T); return Any\n    elseif isobject(T); return Object\n    elseif isarray(T); return Array\n    elseif isstring(T); return String\n    elseif isint(T); return Int64\n    elseif isfloat(T); return Float64\n    elseif isbool(T); return Bool\n    elseif isnull(T); return Nothing\n    elseif isintfloat(T); return Union{Int64, Float64}\n    else return Union{geteltype(nonnull(T)), Nothing}\n    end\nend\n\nobject(tapelen) = OBJECT | Core.bitcast(UInt64, tapelen)\narray(tapelen)  = ARRAY  | Core.bitcast(UInt64, tapelen)\neltypelen(T, len) = T | Core.bitcast(UInt64, len)\nstring(len) = STRING | Core.bitcast(UInt64, len)\nconst ESCAPE_BIT = UInt64(1) << 63\n\nfunction promoteeltype(A, B)\n    if A == B\n        return A\n    elseif A == EMPTY\n        return B\n    elseif A == INT && B == FLOAT\n        return A | B\n    elseif A == FLOAT && B == INT\n        return A | B\n    elseif A == NULL || B == NULL\n        return A | B\n    else\n        return ANY\n    end\nend\n\ngettypemask(x::UInt64) = x & TYPEMASK\ngetnontypemask(x::UInt64) = Core.bitcast(Int64, x & ~TYPEMASK)\ngetpos(x::UInt64) = Core.bitcast(Int64, getnontypemask(x) >> 16)\ngetlen(x::UInt64) = Core.bitcast(Int64, x & 0x000000000000ffff)\n\ngettapelen(T, x::UInt64) = ifelse(isobject(x) | isarray(x), getnontypemask(x), 2)\ngettapelen(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = 2\n\nregularstride(T) = false\nregularstride(::Union{Type{Int64}, Type{Float64}, Type{Bool}, Type{Nothing}}) = true\nregularstride(::Type{Union{Int64, Float64}}) = true\n\ngetvalue(::Type{Object}, buf, tape, tapeidx, t) = Object(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)))\ngetvalue(::Type{Array}, buf, tape, tapeidx, t) = Array{geteltype(tape[tapeidx+1])}(buf, Base.unsafe_view(tape, tapeidx:tapeidx + getnontypemask(t)))\n\nfunction getvalue(::Type{Symbol}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return Symbol(unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t))))\n    else\n        return _symbol(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{String}, buf, tape, tapeidx, t)\n    @inbounds t2 = tape[tapeidx + 1]\n    if (t2 & ESCAPE_BIT) == ESCAPE_BIT\n        return unescape(PointerString(pointer(buf, getnontypemask(t2)), getnontypemask(t)))\n    else\n        return unsafe_string(pointer(buf, getnontypemask(t2)), getnontypemask(t))\n    end\nend\nfunction getvalue(::Type{Int64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Int64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Float64}, buf, tape, tapeidx, t)\n    @inbounds x = Core.bitcast(Float64, tape[tapeidx+1])\n    return x\nend\nfunction getvalue(::Type{Union{Int64, Float64}}, buf, tape, tapeidx, t)\n    @inbounds x = tape[tapeidx+1]\n    return Core.bitcast(ifelse(isint(t), Int64, Float64), x)\nend\ngetvalue(::Type{Bool}, buf, tape, tapeidx, t) = getnontypemask(t) == UInt64(1)\ngetvalue(::Type{Nothing}, buf, tape, tapeidx, t) = nothing\n@inline function getvalue(T, buf, tape, tapeidx, t)\n    if isobject(t)\n        return getvalue(Object, buf, tape, tapeidx, t)\n    elseif isarray(t)\n        return getvalue(Array, buf, tape, tapeidx, t)\n    elseif isstring(t)\n        return getvalue(String, buf, tape, tapeidx, t)\n    elseif isint(t)\n        return getvalue(Int64, buf, tape, tapeidx, t)\n    elseif isfloat(t)\n        return getvalue(Float64, buf, tape, tapeidx, t)\n    elseif isbool(t)\n        return getvalue(Bool, buf, tape, tapeidx, t)\n    elseif isnull(t)\n        return nothing\n    end\nend\n\nBase.@pure function symbolin(names::Tuple{Vararg{Symbol}}, name::Symbol)\n    for nm in names\n        nm === name && return true\n    end\n    return false\nend"}, "source_files_changed": ["src/JSON3.jl", "src/utils.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 25, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "a9df0c44403e91cf10b188c84b641caa6c296294", "parent_sha": "e4c671dfced0655f69d0be656bd76a929fc7a6df", "commit_message": "Fix loading", "commit_date": "2019-06-21T22:36:42-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": "JSON3.StructType", "signature": null, "confidence": 0.6}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nWhile the default `StructType` for custom types is `JSON3.Struct()`, it is less flexible, yet more performant. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written. \n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written. \n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\"\"\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\"\"\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{String}, escaped, ptr, len) = escaped ? unescape(PointerString(ptr, len)) : unsafe_string(ptr, len)\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[K(key)] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Struct()\n\nWhile the default `StructType` for custom types is `JSON3.Struct()`, it is less flexible, yet more performant. For reading a `JSON3.Struct()` from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like `MyType(val1, val2, val3)`. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of `JSON3.Struct()` in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the `JSON3.Mutable()` option.\n\"\"\"\nstruct Struct <: DataType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.Mutable()\n\nThe slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via `JSON3.Mutable()`. This technique requires your Julia type to be defined, ***at a minimum***, like:\n```julia\nmutable struct MyType\n    field1\n    field2\n    field3\n    # etc.\n\n    MyType() = new()\nend\n```\nNote specifically that we're defining a `mutable struct` to allow field mutation, and providing a `MyType() = new()` inner constructor which constructs an \"empty\" `MyType` where isbits fields will be randomly initialied, and reference fields will be `#undef`. (Note that the inner constructor doesn't need to be ***exactly*** this, but at least needs to be callable like `MyType()`. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like `MyType()`, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if \"extra\" fields exist in the JSON structure that aren't apart of the Julia struct's fields, it will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.\n\nThere are a few additional helper methods that can be utilized by `JSON3.Mutable()` types to hand-tune field reading/writing behavior:\n\n* `JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))`: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the `json1` key, the `field1` field of `MyType` will be set. When writing the `field2` field of `MyType`, the JSON key will be `json2`.\n* `JSON3.excludes(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` to ignore when reading and writing, provided as a `Tuple` of `Symbol`s. When reading, if `field1` is encountered as a JSON key, it's value will be read, but the field will not be set in `MyType`. When writing, `field1` will be skipped when writing out `MyType` fields as key-value pairs.\n* `JSON3.omitempties(::Type{MyType}) = (:field1, :field2)`: specify fields of `MyType` that shouldn't be written if they are \"empty\", provided as a `Tuple` of `Symbol`s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written. \n\"\"\"\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n\n\"\"\"\n    JSON3.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))\n\nProvides a mapping of Julia field name to expected JSON object key name.\nThis affects both reading and writing.\nWhen reading the `json1` key, the `field1` field of `MyType` will be set.\nWhen writing the `field2` field of `MyType`, the JSON key will be `json2`.\n\"\"\"\nfunction names end\n\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n\"\"\"\n    JSON3.excludes(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should be ignored when reading, and excluded from writing.\n\"\"\"\nfunction excludes end\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.omitempties(::Type{MyType}) = (:field1, :field2)\n\nSpecify for a `JSON3.Mutable` `StructType` the fields, given as a `Tuple` of `Symbol`s, that should not be written if they're considered \"empty\".\nIf a field is a collection (AbstractDict, AbstractArray, etc.) and `isempty(x) === true`, then it will not be written. If a field is `#undef`, it will not be written. If a field is `nothing`, it will not be written. \n\"\"\"\nfunction omitempties end\n\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n\"\"\"\n    JSON3.JSONType\n\nAn abstract type used in the API for \"interface types\" to map Julia types to a specific JSON type. See docs for the following for more details:\n\n    * JSON3.ObjectType\n    * JSON3.ArrayType\n    * JSON3.StringType\n    * JSON3.NumberType\n    * JSON3.BoolType\n    * JSON3.NullType\n\"\"\"\nabstract type JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ObjectType()\n\nDeclaring my type is `JSON3.ObjectType()` means it should map to a JSON object of unordered key-value pairs, where keys are `Symbol` or `String`, and values are any other type (or `Any`).\n\nTypes already declared as `JSON3.ObjectType()` include:\n  * Any subtype of `AbstractDict`\n  * Any `NamedTuple` type\n  * Any `Pair` type\n\nSo if your type subtypes `AbstractDict` and implements its interface, then JSON reading/writing should just work!\n\nOtherwise, the interface to satisfy `JSON3.ObjectType()` for reading is:\n\n  * `MyType(x::Dict{Symbol, Any})`: implement a constructor that takes a `Dict{Symbol, Any}` of key-value pairs parsed from JSOn\n  * `JSON3.construct(::Type{MyType}, x::Dict)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)\n\nThe interface to satisfy for writing is:\n\n  * `pairs(x)`: implement the `pairs` iteration function (from Base) to iterate key-value pairs to be written out to JSON\n  * `JSON3.keyvaluepairs(x::MyType)`: alternatively, you can overload the `JSON3.keyvaluepairs` function if overloading `pairs` isn't possible for whatever reason\n\"\"\"\nstruct ObjectType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.ArrayType()\n\nDeclaring my type is `JSON3.ArrayType()` means it should map to a JSON array of ordered elements, homogenous or otherwise.\n\nTypes already declared as `JSON3.ArrayType()` include:\n  * Any subtype of `AbstractArray`\n  * Any subtype of `AbstractSet`\n  * Any `Tuple` type\n\nSo if your type already subtypes these and satifies the interface, things should just work.\n\nOtherwise, the interface to satisfy `JSON3.ArrayType()` for reading is:\n\n  * `MyType(x::Vector)`: implement a constructo that takes a `Vector` argument of values and constructs a `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Vector)`: alternatively, you may overload the `JSON3.construct` method for your type if defining a constructor isn't possible\n  * Optional: `Base.IteratorEltype(::Type{MyType})` and `Base.eltype(x::MyType)`: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such\n\nThe interface to satisfy for writing is:\n\n  * `iterate(x::MyType)`: just iteration over each element is required; note if you subtype `AbstractArray` and define `getindex(x::MyType, i::Int)`, then iteration is already defined for your type\n\"\"\"\nstruct ArrayType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.StringType()\n\nDeclaring my type is `JSON3.StringType()` means it should map to a JSON string value.\n\nTypes already declared as `JSON3.StringType()` include:\n  * Any subtype of `AbstractString`\n  * The `Symbol` type\n  * Any subtype of `Enum` (values are written with their symbolic name)\n  * The `Char` type\n\nSo if your type is an `AbstractString` or `Enum`, then things should already work.\n\nOtherwise, the interface to satisfy `JSON3.StringType()` for reading is:\n\n  * `MyType(x::String)`: define a constructor for your type that takes a single String argument\n  * `JSON3.construct(::Type{MyType}, x::String)`: alternatively, you may overload `JSON3.construct` for your type\n  * `JSON3.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int)`: another option is to overload `JSON3.construct` with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both `JSON3.construct` methods, since JSON strings with escape characters in them will be fully unescaped before calling `JSON3.construct(::Type{MyType}, x::String)`, i.e. there is no direct pointer/length method for escaped strings\n\nThe interface to satisfy for writing is:\n\n  * `Base.string(x::MyType)`: overload `Base.string` for your type to return a \"stringified\" value\n\"\"\"\nstruct StringType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NumberType()\n\nDeclaring my type is `JSON3.NumberType()` means it should map to a JSON number value.\n\nTypes already declared as `JSON3.NumberType()` include:\n  * Any subtype of `Signed`\n  * Any subtype of `Unsigned`\n  * Any subtype of `AbstractFloat`\n\nIn addition to declaring `JSON3.NumberType()`, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:\n```julia\nJSON3.numbertype(::Type{MyType}) = Float64\n```\n\nIn this case, I'm declaring the `MyType` should map to an already-supported number type `Float64`. This means that when reading, JSON3 will first parse a `Float64` value, and then call `MyType(x::Float64)`. Note that custom types may also overload `JSON3.construct(::Type{MyType}, x::Float64)` if using a constructor isn't possible. Also note that the default for any type declared as `JSON3.NumberType()` is `Float64`.\n\nSimilarly for writing, JSON3 will first call `Float64(x::MyType)` before writing the resulting `Float64` value out as a JSON number.\n\"\"\"\nstruct NumberType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.BoolType()\n\nDeclaring my type is `JSON3.BoolType()` means it should map to a JSON boolean value.\n\nTypes already declared as `JSON3.BoolType()` include:\n  * `Bool`\n\nThe interface to satisfy for reading is:\n  * `MyType(x::Bool)`: define a constructor that takes a single `Bool` value\n  * `JSON3.construct(::Type{MyType}, x::Bool)`: alternatively, you may overload `JSON3.construct`\n\nThe interface to satisfy for writing is:\n  * `Bool(x::MyType)`: define a conversion to `Bool` method\n\"\"\"\nstruct BoolType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.NullType()\n\nDeclaring my type is `JSON3.NullType()` means it should map to the JSON value `null`.\n\nTypes already declared as `JSON3.NullType()` include:\n  * `nothing`\n  * `missing`\n\nThe interface to satisfy for reading is:\n  * `MyType()`: an empty constructor for `MyType`\n  * `JSON3.construct(::Type{MyType}, x::Nothing)`: alternatively, you may overload `JSON3.construct`\n\nThere is no interface for writing; if a custom type is declared as `JSON3.NullType()`, then the JSON value `null` will be written.\n\"\"\"\nstruct NullType <: JSONType end\n\n\"\"\"\n    JSON3.StructType(::Type{MyType}) = JSON3.AbstractType()\n\nWhen declaring my type as `JSON3.AbstractType()`, you must also define `JSON3.subtypes`, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define `JSON3.subtypekey` that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this `StructType`:\n```julia\nabstract type Vehicle end\n\nstruct Car <: Vehicle\n    type::String\n    make::String\n    model::String\n    seatingCapacity::Int\n    topSpeed::Float64\nend\n\nstruct Truck <: Vehicle\n    type::String\n    make::String\n    model::String\n    payloadCapacity::Float64\nend\n\nJSON3.StructType(::Type{Vehicle}) = JSON3.AbstractType()\nJSON3.subtypekey(::Type{Vehicle}) = :type\nJSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)\n\ncar = JSON3.read(\\\"\\\"\\\"\n{\n    \"type\": \"car\",\n    \"make\": \"Mercedes-Benz\",\n    \"model\": \"S500\",\n    \"seatingCapacity\": 5,\n    \"topSpeed\": 250.1\n}\\\"\\\"\\\", Vehicle)\n```\nHere we have a `Vehicle` type that is defined as a `JSON3.AbstractType()`. We also have two concrete subtypes, `Car` and `Truck`. In addition to the `StructType` definition, we also define `JSON3.subtypekey(::Type{Vehicle}) = :type`, which signals to JSON3 that, when parsing a JSON structure, when it encounters the `type` key, it should use the value, in our example it's `car`, to discover the appropriate concrete subtype to parse the structure as, in this case `Car`. The mapping of JSON subtype key value to Julia Type is defined in our example via `JSON3.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)`. Thus, `JSON3.AbstractType` is useful when the JSON structure to read includes a \"subtype\" key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a `Car` instead of a `Truck`.\n\"\"\"\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{String}, escaped, ptr, len) = escaped ? unescape(PointerString(ptr, len)) : unsafe_string(ptr, len)\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[K(key)] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 4, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "9bce2fcd60b87417d11d852b1e58fac71abfc493", "parent_sha": "f2d22d9f057b66a369f4dab87821752c0a1b1089", "commit_message": "Start work on docs", "commit_date": "2019-06-21T17:07:32-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "_isempty", "signature": null, "confidence": 0.75}, "files_before": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf Base.unsafe_write(io, pointer(buf), pos - 1)\nend\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ObjectType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            y = _getfield(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                y = _getfield(x, i)\n                buf, pos, len = write(StructType(y), buf, pos, len, y)\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    pairs = keyvaluepairs(x)\n    n = length(pairs)\n    i = 1\n    for (k, v) in pairs\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T) where {T} = write(NumberType(), buf, pos, len, numbertype(T)(x))\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::AbstractString)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf Base.unsafe_write(io, pointer(buf), pos - 1)\nend\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{Object, Array, AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ObjectType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            y = _getfield(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                y = _getfield(x, i)\n                buf, pos, len = write(StructType(y), buf, pos, len, y)\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    pairs = keyvaluepairs(x)\n    n = length(pairs)\n    i = 1\n    for (k, v) in pairs\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T) where {T} = write(NumberType(), buf, pos, len, numbertype(T)(x))\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::AbstractString)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 82, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "f2989f6a0c1b4fb432f86211f324adab516845c8", "parent_sha": "8d0a6527c0088e55aa33175f07c6e3caea49cb5b", "commit_message": "Fix enum reading in pre-1.2", "commit_date": "2019-06-20T23:05:26-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": "construct", "signature": null, "confidence": 0.6}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\nstruct Struct <: DataType end\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n# \"interface\" type: fields are internal, json representation is accessible via transform/interface functions\nabstract type JSONType end\nstruct ObjectType <: JSONType end\nstruct ArrayType <: JSONType end\nstruct StringType <: JSONType end\nstruct NumberType <: JSONType end\nstruct BoolType <: JSONType end\nstruct NullType <: JSONType end\n\n# \"abstract\" type: json representation via a concrete subtype, json includes subtype key-value to signal concrete subtype\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    sym = _symbol(ptr, len)\n    for (k, v) in Base.Enums.namemap(E)\n        sym == v && return E(k)\n    end\n    throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{String}, escaped, ptr, len) = escaped ? unescape(PointerString(ptr, len)) : unsafe_string(ptr, len)\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[K(key)] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\nstruct Struct <: DataType end\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n# \"interface\" type: fields are internal, json representation is accessible via transform/interface functions\nabstract type JSONType end\nstruct ObjectType <: JSONType end\nstruct ArrayType <: JSONType end\nstruct StringType <: JSONType end\nstruct NumberType <: JSONType end\nstruct BoolType <: JSONType end\nstruct NullType <: JSONType end\n\n# \"abstract\" type: json representation via a concrete subtype, json includes subtype key-value to signal concrete subtype\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    @static if VERSION < v\"1.2.0-DEV.272\"\n        Core.eval(parentmodule(E), _symbol(ptr, len))\n    else\n        sym = _symbol(ptr, len)\n        for (k, v) in Base.Enums.namemap(E)\n            sym == v && return E(k)\n        end\n        throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\n    end\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{String}, escaped, ptr, len) = escaped ? unescape(PointerString(ptr, len)) : unsafe_string(ptr, len)\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[K(key)] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 14, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "330132a47c4d2ebeb7c2fb60dca5efc86e3c6ace", "parent_sha": "5670af800414e89389877dce9a551a720cf257d1", "commit_message": "Clean up tests and get everything passing", "commit_date": "2019-06-20T22:16:19-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": "defaultminimum", "signature": null, "confidence": 0.75}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\nstruct Struct <: DataType end\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n# \"interface\" type: fields are internal, json representation is accessible via transform/interface functions\nabstract type JSONType end\nstruct ObjectType <: JSONType end\nstruct ArrayType <: JSONType end\nstruct StringType <: JSONType end\nstruct NumberType <: JSONType end\nstruct BoolType <: JSONType end\nstruct NullType <: JSONType end\n\n# \"abstract\" type: json representation via a concrete subtype, json includes subtype key-value to signal concrete subtype\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    sym = _symbol(ptr, len)\n    for (k, v) in Base.Enums.namemap(E)\n        sym == v && return E(k)\n    end\n    throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Real}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{String}, escaped, ptr, len) = escaped ? unescape(PointerString(ptr, len)) : unsafe_string(ptr, len)\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[K(key)] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = sum(defaultminimum(k) + defaultminimum(v) for (k, v) in keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf Base.unsafe_write(io, pointer(buf), pos - 1)\nend\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    println(\"re-allocing...\")\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ObjectType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            y = _getfield(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                y = _getfield(x, i)\n                buf, pos, len = write(StructType(y), buf, pos, len, y)\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    pairs = keyvaluepairs(x)\n    n = length(pairs)\n    i = 1\n    for (k, v) in pairs\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T) where {T} = write(NumberType(), buf, pos, len, numbertype(T)(x))\nfunction write(::NumberType, buf, pos, len, x::Float64)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::AbstractString)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\nstruct Struct <: DataType end\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n# \"interface\" type: fields are internal, json representation is accessible via transform/interface functions\nabstract type JSONType end\nstruct ObjectType <: JSONType end\nstruct ArrayType <: JSONType end\nstruct StringType <: JSONType end\nstruct NumberType <: JSONType end\nstruct BoolType <: JSONType end\nstruct NullType <: JSONType end\n\n# \"abstract\" type: json representation via a concrete subtype, json includes subtype key-value to signal concrete subtype\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    sym = _symbol(ptr, len)\n    for (k, v) in Base.Enums.namemap(E)\n        sym == v && return E(k)\n    end\n    throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Unsigned}) = NumberType()\nStructType(::Type{<:Signed}) = NumberType()\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{String}, escaped, ptr, len) = escaped ? unescape(PointerString(ptr, len)) : unsafe_string(ptr, len)\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[K(key)] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend", "src/write.jl": "defaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = ifelse(x, 4, 5)\ndefaultminimum(x::AbstractString) = ncodeunits(x) + 2\ndefaultminimum(x::Symbol) = ccall(:strlen, Csize_t, (Cstring,), x) + 2\ndefaultminimum(x::Enum) = 16\ndefaultminimum(::Type{T}) where {T} = 16\ndefaultminimum(x::Char) = 3\ndefaultminimum(x::Union{Tuple, AbstractSet, AbstractArray}) = isempty(x) ? 2 : sum(defaultminimum, x)\ndefaultminimum(x::Union{AbstractDict, NamedTuple, Pair}) = isempty(x) ? 2 : sum(defaultminimum(k) + defaultminimum(v) for (k, v) in keyvaluepairs(x))\ndefaultminimum(x) = max(2, sizeof(x))\n\nfunction write(io::IO, obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf Base.unsafe_write(io, pointer(buf), pos - 1)\nend\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    # println(\"re-allocing...\")\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# we need to special-case writing Type{T} because of ambiguities w/ StructTypes\nwrite(::Struct, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::Mutable, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ObjectType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::ArrayType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::StringType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NumberType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::NullType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::BoolType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\nwrite(::AbstractType, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            y = _getfield(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                y = _getfield(x, i)\n                buf, pos, len = write(StructType(y), buf, pos, len, y)\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    pairs = keyvaluepairs(x)\n    n = length(pairs)\n    i = 1\n    for (k, v) in pairs\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x::T) where {T} = write(NumberType(), buf, pos, len, numbertype(T)(x))\nfunction write(::NumberType, buf, pos, len, x::AbstractFloat)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    x = 0\n    @simd for i = 1:ncodeunits(str)\n        @inbounds len = ESCAPELENS[codeunit(str, i) + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::AbstractString)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/structs.jl", "src/write.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 12, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "412ad7d39851db9ba9a19c4e601b5269847cd52b", "parent_sha": "3c2e034b7b5c08c176f5644c829b246ce72bf455", "commit_message": "Fix Dict performance issue by avoiding use of ifelse?", "commit_date": "2019-06-19T11:47:18-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\nstruct Struct <: DataType end\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n# \"interface\" type: fields are internal, json representation is accessible via transform/interface functions\nabstract type JSONType end\nstruct ObjectType <: JSONType end\nstruct ArrayType <: JSONType end\nstruct StringType <: JSONType end\nstruct NumberType <: JSONType end\nstruct BoolType <: JSONType end\nstruct NullType <: JSONType end\n\n# \"abstract\" type: json representation via a concrete subtype, json includes subtype key-value to signal concrete subtype\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    sym = _symbol(ptr, len)\n    for (k, v) in Base.Enums.namemap(E)\n        sym == v && return E(k)\n    end\n    throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Real}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{String}, escaped, ptr, len) = escaped ? unescape(PointerString(ptr, len)) : unsafe_string(ptr, len)\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[K(key)] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\nstruct Struct <: DataType end\nstruct Mutable <: DataType end\n\nStructType(u::Union) = Struct()\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[1]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[2]\n    end\n    return julianame\nend\n\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n# \"interface\" type: fields are internal, json representation is accessible via transform/interface functions\nabstract type JSONType end\nstruct ObjectType <: JSONType end\nstruct ArrayType <: JSONType end\nstruct StringType <: JSONType end\nstruct NumberType <: JSONType end\nstruct BoolType <: JSONType end\nstruct NullType <: JSONType end\n\n# \"abstract\" type: json representation via a concrete subtype, json includes subtype key-value to signal concrete subtype\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(VectorString(bytes), T)\n\nfunction read(str::AbstractString, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    b = getbyte(buf, pos)\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{String, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                return pos, int\n            else\n                return pos, float\n            end\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{Symbol}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{Char}) = StringType()\n\nfunction construct(::Type{Char}, str::String)\n    if length(str) == 1\n        return Char(str[1])\n    else\n        throw(ArgumentError(\"invalid conversion from json string to Char: '$str'\"))\n    end\nend\n\nfunction construct(::Type{E}, ptr::Ptr{UInt8}, len::Int) where {E <: Enum}\n    sym = _symbol(ptr, len)\n    for (k, v) in Base.Enums.namemap(E)\n        sym == v && return E(k)\n    end\n    throw(ArgumentError(\"invalid $E string value: \\\"$(unsafe_string(ptr, len))\\\"\"))\nend\n\nconstruct(T, str::String) = T(str)\nconstruct(T, ptr::Ptr{UInt8}, len::Int) = construct(T, unsafe_string(ptr, len))\nconstruct(::Type{Symbol}, ptr::Ptr{UInt8}, len::Int) = _symbol(ptr, len)\n\n@inline function read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        b = getbyte(buf, pos)\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? construct(T, unescape(PointerString(ptr, strlen))) : construct(T, ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nconstruct(T, bool::Bool) = T(bool)\n\n@inline function read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, construct(T, true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, construct(T, false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nconstruct(T, ::Nothing) = T()\n\n@inline function read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, construct(T, nothing)\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Real}) = NumberType()\nnumbertype(::Type{T}) where {T <: Real} = T\nnumbertype(x) = Float64\nconstruct(T, x::Real) = T(x)\n\n@inline function read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, construct(T, x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nconstruct(T, x::Vector{S}) where {S} = T(x)\n\n@inline read(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\n\n@inline function read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8(']')\n            return pos + 1, construct(T, vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\nStructType(::Type{<:NamedTuple}) = ObjectType()\nStructType(::Type{<:Pair}) = ObjectType()\n\nkeyvaluepairs(x) = pairs(x)\nkeyvaluepairs(x::Pair) = (x,)\n\nconstruct(::Type{Dict{K, V}}, x::Dict{K, V}) where {K, V} = x\nconstruct(T, x::Dict{K, V}) where {K, V} = T(x)\n\nconstruct(::Type{NamedTuple}, x::Dict) = NamedTuple{Tuple(keys(x))}(values(x))\nconstruct(::Type{NamedTuple{names}}, x::Dict) where {names} = NamedTuple{names}(Tuple(x[nm] for nm in names))\nconstruct(::Type{NamedTuple{names, types}}, x::Dict) where {names, types} = NamedTuple{names, types}(Tuple(x[nm] for nm in names))\n\nkeyvalue(::Type{Symbol}, escaped, ptr, len) = escaped ? Symbol(unescape(PointerString(ptr, len))) : _symbol(ptr, len)\nkeyvalue(::Type{String}, escaped, ptr, len) = escaped ? unescape(PointerString(ptr, len)) : unsafe_string(ptr, len)\n\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: NamedTuple} = read(ObjectType(), buf, pos, len, b, T, Symbol, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{Dict}) = read(ObjectType(), buf, pos, len, b, Dict, String, Any)\n@inline read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\n\n@inline function read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}, ::Type{V}) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = Dict{K, V}()\n    if b == UInt8('}')\n        return pos + 1, construct(T, x)\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        b = getbyte(buf, pos)\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(K, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[K(key)] = y\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            return pos + 1, construct(T, x)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    b = getbyte(buf, pos)\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        b = getbyte(buf, pos)\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    b = getbyte(buf, pos)\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        b = getbyte(buf, pos)\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            b = getbyte(buf, pos)\n        end\n        key = keyvalue(Symbol, escaped, pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        b = getbyte(buf, pos)\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 6, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "ec8bba2e393d4a4d54f1f48e0f6a84cbec9c1268", "parent_sha": "3f74d37a12d0515878c4aa60f1f0260ad15b975c", "commit_message": "Add a gc preserve to make our unsafe_string more safe", "commit_date": "2019-06-17T10:44:00-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.6}, "files_before": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\nwrite(::Struct, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            y = _getfield(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                y = _getfield(x, i)\n                buf, pos, len = write(StructType(y), buf, pos, len, y)\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x) = write(NumberType(), buf, pos, len, Float64(x))\nfunction write(::NumberType, buf, pos, len, x::Float64)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::String)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return GC.@preserve buf unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\nwrite(::Struct, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            y = _getfield(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                y = _getfield(x, i)\n                buf, pos, len = write(StructType(y), buf, pos, len, y)\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x) = write(NumberType(), buf, pos, len, Float64(x))\nfunction write(::NumberType, buf, pos, len, x::Float64)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::String)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "3f74d37a12d0515878c4aa60f1f0260ad15b975c", "parent_sha": "0d7c4244b51e011ac44e10e6dc8b5dd6c4f1743f", "commit_message": "Fix a couple read/write bugs", "commit_date": "2019-06-13T15:04:33-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "StructType", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\nstruct Struct <: DataType end\nstruct Mutable <: DataType end\n\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[2]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[1]\n    end\n    return julianame\nend\n\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n# \"interface\" type: fields are internal, json representation is accessible via transform/interface functions\nabstract type JSONType end\nstruct ObjectType <: JSONType end\nstruct ArrayType <: JSONType end\nstruct StringType <: JSONType end\nstruct NumberType <: JSONType end\nstruct BoolType <: JSONType end\nstruct NullType <: JSONType end\n\n# \"abstract\" type: json representation via a concrete subtype, json includes subtype key-value to signal concrete subtype\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(String(bytes), T)\n\nfunction read(str::String, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{Symbol, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? T(unescape(PointerString(ptr, strlen))) : T(unsafe_string(ptr, strlen))\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nStructType(::Type{Char}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{Char})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds x = Char(buf[pos])\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    if b != UInt8('\"')\n        error = InvalidChar\n        @goto invalid\n    end\n    return pos + 1, x\n\n@label invalid\n    invalid(error, buf, pos, Char)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, T(true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, T(false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, T()\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Integer}) = NumberType()\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(x::T) where {T <: Real} = T\nnumbertype(x) = Float64\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, T(x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\n\nread(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\nfunction read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            return pos + 1, vals\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\n\nread(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\nfunction read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}=Any, ::Type{V}=Any) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        return pos + 1, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? unescape(PointerString(pointer(buf, keypos), keylen)) : unsafe_string(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[K(key)] = y\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            return pos + 1, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        @inbounds b = buf[pos]\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend", "src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    for i = 1:n\n        if isassigned(x, i)\n            @inbounds y = x[i]\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n            if i < n\n                @writechar ','\n            end\n        else\n            buf, pos, len = write(NullType(), buf, pos, len, x)\n        end\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x) = write(NumberType(), buf, pos, len, Float64(x))\nfunction write(::NumberType, buf, pos, len, x::Float64)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::String)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\nstruct Struct <: DataType end\nstruct Mutable <: DataType end\n\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[2]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[1]\n    end\n    return julianame\nend\n\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n# \"interface\" type: fields are internal, json representation is accessible via transform/interface functions\nabstract type JSONType end\nstruct ObjectType <: JSONType end\nstruct ArrayType <: JSONType end\nstruct StringType <: JSONType end\nstruct NumberType <: JSONType end\nstruct BoolType <: JSONType end\nstruct NullType <: JSONType end\n\n# \"abstract\" type: json representation via a concrete subtype, json includes subtype key-value to signal concrete subtype\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(String(bytes), T)\n\nfunction read(str::String, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{Symbol, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\nStructType(::Type{<:Enum}) = StringType()\nStructType(::Type{DataType}) = StringType()\n\n# argh!\nfunction (::Type{E})(str::String) where {E <: Enum}\n    sym = Symbol(str)\n    for (k, v) in Base.Enums.namemap(E)\n        sym == v && return E(k)\n    end\n    throw(ArgumentError(\"invalid $E string value: \\\"$str\\\"\"))\nend\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? T(unescape(PointerString(ptr, strlen))) : T(unsafe_string(ptr, strlen))\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nStructType(::Type{Char}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{Char})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds x = Char(buf[pos])\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    if b != UInt8('\"')\n        error = InvalidChar\n        @goto invalid\n    end\n    return pos + 1, x\n\n@label invalid\n    invalid(error, buf, pos, Char)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, T(true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, T(false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, T()\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Integer}) = NumberType()\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(x::T) where {T <: Real} = T\nnumbertype(x) = Float64\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, T(x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\nStructType(::Type{<:AbstractSet}) = ArrayType()\nStructType(::Type{<:Tuple}) = ArrayType()\n\nread(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\nfunction read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            return pos + 1, T(vals)\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\n\nread(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\nfunction read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}=Any, ::Type{V}=Any) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        return pos + 1, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? unescape(PointerString(pointer(buf, keypos), keylen)) : unsafe_string(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[K(key)] = y\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            return pos + 1, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        @inbounds b = buf[pos]\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend", "src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(obj), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\nwrite(::Struct, buf, pos, len, ::Type{T}) where {T} = write(StringType(), buf, pos, len, Base.string(T))\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            y = _getfield(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                y = _getfield(x, i)\n                buf, pos, len = write(StructType(y), buf, pos, len, y)\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    n = i = ndigits(x, base=10, pad=1)\n    @check i\n    while i > 0\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x) = write(NumberType(), buf, pos, len, Float64(x))\nfunction write(::NumberType, buf, pos, len, x::Float64)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::String)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/structs.jl", "src/write.jl"], "test_files_changed": [], "lines_changed": 50, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "0d7c4244b51e011ac44e10e6dc8b5dd6c4f1743f", "parent_sha": "0a3419c3822c6fa5a7f9c36b07e1e34a83976518", "commit_message": "Fix unicode escaping bug when digit was 9", "commit_date": "2019-06-10T18:07:42-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/strings.jl", "target_symbol": "charvalue", "signature": null, "confidence": 0.75}, "files_before": {"src/strings.jl": "struct PointerString <: AbstractString\n    ptr::Ptr{UInt8}\n    len::Int\nend\n\nfunction Base.hash(s::PointerString, h::UInt)\n    h += Base.memhash_seed\n    ccall(Base.memhash, UInt, (Ptr{UInt8}, Csize_t, UInt32), s.ptr, s.len, h % UInt32) + h\nend\n\nimport Base: ==\nfunction ==(x::String, y::PointerString)\n    sizeof(x) == y.len && ccall(:memcmp, Cint, (Ptr{UInt8}, Ptr{UInt8}, Csize_t), pointer(x), y.ptr, y.len) == 0\nend\n==(y::PointerString, x::String) = x == y\n\nBase.ncodeunits(s::PointerString) = s.len\n@inline function Base.codeunit(s::PointerString, i::Integer)\n    @boundscheck checkbounds(s, i)\n    GC.@preserve s unsafe_load(s.ptr + i - 1)\nend\nBase.String(x::PointerString) = unsafe_string(x.ptr, x.len)\n\nfunction reverseescapechar(b)\n    b == UInt8('\"')     && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('b')  && return UInt8('\\b')\n    b == UInt8('f')  && return UInt8('\\f')\n    b == UInt8('n')  && return UInt8('\\n')\n    b == UInt8('r')  && return UInt8('\\r')\n    b == UInt8('t')  && return UInt8('\\t')\n    return 0x00\nend\n\nutf16_is_surrogate(c::UInt16) = (c & 0xf800) == 0xd800\nutf16_get_supplementary(lead::UInt16, trail::UInt16) = Char(UInt32(lead-0xd7f7)<<10 + trail)\n\ncharvalue(b) = (UInt8('0') <= b < UInt8('9'))         ? b - UInt8('0')            :\n               (UInt8('a') <= b <= UInt8('f')) ? b - (UInt8('a') - 0x0a) :\n               (UInt8('A') <= b <= UInt8('F'))       ? b - (UInt8('A') - 0x0a)    :\n               throw(ArgumentError(\"JSON invalid unicode hex value\"))\n\n@noinline invalid_escape(str) = throw(ArgumentError(\"encountered invalid escape character in json string: \\\"$(String(str))\\\"\"))\n@noinline unescaped_control(b) = throw(ArgumentError(\"encountered unescaped control character in json: '$(Char(b))'\"))\n\nfunction unescape(s)\n    n = ncodeunits(s)\n    buf = Base.StringVector(n)\n    len = 1\n    i = 1\n    @inbounds begin\n        while i <= n\n            b = codeunit(s, i)\n            if b == UInt8('\\\\')\n                i += 1\n                i > n && invalid_escape(s)\n                b = codeunit(s, i)\n                if b == UInt8('u')\n                    c = 0x0000\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    if utf16_is_surrogate(c)\n                        i += 3\n                        i > n && invalid_escape(s)\n                        c2 = 0x0000\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        ch = utf16_get_supplementary(c, c2)\n                    else\n                        ch = Char(c)\n                    end\n                    st = codeunits(Base.string(ch))\n                    for j = 1:length(st)-1\n                        @inbounds buf[len] = st[j]\n                        len += 1\n                    end\n                    b = st[end]\n                else\n                    b = reverseescapechar(b)\n                    b == 0x00 && invalid_escape(s)\n                end\n            elseif b < UInt8(' ')\n                unescaped_control(b)\n            end\n            @inbounds buf[len] = b\n            len += 1\n            i += 1\n        end\n    end\n    resize!(buf, len - 1)\n    return String(buf)\nend\n"}, "files_after": {"src/strings.jl": "struct PointerString <: AbstractString\n    ptr::Ptr{UInt8}\n    len::Int\nend\n\nfunction Base.hash(s::PointerString, h::UInt)\n    h += Base.memhash_seed\n    ccall(Base.memhash, UInt, (Ptr{UInt8}, Csize_t, UInt32), s.ptr, s.len, h % UInt32) + h\nend\n\nimport Base: ==\nfunction ==(x::String, y::PointerString)\n    sizeof(x) == y.len && ccall(:memcmp, Cint, (Ptr{UInt8}, Ptr{UInt8}, Csize_t), pointer(x), y.ptr, y.len) == 0\nend\n==(y::PointerString, x::String) = x == y\n\nBase.ncodeunits(s::PointerString) = s.len\n@inline function Base.codeunit(s::PointerString, i::Integer)\n    @boundscheck checkbounds(s, i)\n    GC.@preserve s unsafe_load(s.ptr + i - 1)\nend\nBase.String(x::PointerString) = unsafe_string(x.ptr, x.len)\n\nfunction reverseescapechar(b)\n    b == UInt8('\"')     && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('b')  && return UInt8('\\b')\n    b == UInt8('f')  && return UInt8('\\f')\n    b == UInt8('n')  && return UInt8('\\n')\n    b == UInt8('r')  && return UInt8('\\r')\n    b == UInt8('t')  && return UInt8('\\t')\n    return 0x00\nend\n\nutf16_is_surrogate(c::UInt16) = (c & 0xf800) == 0xd800\nutf16_get_supplementary(lead::UInt16, trail::UInt16) = Char(UInt32(lead-0xd7f7)<<10 + trail)\n\ncharvalue(b) = (UInt8('0') <= b <= UInt8('9')) ? b - UInt8('0') :\n               (UInt8('a') <= b <= UInt8('f')) ? b - (UInt8('a') - 0x0a) :\n               (UInt8('A') <= b <= UInt8('F')) ? b - (UInt8('A') - 0x0a) :\n               throw(ArgumentError(\"JSON invalid unicode hex value\"))\n\n@noinline invalid_escape(str) = throw(ArgumentError(\"encountered invalid escape character in json string: \\\"$(String(str))\\\"\"))\n@noinline unescaped_control(b) = throw(ArgumentError(\"encountered unescaped control character in json: '$(Char(b))'\"))\n\nfunction unescape(s)\n    n = ncodeunits(s)\n    buf = Base.StringVector(n)\n    len = 1\n    i = 1\n    @inbounds begin\n        while i <= n\n            b = codeunit(s, i)\n            if b == UInt8('\\\\')\n                i += 1\n                i > n && invalid_escape(s)\n                b = codeunit(s, i)\n                if b == UInt8('u')\n                    c = 0x0000\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    i += 1\n                    i > n && invalid_escape(s)\n                    b = codeunit(s, i)\n                    c = (c << 4) + charvalue(b)\n                    if utf16_is_surrogate(c)\n                        i += 3\n                        i > n && invalid_escape(s)\n                        c2 = 0x0000\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        i += 1\n                        i > n && invalid_escape(s)\n                        b = codeunit(s, i)\n                        c2 = (c2 << 4) + charvalue(b)\n                        ch = utf16_get_supplementary(c, c2)\n                    else\n                        ch = Char(c)\n                    end\n                    st = codeunits(Base.string(ch))\n                    for j = 1:length(st)-1\n                        @inbounds buf[len] = st[j]\n                        len += 1\n                    end\n                    b = st[end]\n                else\n                    b = reverseescapechar(b)\n                    b == 0x00 && invalid_escape(s)\n                end\n            elseif b < UInt8(' ')\n                unescaped_control(b)\n            end\n            @inbounds buf[len] = b\n            len += 1\n            i += 1\n        end\n    end\n    resize!(buf, len - 1)\n    return String(buf)\nend\n"}, "source_files_changed": ["src/strings.jl"], "test_files_changed": [], "lines_changed": 4, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "0a3419c3822c6fa5a7f9c36b07e1e34a83976518", "parent_sha": "96413f9ce931ab2abce6766623f7d878cabb707e", "commit_message": "A few fixes", "commit_date": "2019-06-08T21:53:51-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": "read", "signature": null, "confidence": 0.75}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\nstruct Struct <: DataType end\nstruct Mutable <: DataType end\n\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[2]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[1]\n    end\n    return julianame\nend\n\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n# \"interface\" type: fields are internal, json representation is accessible via transform/interface functions\nabstract type JSONType end\nstruct ObjectType <: JSONType end\nstruct ArrayType <: JSONType end\nstruct StringType <: JSONType end\nstruct NumberType <: JSONType end\nstruct BoolType <: JSONType end\nstruct NullType <: JSONType end\n\n# \"abstract\" type: json representation via a concrete subtype, json includes subtype key-value to signal concrete subtype\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(String(bytes), T)\n\nfunction read(str::String, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{Symbol, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? T(unescape(PointerString(ptr, strlen))) : T(unsafe_string(ptr, strlen))\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nStructType(::Type{Char}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{Char})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds x = Char(buf[pos])\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    if b != UInt8('\"')\n        error = InvalidChar\n        @goto invalid\n    end\n    return pos + 1, x\n\n@label invalid\n    invalid(error, buf, pos, Char)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, T(true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, T(false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, T()\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Integer}) = NumberType()\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(x::T) where {T <: Real} = T\nnumbertype(x) = Float64\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, T(x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\n\nread(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\nfunction read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            return pos + 1, vals\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\n\nfunction read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        return pos + 1, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? unescape(PointerString(pointer(buf, keypos), keylen)) : unsafe_string(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, y = read(Struct(), buf, pos, len, b, Any)\n        x[key] = y\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            return pos + 1, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        @inbounds b = buf[pos]\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend", "src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    for i = 1:n\n        if isdefined(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n            if i < n\n                @writechar ','\n            end\n        else\n            buf, pos, len = write(NullType(), buf, pos, len, x)\n        end\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\nstruct Struct <: DataType end\nstruct Mutable <: DataType end\n\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[2]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[1]\n    end\n    return julianame\nend\n\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n# \"interface\" type: fields are internal, json representation is accessible via transform/interface functions\nabstract type JSONType end\nstruct ObjectType <: JSONType end\nstruct ArrayType <: JSONType end\nstruct StringType <: JSONType end\nstruct NumberType <: JSONType end\nstruct BoolType <: JSONType end\nstruct NullType <: JSONType end\n\n# \"abstract\" type: json representation via a concrete subtype, json includes subtype key-value to signal concrete subtype\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(String(bytes), T)\n\nfunction read(str::String, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{Symbol, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? T(unescape(PointerString(ptr, strlen))) : T(unsafe_string(ptr, strlen))\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nStructType(::Type{Char}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{Char})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds x = Char(buf[pos])\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    if b != UInt8('\"')\n        error = InvalidChar\n        @goto invalid\n    end\n    return pos + 1, x\n\n@label invalid\n    invalid(error, buf, pos, Char)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, T(true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, T(false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, T()\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Integer}) = NumberType()\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(x::T) where {T <: Real} = T\nnumbertype(x) = Float64\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, T(x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\n\nread(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\nfunction read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            return pos + 1, vals\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\n\nread(::ObjectType, buf, pos, len, b, ::Type{T}) where {T <: AbstractDict} = read(ObjectType(), buf, pos, len, b, T, keytype(T), valtype(T))\nfunction read(::ObjectType, buf, pos, len, b, ::Type{T}, ::Type{K}=Any, ::Type{V}=Any) where {T, K, V}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        return pos + 1, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? unescape(PointerString(pointer(buf, keypos), keylen)) : unsafe_string(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, y = read(StructType(V), buf, pos, len, b, V)\n        x[K(key)] = y\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            return pos + 1, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        @inbounds b = buf[pos]\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend", "src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    for i = 1:n\n        if isassigned(x, i)\n            @inbounds y = x[i]\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n            if i < n\n                @writechar ','\n            end\n        else\n            buf, pos, len = write(NullType(), buf, pos, len, x)\n        end\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nwrite(::BoolType, buf, pos, len, x) = write(BoolType(), buf, pos, len, Bool(x))\nfunction write(::BoolType, buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y::Integer)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nwrite(::NumberType, buf, pos, len, x) = write(NumberType(), buf, pos, len, Float64(x))\nfunction write(::NumberType, buf, pos, len, x::Float64)\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(Base.string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nwrite(::StringType, buf, pos, len, x) = write(StringType(), buf, pos, len, Base.string(x))\nfunction write(::StringType, buf, pos, len, x::String)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n"}, "source_files_changed": ["src/structs.jl", "src/write.jl"], "test_files_changed": [], "lines_changed": 49, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "96413f9ce931ab2abce6766623f7d878cabb707e", "parent_sha": "583dca9000accac25d2fc335b3ea97a7a63301b0", "commit_message": "Fix char writing again", "commit_date": "2019-06-08T18:32:23-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            i > 1 && @writechar ','\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    for i = 1:n\n        if isdefined(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n            if i < n\n                @writechar ','\n            end\n        else\n            buf, pos, len = write(NullType(), buf, pos, len, x)\n        end\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend"}, "files_after": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    afterfirst = false\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            afterfirst && @writechar ','\n            afterfirst = true\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    for i = 1:n\n        if isdefined(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n            if i < n\n                @writechar ','\n            end\n        else\n            buf, pos, len = write(NullType(), buf, pos, len, x)\n        end\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 4, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "583dca9000accac25d2fc335b3ea97a7a63301b0", "parent_sha": "c78aeaab09e5546a4a51470dc4653dc99cf8ce8d", "commit_message": "write commas before a key-value pair, not after in case we don't end up writing any more", "commit_date": "2019-06-08T18:24:48-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.6}, "files_before": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            i < N && @writechar ','\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        @show StructType(v)\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    for i = 1:n\n        if isdefined(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n            if i < n\n                @writechar ','\n            end\n        else\n            buf, pos, len = write(NullType(), buf, pos, len, x)\n        end\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend"}, "files_after": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            i > 1 && @writechar ','\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                @writechar ','\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    for i = 1:n\n        if isdefined(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n            if i < n\n                @writechar ','\n            end\n        else\n            buf, pos, len = write(NullType(), buf, pos, len, x)\n        end\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 5, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "c78aeaab09e5546a4a51470dc4653dc99cf8ce8d", "parent_sha": "3e93da00c4cfac8361cc15b5e74252f9c149c2f7", "commit_message": "debug", "commit_date": "2019-06-08T08:43:01-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.6}, "files_before": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            i < N && @writechar ','\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend"}, "files_after": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            i < N && @writechar ','\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        @show StructType(v)\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    for i = 1:n\n        if isdefined(x, i)\n            buf, pos, len = write(StructType(y), buf, pos, len, y)\n            if i < n\n                @writechar ','\n            end\n        else\n            buf, pos, len = write(NullType(), buf, pos, len, x)\n        end\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 15, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "3e93da00c4cfac8361cc15b5e74252f9c149c2f7", "parent_sha": "dfd9153c5d3a564ab1fdd86f48c99439210dad3c", "commit_message": "remove debugging", "commit_date": "2019-06-08T08:20:50-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            @show String(copy(buf)), pos, len\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @show String(copy(buf)), pos, len\n            @writechar ':'\n            @show String(copy(buf)), pos, len\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            @show String(copy(buf)), pos, len\n            i < N && @writechar ','\n            @show String(copy(buf)), pos, len\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend"}, "files_after": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            i < N && @writechar ','\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 5, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "dfd9153c5d3a564ab1fdd86f48c99439210dad3c", "parent_sha": "627d8bdedecb37ad6e90c49e981526e0580194a5", "commit_message": "Fix long value writing", "commit_date": "2019-06-08T08:19:11-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "_isempty", "signature": null, "confidence": 0.6}, "files_before": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len)\n    new = Mmap.mmap(Vector{UInt8}, trunc(Int, len * 1.25))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            i < N && @writechar ','\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend"}, "files_after": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len, n)\n    new = Mmap.mmap(Vector{UInt8}, max(n, trunc(Int, len * 1.25)))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len, pos + $n - 1)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            @show String(copy(buf)), pos, len\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @show String(copy(buf)), pos, len\n            @writechar ':'\n            @show String(copy(buf)), pos, len\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            @show String(copy(buf)), pos, len\n            i < N && @writechar ','\n            @show String(copy(buf)), pos, len\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 11, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "627d8bdedecb37ad6e90c49e981526e0580194a5", "parent_sha": "710ffc4b67df52d14a7291bc8bf62237b6810f6c", "commit_message": "fix", "commit_date": "2019-06-08T08:00:58-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.6}, "files_before": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return SubString(String(buf), 1, pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len)\n    new = Mmap.mmap(Vector{UInt8}, trunc(Int, len * 1.25))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            i < N && @writechar ','\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend"}, "files_after": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return unsafe_string(pointer(buf), pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len)\n    new = Mmap.mmap(Vector{UInt8}, trunc(Int, len * 1.25))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            i < N && @writechar ','\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "710ffc4b67df52d14a7291bc8bf62237b6810f6c", "parent_sha": "dc797f6d8d2e21515ce5d7c70bc1d7d83cad1630", "commit_message": "fix", "commit_date": "2019-06-08T07:50:41-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/structs.jl", "target_symbol": "read", "signature": null, "confidence": 0.6}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\nstruct Struct <: DataType end\nstruct Mutable <: DataType end\n\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[2]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[1]\n    end\n    return julianame\nend\n\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n# \"interface\" type: fields are internal, json representation is accessible via transform/interface functions\nabstract type JSONType end\nstruct ObjectType <: JSONType end\nstruct ArrayType <: JSONType end\nstruct StringType <: JSONType end\nstruct NumberType <: JSONType end\nstruct BoolType <: JSONType end\nstruct NullType <: JSONType end\n\n# \"abstract\" type: json representation via a concrete subtype, json includes subtype key-value to signal concrete subtype\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(String(bytes), T)\n\nfunction read(str::String, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{Symbol, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? T(unescape(PointerString(ptr, strlen))) : T(unsafe_string(ptr, strlen))\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nStructType(::Type{Char}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{Char})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds x = Char(buf[pos])\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    if b != UInt8('\"')\n        error = InvalidChar\n        @goto invalid\n    end\n    return pos + 1, x\n\n@label invalid\n    invalid(error, buf, pos, Char)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, T(true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, T(false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, T()\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Integer}) = NumberType()\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(x::T) where {T <: Real} = T\nnumbertype(x) = Float64\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, T(x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\n\nread(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\nfunction read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            return pos + 1, vals\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\n\nfunction read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        return pos + 1, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, y = read(Struct(), buf, pos, len, b, Any)\n        x[key] = y\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            return pos + 1, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        @inbounds b = buf[pos]\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\nstruct Struct <: DataType end\nstruct Mutable <: DataType end\n\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[2]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[1]\n    end\n    return julianame\nend\n\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n# \"interface\" type: fields are internal, json representation is accessible via transform/interface functions\nabstract type JSONType end\nstruct ObjectType <: JSONType end\nstruct ArrayType <: JSONType end\nstruct StringType <: JSONType end\nstruct NumberType <: JSONType end\nstruct BoolType <: JSONType end\nstruct NullType <: JSONType end\n\n# \"abstract\" type: json representation via a concrete subtype, json includes subtype key-value to signal concrete subtype\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(String(bytes), T)\n\nfunction read(str::String, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{Symbol, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? T(unescape(PointerString(ptr, strlen))) : T(unsafe_string(ptr, strlen))\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nStructType(::Type{Char}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{Char})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds x = Char(buf[pos])\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    if b != UInt8('\"')\n        error = InvalidChar\n        @goto invalid\n    end\n    return pos + 1, x\n\n@label invalid\n    invalid(error, buf, pos, Char)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, T(true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, T(false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, T()\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Integer}) = NumberType()\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(x::T) where {T <: Real} = T\nnumbertype(x) = Float64\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, T(x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\n\nread(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\nfunction read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            return pos + 1, vals\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\n\nfunction read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        return pos + 1, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? unescape(PointerString(pointer(buf, keypos), keylen)) : unsafe_string(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, y = read(Struct(), buf, pos, len, b, Any)\n        x[key] = y\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            return pos + 1, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        @inbounds b = buf[pos]\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "dc797f6d8d2e21515ce5d7c70bc1d7d83cad1630", "parent_sha": "0a0a163fc4f917de9e5ca4a2ca9fe6efefa4198d", "commit_message": "Fix write", "commit_date": "2019-06-08T07:40:51-06:00", "action": {"type": "REMOVE_METHOD", "target_file": "src/write.jl", "target_symbol": "write", "signature": null, "confidence": 0.85}, "files_before": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos = write(StructType(T), buf, 1, length(buf), obj)\n    return SubString(String(buf), 1, pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len)\n    new = Mmap.mmap(Vector{UInt8}, trunc(Int, len * 1.25))\n    copyto!(buf, 1, new, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\nfunction write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            buf, pos = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            i < N && @writechar ','\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @writechar '\"'\n    return buf, pos\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos\nend"}, "files_after": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos, len = write(StructType(T), buf, 1, length(buf), obj)\n    return SubString(String(buf), 1, pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len)\n    new = Mmap.mmap(Vector{UInt8}, trunc(Int, len * 1.25))\n    copyto!(new, 1, buf, 1, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\n@inline function write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            i < N && @writechar ','\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos, len = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos, len = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos, len = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos, len = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos, len\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos, len = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos, len\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos, len\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos, len\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n, len\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @inbounds @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos, len\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos, len\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos, len\nend"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 44, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "0a0a163fc4f917de9e5ca4a2ca9fe6efefa4198d", "parent_sha": "981e60711f69e59d41c09d77a82c753f26f9ef9a", "commit_message": "fix realloc", "commit_date": "2019-06-08T06:43:28-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "_isempty", "signature": null, "confidence": 0.6}, "files_before": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos = write(StructType(T), buf, 1, length(buf), obj)\n    return SubString(String(buf), 1, pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len)\n    new = Mmap.mmap(Vector{UInt8}, trunc(Int, len * 1.25))\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\nfunction write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            buf, pos = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            i < N && @writechar ','\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @writechar '\"'\n    return buf, pos\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos\nend"}, "files_after": {"src/write.jl": "write(io::IO, obj) = Base.write(io, write(obj))\n\ndefaultminimum(::Union{Nothing, Missing}) = 4\ndefaultminimum(::Number) = 20\ndefaultminimum(x::Bool) = x ? 4 : 5\ndefaultminimum(x) = sizeof(x)\n\nfunction write(obj::T) where {T}\n    len = defaultminimum(obj)\n    buf = len < Mmap.PAGESIZE ? zeros(UInt8, len) : Mmap.mmap(Vector{UInt8}, len)\n    buf, pos = write(StructType(T), buf, 1, length(buf), obj)\n    return SubString(String(buf), 1, pos - 1)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len)\n    new = Mmap.mmap(Vector{UInt8}, trunc(Int, len * 1.25))\n    copyto!(buf, 1, new, len)\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\nfunction write(::Union{Struct, Mutable, AbstractType}, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            buf, pos = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n            i < N && @writechar ','\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos = write(StringType(), buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos = write(StructType(fieldtype(T, i)), buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos\nend\n\nfunction write(::ObjectType, buf, pos, len, x::T) where {T}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos = write(StringType(), buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos = write(StructType(v), buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos\nend\n\nfunction write(::ArrayType, buf, pos, len, x::T) where {T}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos = write(StructType(y), buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos\nend\n\nfunction write(::NullType, buf, pos, len, x)\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos\nend\n\nfunction write(::BoolType, buf, pos, len, x)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos\nend\n\n# adapted from base/intfuncs.jl\nfunction write(::NumberType, buf, pos, len, y)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(::StringType, buf, pos, len, x)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @writechar '\"'\n    return buf, pos\nend\n\nfunction write(::StringType, buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos\nend\n\nfunction write(::NumberType, buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos\nend"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 1, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "981e60711f69e59d41c09d77a82c753f26f9ef9a", "parent_sha": "b77835c8fd304c3576f9c6542832e04ead8bf285", "commit_message": "enhance NumberType", "commit_date": "2019-06-08T06:34:27-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/structs.jl", "target_symbol": "numbertype", "signature": null, "confidence": 0.85}, "files_before": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\nstruct Struct <: DataType end\nstruct Mutable <: DataType end\n\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[2]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[1]\n    end\n    return julianame\nend\n\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n# \"interface\" type: fields are internal, json representation is accessible via transform/interface functions\nabstract type JSONType end\nstruct ObjectType <: JSONType end\nstruct ArrayType <: JSONType end\nstruct StringType <: JSONType end\nstruct NumberType <: JSONType end\nstruct BoolType <: JSONType end\nstruct NullType <: JSONType end\n\n# \"abstract\" type: json representation via a concrete subtype, json includes subtype key-value to signal concrete subtype\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(String(bytes), T)\n\nfunction read(str::String, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{Symbol, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? T(unescape(PointerString(ptr, strlen))) : T(unsafe_string(ptr, strlen))\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nStructType(::Type{Char}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{Char})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds x = Char(buf[pos])\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    if b != UInt8('\"')\n        error = InvalidChar\n        @goto invalid\n    end\n    return pos + 1, x\n\n@label invalid\n    invalid(error, buf, pos, Char)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, T(true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, T(false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, T()\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Integer}) = NumberType()\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractFloat}) = NumberType()\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    float, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, T(float)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\n\nread(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\nfunction read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            return pos + 1, vals\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\n\nfunction read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        return pos + 1, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, y = read(Struct(), buf, pos, len, b, Any)\n        x[key] = y\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            return pos + 1, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        @inbounds b = buf[pos]\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend"}, "files_after": {"src/structs.jl": "abstract type StructType end\n\n# \"Data\" type: fields are json keys, field values are json values; use names, omitempties, excludes\nabstract type DataType <: StructType end\nstruct Struct <: DataType end\nstruct Mutable <: DataType end\n\nStructType(::Type{T}) where {T} = Struct()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\n\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[2]\n    end\n    return jsonname\nend\n\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[1]\n    end\n    return julianame\nend\n\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\n\n# \"interface\" type: fields are internal, json representation is accessible via transform/interface functions\nabstract type JSONType end\nstruct ObjectType <: JSONType end\nstruct ArrayType <: JSONType end\nstruct StringType <: JSONType end\nstruct NumberType <: JSONType end\nstruct BoolType <: JSONType end\nstruct NullType <: JSONType end\n\n# \"abstract\" type: json representation via a concrete subtype, json includes subtype key-value to signal concrete subtype\nstruct AbstractType <: StructType end\n\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(String(bytes), T)\n\nfunction read(str::String, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Struct, buf, pos, len, b, U::Union)\n    try\n        return read(StructType(U.a), buf, pos, len, b, U.a)\n    catch e\n        return read(StructType(U.b), buf, pos, len, b, U.b)\n    end\nend\n\nfunction read(::Struct, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(ObjectType(), buf, pos, len, b, Dict{Symbol, Any})\n    elseif b == UInt8('[')\n        return read(ArrayType(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(StringType(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(NullType(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(BoolType(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nStructType(::Type{<:AbstractString}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? T(unescape(PointerString(ptr, strlen))) : T(unsafe_string(ptr, strlen))\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nStructType(::Type{Char}) = StringType()\n\nfunction read(::StringType, buf, pos, len, b, ::Type{Char})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds x = Char(buf[pos])\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    if b != UInt8('\"')\n        error = InvalidChar\n        @goto invalid\n    end\n    return pos + 1, x\n\n@label invalid\n    invalid(error, buf, pos, Char)\nend\n\nStructType(::Type{Bool}) = BoolType()\n\nfunction read(::BoolType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, T(true)\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, T(false)\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nStructType(::Type{Nothing}) = NullType()\nStructType(::Type{Missing}) = NullType()\n\nfunction read(::NullType, buf, pos, len, b, ::Type{T}) where {T}\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, T()\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nStructType(::Type{<:Integer}) = NumberType()\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractFloat}) = NumberType()\nnumbertype(x::T) where {T <: Real} = T\nnumbertype(x) = Float64\n\nfunction read(::NumberType, buf, pos, len, b, ::Type{T}) where {T}\n    x, code, pos = Parsers.typeparser(numbertype(T), buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, T(x)\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractArray}) = ArrayType()\n\nread(::ArrayType, buf, pos, len, b, ::Type{T}) where {T} = read(ArrayType(), buf, pos, len, b, T, Base.IteratorEltype(T) == Base.HasEltype() ? eltype(T) : Any)\nfunction read(::ArrayType, buf, pos, len, b, ::Type{T}, ::Type{eT}) where {T, eT}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    vals = Vector{eT}(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, T(vals)\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(eT), buf, pos, len, b, eT)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            return pos + 1, vals\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nStructType(::Type{<:AbstractDict}) = ObjectType()\n\nfunction read(::ObjectType, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        return pos + 1, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, y = read(Struct(), buf, pos, len, b, Any)\n        x[key] = y\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            return pos + 1, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read(::Mutable, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    x = T()\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    nms = names(T)\n    excl = excludes(T)\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        key = julianame(nms, key)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        ind = Base.fieldindex(T, key, false)\n        if ind > 0\n            FT = fieldtype(T, key)\n            pos, y = read(StructType(FT), buf, pos, len, b, FT)\n            if !symbolin(excl, key)\n                setfield!(x, key, y)\n            end\n        else\n            # read the unknown key's value, but ignore it\n            pos, _ = read(Struct(), buf, pos, len, b, Any)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Struct, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    N = fieldcount(T)\n    Base.@nexprs 32 i -> begin\n        pos, x_i = readvalue(buf, pos, len, fieldtype(T, i))\n        if N == i\n            return pos, Base.@ncall i T x\n        end\n    end\n    vals = []\n    for i = 33:N\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16,\n                  x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        @inbounds b = buf[pos]\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::AbstractType, buf, pos, len, b, ::Type{T}) where {T}\n    startpos = pos\n    startb = b\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        throw(ArgumentError(\"invalid json abstract type\"))\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    types = subtypes(T)\n    skey = subtypekey(T)\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        pos, val = read(Struct(), buf, pos, len, b, Any)\n        if key == skey\n            TT = types[Symbol(val)]\n            return read(StructType(TT), buf, startpos, len, startb, TT)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            throw(ArgumentError(\"invalid json abstract type: didn't find subtypekey\"))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend"}, "source_files_changed": ["src/structs.jl"], "test_files_changed": [], "lines_changed": 6, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "2a76a4e5350664c5f5e21c4b1a103f6ad7f0260e", "parent_sha": "b65018c9ec3c678f87c36fd50962f24c48aea181", "commit_message": "High-level APIs", "commit_date": "2019-06-04T17:21:59-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/read.jl", "target_symbol": "fromobject", "signature": null, "confidence": 0.85}, "files_before": {"src/read.jl": "abstract type StructType end\n\n# by default, assume json key-values are in right order, and just pass to T constructor\nstruct Ordered <: StructType end\n\n# mutable struct + setfield!\nstruct MutableSetField <: StructType end\n\nstruct AbstractType <: StructType end\n\nStructType(::Type{T}) where {T} = Ordered()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[2]\n    end\n    return jsonname\nend\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[1]\n    end\n    return julianame\nend\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nfunction read(str::String)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\n# fallback\nfromobject(::Ordered, ::Type{T}, obj) where {T} = obj\nfunction fromobject(::Ordered, ::Type{T}, obj::Object) where {T}\n    vals = values(obj)\n    return T(map(x->fromobject(StructType(fieldtype(T, x[1])), fieldtype(T, x[1]), x[2]), enumerate(vals))...)\nend\nfunction fromobject(::MutableSetField, ::Type{T}, obj::Object) where {T}\n    x = T()\n    nms = names(T)\n    excl = excludes(T)\n    for (k, v) in obj\n        k = julianame(nms, k)\n        ind = Base.fieldindex(T, k, false)\n        if ind > 0 && !symbolin(excl, k)\n            T = fieldtype(T, k)\n            setfield!(x, k, fromobject(StructType(T), T, v))\n        end\n    end\n    return x\nend\nfunction fromobject(::AbstractType, ::Type{T}, obj::Object) where {T}\n    TT = subtypes(T)[Symbol(get(obj, subtypekey(T)))]\n    return fromobject(StructType(TT), TT, obj)\nend\n\nfunction read(str::String, ::Type{T}) where {T}\n    if StructType(T) == AbstractType()\n        obj = read(str)\n        TT = subtypes(T)[Symbol(get(obj, subtypekey(T)))]\n        return fromobject(StructType(TT), TT, obj)\n    end\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Ordered, buf, pos, len, b, U::Union)\n    try\n        return read(Ordered(), buf, pos, len, b, U.a)\n    catch e\n        return read(Ordered(), buf, pos, len, b, U.b)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any})\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                @inbounds tape[tapeidx] = INT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(Ordered(), buf, pos, len, b, NamedTuple)\n    elseif b == UInt8('[')\n        return read(Ordered(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(Ordered(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(Ordered(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(Ordered(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(Ordered(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? unescape(PointerString(ptr, strlen)) : unsafe_string(ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Char})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds x = Char(buf[pos])\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    if b != UInt8('\"')\n        error = InvalidChar\n        @goto invalid\n    end\n    return pos + 1, x\n\n@label invalid\n    invalid(error, buf, pos, Char)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Bool})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, true\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, false\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, T::Union{Type{Missing}, Type{Nothing}})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, T === Missing ? missing : nothing\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{T}) where {T <: AbstractFloat}\n    float, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, float\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = 0\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{NamedTuple})\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        return pos + 1, NamedTuple()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    keys = Symbol[]\n    vals = Any[]\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        push!(keys, escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen))\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, y = read(Ordered(), buf, pos, len, b, Any)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            return pos + 1, NamedTuple{Tuple(keys)}(Tuple(vals))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = 0\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{A}) where {A <: AbstractArray{T}} where {T}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    vals = A(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, vals\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(T), buf, pos, len, b, T)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            return pos + 1, vals\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, A)\nend\n", "src/write.jl": "_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len)\n    new = Mmap.mmap(Vector{UInt8}, trunc(Int, len * 1.25))\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\nfunction write(buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            buf, pos = write(buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos = write(buf, pos, len, _getfield(x, i))\n            i < N && @writechar ','\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos = write(buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos = write(buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::T) where {T <: AbstractDict}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos = write(buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos = write(buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::T) where {T <: Union{AbstractArray, AbstractSet, Tuple}}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos = write(buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::Union{Nothing, Missing})\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos\nend\n\n# adapted from base/intfuncs.jl\nfunction write(buf, pos, len, y::Number)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(buf, pos, len, x::AbstractString)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @writechar '\"'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos\nend"}, "files_after": {"src/read.jl": "abstract type StructType end\n\n# by default, assume json key-values are in right order, and just pass to T constructor\nstruct Ordered <: StructType end\n\n# mutable struct + setfield!\nstruct MutableSetField <: StructType end\n\nstruct AbstractType <: StructType end\n\nstruct FromObject <: StructType end\n\nStructType(::Type{T}) where {T} = Ordered()\nStructType(x::T) where {T} = StructType(T)\n# maps Julia struct field name to json key name: ((:field1, :json1), (:field2, :json2))\nnames(x::T) where {T} = names(T)\nnames(::Type{T}) where {T} = ()\nBase.@pure function julianame(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, jsonname::Symbol)\n    for nm in names\n        nm[2] === jsonname && return nm[2]\n    end\n    return jsonname\nend\nBase.@pure function jsonname(names::Tuple{Vararg{Tuple{Symbol, Symbol}}}, julianame::Symbol)\n    for nm in names\n        nm[1] === julianame && return nm[1]\n    end\n    return julianame\nend\n# Julia struct field names as symbols that will be ignored when reading, and never written\nexcludes(x::T) where {T} = excludes(T)\nexcludes(::Type{T}) where {T} = ()\n# Julia struct field names as symbols \nomitempties(x::T) where {T} = omitempties(T)\nomitempties(::Type{T}) where {T} = ()\nsubtypekey(x::T) where {T} = subtypekey(T)\nsubtypekey(::Type{T}) where {T} = :type\nsubtypes(x::T) where {T} = subtypes(T)\nsubtypes(::Type{T}) where {T} = NamedTuple()\n\nread(io::IO) = read(Base.read(io, String))\nread(bytes::Vector{UInt8}) = read(String(bytes))\n\nfunction read(str::String)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\n# fallback\nfromobject(::Type{T}, obj) where {T} = fromobject(StructType(T), T, obj)\nfromobject(::Ordered, ::Type{T}, obj) where {T} = obj\nfunction fromobject(::Ordered, ::Type{T}, obj::Object) where {T}\n    vals = values(obj)\n    return T(map(x->fromobject(StructType(fieldtype(T, x[1])), fieldtype(T, x[1]), x[2]), enumerate(vals))...)\nend\nfunction fromobject(::MutableSetField, ::Type{T}, obj::Object) where {T}\n    x = T()\n    nms = names(T)\n    excl = excludes(T)\n    for (k, v) in obj\n        k = julianame(nms, k)\n        ind = Base.fieldindex(T, k, false)\n        if ind > 0 && !symbolin(excl, k)\n            T = fieldtype(T, k)\n            setfield!(x, k, fromobject(StructType(T), T, v))\n        end\n    end\n    return x\nend\nfunction fromobject(::AbstractType, ::Type{T}, obj::Object) where {T}\n    TT = subtypes(T)[Symbol(get(obj, subtypekey(T)))]\n    return fromobject(StructType(TT), TT, obj)\nend\n\nread(io::IO, ::Type{T}) where {T} = read(Base.read(io, String), T)\nread(bytes::Vector{UInt8}, ::Type{T}) where {T} = read(String(bytes), T)\n\nfunction read(str::String, ::Type{T}) where {T}\n    if StructType(T) == AbstractType()\n        obj = read(str)\n        TT = subtypes(T)[Symbol(get(obj, subtypekey(T)))]\n        return fromobject(StructType(TT), TT, obj)\n    elseif StructType(T) == FromObject()\n        return fromobject(T, read(str))\n    end\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Ordered, buf, pos, len, b, U::Union)\n    try\n        return read(Ordered(), buf, pos, len, b, U.a)\n    catch e\n        return read(Ordered(), buf, pos, len, b, U.b)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any})\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                @inbounds tape[tapeidx] = INT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(Ordered(), buf, pos, len, b, NamedTuple)\n    elseif b == UInt8('[')\n        return read(Ordered(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(Ordered(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(Ordered(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(Ordered(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(Ordered(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? unescape(PointerString(ptr, strlen)) : unsafe_string(ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Char})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds x = Char(buf[pos])\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    if b != UInt8('\"')\n        error = InvalidChar\n        @goto invalid\n    end\n    return pos + 1, x\n\n@label invalid\n    invalid(error, buf, pos, Char)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Bool})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, true\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, false\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, T::Union{Type{Missing}, Type{Nothing}})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, T === Missing ? missing : nothing\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{T}) where {T <: AbstractFloat}\n    float, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, float\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = 0\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{NamedTuple})\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        return pos + 1, NamedTuple()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    keys = Symbol[]\n    vals = Any[]\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        push!(keys, escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen))\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, y = read(Ordered(), buf, pos, len, b, Any)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            return pos + 1, NamedTuple{Tuple(keys)}(Tuple(vals))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = 0\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{A}) where {A <: AbstractArray{T}} where {T}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    vals = A(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, vals\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(T), buf, pos, len, b, T)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            return pos + 1, vals\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, A)\nend\n", "src/write.jl": "lower(x) = x\n\nwrite(io::IO, obj) = Base.write(io, write(obj))\n\nfunction write(obj)\n    buf = Mmap.mmap(Vector{UInt8}, sizeof(obj))\n    buf, pos = write(buf, 1, length(buf), lower(obj))\n    return String(buf)\nend\n\n_getfield(x, i) = isdefined(x, i) ? Core.getfield(x, i) : nothing\n_isempty(x, i) = !isdefined(x, i) || _isempty(getfield(x, i))\n_isempty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = isempty(x)\n_isempty(::Number) = false\n_isempty(::Nothing) = true\n_isempty(x) = false\n\n@noinline function realloc!(buf, len)\n    new = Mmap.mmap(Vector{UInt8}, trunc(Int, len * 1.25))\n    return new, length(new)\nend\n\nmacro check(n)\n    esc(quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len)\n        end\n    end)\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\n# generic object writing\nfunction write(buf, pos, len, x::T) where {T}\n    @writechar '{'\n    N = fieldcount(T)\n    N == 0 && @goto done\n    excl = excludes(T)\n    nms = names(T)\n    emp = omitempties(T)\n    Base.@nexprs 32 i -> begin\n        k_i = fieldname(T, i)\n        if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n            buf, pos = write(buf, pos, len, jsonname(nms, k_i))\n            @writechar ':'\n            buf, pos = write(buf, pos, len, _getfield(x, i))\n            i < N && @writechar ','\n        end\n        N == i && @goto done\n    end\n    if N > 32\n        for i = 33:N\n            k_i = fieldname(T, i)\n            if !symbolin(excl, k_i) && (!symbolin(emp, k_i) || !_isempty(x, i))\n                buf, pos = write(buf, pos, len, jsonname(nms, k_i))\n                @writechar ':'\n                buf, pos = write(buf, pos, len, _getfield(x, i))\n                i < N && @writechar ','\n            end\n        end\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::T) where {T <: AbstractDict}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in x\n        buf, pos = write(buf, pos, len, Base.string(k))\n        @writechar ':'\n        buf, pos = write(buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::T) where {T <: Union{AbstractArray, AbstractSet, Tuple}}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos = write(buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::Union{Nothing, Missing})\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos\nend\n\n# adapted from base/intfuncs.jl\nfunction write(buf, pos, len, y::Number)\n    x, neg = Base.split_sign(y)\n    n = i = neg + ndigits(x, base=10, pad=1)\n    @check i\n    while i > neg\n        @inbounds buf[pos + i - 1] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @inbounds @writechar UInt8('-')\n    end\n    return buf, pos + n\nend\n\nconst NEEDESCAPE = Set(map(UInt8, ('\"', '\\\\', '\\b', '\\f', '\\n', '\\r', '\\t')))\n\nfunction escapechar(b)\n    b == UInt8('\"')  && return UInt8('\"')\n    b == UInt8('\\\\') && return UInt8('\\\\')\n    b == UInt8('\\b') && return UInt8('b')\n    b == UInt8('\\f') && return UInt8('f')\n    b == UInt8('\\n') && return UInt8('n')\n    b == UInt8('\\r') && return UInt8('r')\n    b == UInt8('\\t') && return UInt8('t')\n    return 0x00\nend\n\niscntrl(c::Char) = c <= '\\x1f' || '\\x7f' <= c <= '\\u9f'\nfunction escaped(b)\n    if b == UInt8('/')\n        return [UInt8('/')]\n    elseif b >= 0x80\n        return [b]\n    elseif b in NEEDESCAPE\n        return [UInt8('\\\\'), escapechar(b)]\n    elseif iscntrl(Char(b))\n        return UInt8[UInt8('\\\\'), UInt8('u'), Base.string(b, base=16, pad=4)...]\n    else\n        return [b]\n    end\nend\n\nconst ESCAPECHARS = [escaped(b) for b = 0x00:0xff]\nconst ESCAPELENS = [length(x) for x in ESCAPECHARS]\n\nfunction escapelength(str)\n    bytes = codeunits(str)\n    x = 0\n    @simd for i = 1:length(bytes)\n        @inbounds len = ESCAPELENS[bytes[i] + 0x01]\n        x += len\n    end\n    return x\nend\n\nfunction write(buf, pos, len, x::AbstractString)\n    sz = sizeof(x)\n    el = escapelength(x)\n    @check (el + 2)\n    @writechar '\"'\n    bytes = codeunits(x)\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[bytes[i] + 0x01]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = bytes[i]\n            pos += 1\n        end\n    end\n    @writechar '\"'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::Symbol)\n    ptr = Base.unsafe_convert(Ptr{UInt8}, x)\n    slen = ccall(:strlen, Csize_t, (Cstring,), ptr)\n    @check (slen + 2)\n    @inbounds @writechar '\"'\n    for i = 1:slen\n        @inbounds @writechar unsafe_load(ptr, i)\n    end\n    @inbounds @writechar '\"'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::T) where {T <: Base.IEEEFloat}\n    if !isfinite(x)\n        @writechar 'n' 'u' 'l' 'l'\n        return buf, pos\n    end\n    bytes = codeunits(string(x))\n    sz = sizeof(bytes)\n    @check sz\n    for i = 1:sz\n        @inbounds @writechar bytes[i]\n    end\n\n    return buf, pos\nend"}, "source_files_changed": ["src/read.jl", "src/write.jl"], "test_files_changed": [], "lines_changed": 21, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "21c544ba1f13a319b9d97b89fdb3dd67759832af", "parent_sha": "d6b260123cf404a85d03823d493e7fcc40213d86", "commit_message": "updates for write", "commit_date": "2019-06-04T00:45:09-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/JSON3.jl", "target_symbol": "writechar", "signature": null, "confidence": 0.75}, "files_before": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object <: AbstractDict{Symbol, Any}\n    buf::Base.CodeUnits{UInt8,String}\n    tape::Vector{UInt64}\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(2), 0])\n\nstruct Array{T} <: AbstractVector{T}\n    buf::Base.CodeUnits{UInt8,String}\n    tape::Vector{UInt64}\nend\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-10):min(end, pos+10)]))\n\"\"\"))\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\n\nend # module\n", "src/write.jl": "@noinline function realloc!(buf, len)\n    new = Mmap.mmap(Vector{UInt8}, trunc(Int, len * 1.25))\n    return new, length(new)\nend\n\nmacro writechar(chars...)\n    block = quote\n        if (pos + $(length(chars) - 1) > len\n            buf, len = realloc!(buf, len)\n        end\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    return block\nend\n\nfunction write(buf, pos, len, x::T) where {T <: AbstractDict}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in obj\n        buf, pos = write(buf, pos, len, string(k))\n        @writechar ':'\n        buf, pos = write(buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::T) where {T <: Union{AbstractArray, AbstractSet, Tuple}}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos = write(buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::Union{Nothing, Missing})\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::Number)\n\nend\n"}, "files_after": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nfunction __init__()\n    # Threads.resize_nthreads!()\n    return\nend\n\nstruct Object <: AbstractDict{Symbol, Any}\n    buf::Base.CodeUnits{UInt8,String}\n    tape::Vector{UInt64}\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(2), 0])\n\nstruct Array{T} <: AbstractVector{T}\n    buf::Base.CodeUnits{UInt8,String}\n    tape::Vector{UInt64}\nend\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-10):min(end, pos+10)]))\n\"\"\"))\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(obj::Object, ::Type{T}, key, default::T)::T where {T}\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\ninclude(\"read.jl\")\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\ninclude(\"write.jl\")\n\nend # module\n", "src/write.jl": "@noinline function realloc!(buf, len)\n    new = Mmap.mmap(Vector{UInt8}, trunc(Int, len * 1.25))\n    return new, length(new)\nend\n\nmacro check(n)\n    quote\n        if (pos + $n - 1) > len\n            buf, len = realloc!(buf, len)\n        end\n    end\nend\n\nmacro writechar(chars...)\n    block = quote\n        @boundscheck @check($(length(chars)))\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    #println(macroexpand(@__MODULE__, block))\n    return esc(block)\nend\n\nfunction write(buf, pos, len, x::T) where {T <: AbstractDict}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in obj\n        buf, pos = write(buf, pos, len, string(k))\n        @writechar ':'\n        buf, pos = write(buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::T) where {T <: Union{AbstractArray, AbstractSet, Tuple}}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos = write(buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::Union{Nothing, Missing})\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos\nend\n\nfunction write(buf, pos, len, y::Number)\n    x, neg = Base.split_sign(y)\n    i = neg + ndigits(x, base=10, pad=1)\n    pos += i\n    while i > neg\n        @inbounds buf[i] = 48 + rem(x, 10)\n        x = oftype(x, div(x, 10))\n        i -= 1\n    end\n    if neg\n        @writechar UInt8('-')\n    end\n    return buf, pos\nend\n\n"}, "source_files_changed": ["src/JSON3.jl", "src/write.jl"], "test_files_changed": [], "lines_changed": 37, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "d6b260123cf404a85d03823d493e7fcc40213d86", "parent_sha": "c491cd0a08e30dcd24efa0646898265d838fd838", "commit_message": "start write functionality", "commit_date": "2019-06-03T23:15:41-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/write.jl", "target_symbol": "writechar", "signature": null, "confidence": 0.85}, "files_before": {}, "files_after": {"src/write.jl": "@noinline function realloc!(buf, len)\n    new = Mmap.mmap(Vector{UInt8}, trunc(Int, len * 1.25))\n    return new, length(new)\nend\n\nmacro writechar(chars...)\n    block = quote\n        if (pos + $(length(chars) - 1) > len\n            buf, len = realloc!(buf, len)\n        end\n    end\n    for c in chars\n        push!(block.args, quote\n            @inbounds buf[pos] = UInt8($c)\n            pos += 1\n        end)\n    end\n    return block\nend\n\nfunction write(buf, pos, len, x::T) where {T <: AbstractDict}\n    @writechar '{'\n    n = length(x)\n    i = 1\n    for (k, v) in obj\n        buf, pos = write(buf, pos, len, string(k))\n        @writechar ':'\n        buf, pos = write(buf, pos, len, v)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n\n@label done\n    @writechar '}'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::T) where {T <: Union{AbstractArray, AbstractSet, Tuple}}\n    @writechar '['\n    n = length(x)\n    i = 1\n    for y in x\n        buf, pos = write(buf, pos, len, y)\n        if i < n\n            @writechar ','\n        end\n        i += 1\n    end\n    @writechar ']'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::Union{Nothing, Missing})\n    @writechar 'n' 'u' 'l' 'l'\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::Bool)\n    if x\n        @writechar 't' 'r' 'u' 'e'\n    else\n        @writechar 'f' 'a' 'l' 's' 'e'\n    end\n    return buf, pos\nend\n\nfunction write(buf, pos, len, x::Number)\n\nend\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 71, "is_valid": false, "validation_errors": ["Julia syntax error in src/write.jl: Parse error: $(Expr(:error, \"missing comma or ) in argument list\"))"]}
{"repo": "JSON3.jl", "commit_sha": "c491cd0a08e30dcd24efa0646898265d838fd838", "parent_sha": "c896cbce02435989de420d8ee116c2a9ef4cce9a", "commit_message": "More work on AbstractType", "commit_date": "2019-05-23T22:41:36-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/read.jl", "target_symbol": "fromobject", "signature": null, "confidence": 0.75}, "files_before": {"src/read.jl": "# by default, assume json key-values are in right order, and just pass to T constructor\n# mutable struct + setfield!\n# keyword args constructor\nabstract type StructType end\nstruct Ordered <: StructType end\nstruct MutableSetField <: StructType end\nstruct AbstractType <: StructType end\n\nStructType(T) = Ordered()\nnames(T) = NamedTuple()\nexcludes(T) = NamedTuple()\nsubtypekey(T) = :type\nsubtypes(T) = NamedTuple()\n\nfunction read(str::String)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfromobject(::Ordered, ::Type{T}, obj) where {T} = T((v for (k, v) in obj if k != :type)...)\nfunction fromobject(::MutableSetField, ::Type{T}, obj) where {T}\n    x = T()\n    nms = names(T)\n    excl = excludes(T)\n    for (k, v) in obj\n        k = get(nms, k, k)\n        ind = Base.fieldindex(T, k, false)\n        if ind > 0 && !get(excl, k, false)\n            setfield!(x, k, v)\n        end\n    end\n    return x\nend\n\nfunction read(str::String, ::Type{T}) where {T}\n    if StructType(T) == AbstractType()\n        obj = read(str)\n        TT = subtypes(T)[get(obj, subtypekey(T))]\n        return fromobject(StructType(TT), TT, obj)\n    end\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Ordered, buf, pos, len, b, U::Union)\n    try\n        return read(Ordered(), buf, pos, len, b, U.a)\n    catch e\n        return read(Ordered(), buf, pos, len, b, U.b)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any})\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                @inbounds tape[tapeidx] = INT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(Ordered(), buf, pos, len, b, NamedTuple)\n    elseif b == UInt8('[')\n        return read(Ordered(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(Ordered(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(Ordered(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(Ordered(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(Ordered(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? unescape(PointerString(ptr, strlen)) : unsafe_string(ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Char})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds x = Char(buf[pos])\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    if b != UInt8('\"')\n        error = InvalidChar\n        @goto invalid\n    end\n    return pos + 1, x\n\n@label invalid\n    invalid(error, buf, pos, Char)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Bool})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, true\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, false\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, T::Union{Type{Missing}, Type{Nothing}})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, T === Missing ? missing : nothing\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{T}) where {T <: AbstractFloat}\n    float, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, float\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = 0\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{NamedTuple})\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        return pos + 1, NamedTuple()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    keys = Symbol[]\n    vals = Any[]\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        push!(keys, escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen))\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, y = read(Ordered(), buf, pos, len, b, Any)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            return pos + 1, NamedTuple{Tuple(keys)}(Tuple(vals))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = 0\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{A}) where {A <: AbstractArray{T}} where {T}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    vals = A(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, vals\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(T), buf, pos, len, b, T)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            return pos + 1, vals\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, A)\nend\n"}, "files_after": {"src/read.jl": "abstract type StructType end\n\n# by default, assume json key-values are in right order, and just pass to T constructor\nstruct Ordered <: StructType end\n\n# mutable struct + setfield!\nstruct MutableSetField <: StructType end\n\nstruct AbstractType <: StructType end\n\nStructType(T) = Ordered()\nnames(T) = NamedTuple()\nexcludes(T) = NamedTuple()\nsubtypekey(T) = :type\nsubtypes(T) = NamedTuple()\n\nfunction read(str::String)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfromobject(::Ordered, ::Type{T}, obj) where {T} = T(values(obj)...)\nfunction fromobject(::MutableSetField, ::Type{T}, obj) where {T}\n    x = T()\n    nms = names(T)\n    excl = excludes(T)\n    for (k, v) in obj\n        k = get(nms, k, k)\n        ind = Base.fieldindex(T, k, false)\n        if ind > 0 && !get(excl, k, false)\n            setfield!(x, k, v)\n        end\n    end\n    return x\nend\n\nfunction read(str::String, ::Type{T}) where {T}\n    if StructType(T) == AbstractType()\n        obj = read(str)\n        TT = subtypes(T)[Symbol(get(obj, subtypekey(T)))]\n        return fromobject(StructType(TT), TT, obj)\n    end\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(::Ordered, buf, pos, len, b, U::Union)\n    try\n        return read(Ordered(), buf, pos, len, b, U.a)\n    catch e\n        return read(Ordered(), buf, pos, len, b, U.b)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any})\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                @inbounds tape[tapeidx] = INT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(Ordered(), buf, pos, len, b, NamedTuple)\n    elseif b == UInt8('[')\n        return read(Ordered(), buf, pos, len, b, Base.Array{Any})\n    elseif b == UInt8('\"')\n        return read(Ordered(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(Ordered(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(Ordered(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(Ordered(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? unescape(PointerString(ptr, strlen)) : unsafe_string(ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Char})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds x = Char(buf[pos])\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    if b != UInt8('\"')\n        error = InvalidChar\n        @goto invalid\n    end\n    return pos + 1, x\n\n@label invalid\n    invalid(error, buf, pos, Char)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Bool})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, true\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, false\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, T::Union{Type{Missing}, Type{Nothing}})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, T === Missing ? missing : nothing\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{T}) where {T <: AbstractFloat}\n    float, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, float\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = 0\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{NamedTuple})\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        return pos + 1, NamedTuple()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    keys = Symbol[]\n    vals = Any[]\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        push!(keys, escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen))\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, y = read(Ordered(), buf, pos, len, b, Any)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            return pos + 1, NamedTuple{Tuple(keys)}(Tuple(vals))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = 0\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{A}) where {A <: AbstractArray{T}} where {T}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    vals = A(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, vals\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(T), buf, pos, len, b, T)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            return pos + 1, vals\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, A)\nend\n"}, "source_files_changed": ["src/read.jl"], "test_files_changed": ["test/runtests.jl"], "lines_changed": 59, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "e1c1ec87b2327563a4bd08b0dfa313328dd70569", "parent_sha": "ce5e08c9b65ffca01a0479aae734a26de25b2492", "commit_message": "updates", "commit_date": "2019-05-20T20:08:23-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/read.jl", "target_symbol": "read", "signature": null, "confidence": 0.75}, "files_before": {"src/read.jl": "function read(str::String)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read(str::String, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    pos, x = read(buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(buf, pos, len, b, U::Union)\n    try\n        return read(buf, pos, len, b, U.a)\n    catch e\n        return read(buf, pos, len, b, U.b)\n    end\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Any})\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                @inbounds tape[tapeidx] = INT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(buf, pos, len, b, NamedTuple)\n    elseif b == UInt8('[')\n        return read(buf, pos, len, b, Base.Array)\n    elseif b == UInt8('\"')\n        return read(buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    # positioned at first character of object key\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    # positioned at first character of object key\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? unescape(PointerString(ptr, strlen)) : unsafe_string(ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, ::Type{Char})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds x = Char(buf[pos])\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    if b != UInt8('\"')\n        error = InvalidChar\n        @goto invalid\n    end\n    return pos + 1, x\n\n@label invalid\n    invalid(error, buf, pos, Char)\nend\n\nstruct True end\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, ::Type{Bool})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, true\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, false\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, T::Union{Type{Missing}, Type{Nothing}})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, T === Missing ? missing : nothing\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nfunction read(buf, pos, len, b, ::Type{T}) where {T <: AbstractFloat}\n    float, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, float\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = 0\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, ::Type{NamedTuple})\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        return pos + 1, NamedTuple()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    keys = Symbol[]\n    vals = Any[]\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        push!(keys, escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen))\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, y = read!(buf, pos, len, b, Any)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            return pos + 1, NamedTuple{Tuple(keys)}(Tuple(vals))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = 0\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, ::Type{A}) where {A <: AbstractArray{T}} where {T}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    vals = A(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, vals\n    end\n    while true\n        # positioned at start of value\n        pos, y = read!(buf, pos, len, b, T)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            return pos + 1, vals\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, A)\nend\n", "src/structs.jl": "# by default, assume json key-values are in right order, and just pass to T constructor\n# mutable struct + setfield!\n# keyword args constructor\nabstract type StructType end\nstruct Ordered <: StructType end\nstruct MutableSetField <: StructType end\nstruct KeywordArgConstrutor <: StructType end\nStructType(T) = Ordered()\n\n@inline function read(::MutableSetField, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    x = T()\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, x\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        pos, y = read(buf, pos, len, b, fieldtype(T, key))\n        setfield!(x, key, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return pos, x\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Ordered, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    pos, x1 = readvalue(buf, pos, len, fieldtype(T, 1))\n    if fieldcount(T) == 1\n        return pos, T(x1)\n    end\n    pos, x2 = readvalue(buf, pos, len, fieldtype(T, 2))\n    if fieldcount(T) == 2\n        return pos, T(x1, x2)\n    end\n    pos, x3 = readvalue(buf, pos, len, fieldtype(T, 3))\n    if fieldcount(T) == 3\n        return pos, T(x1, x2, x3)\n    end\n    pos, x4 = readvalue(buf, pos, len, fieldtype(T, 4))\n    if fieldcount(T) == 4\n        return pos, T(x1, x2, x3, x4)\n    end\n    pos, x5 = readvalue(buf, pos, len, fieldtype(T, 5))\n    if fieldcount(T) == 5\n        return pos, T(x1, x2, x3, x4, x5)\n    end\n    pos, x6 = readvalue(buf, pos, len, fieldtype(T, 6))\n    if fieldcount(T) == 6\n        return pos, T(x1, x2, x3, x4, x5, x6)\n    end\n    pos, x7 = readvalue(buf, pos, len, fieldtype(T, 7))\n    if fieldcount(T) == 7\n        return pos, T(x1, x2, x3, x4, x5, x6, x7)\n    end\n    pos, x8 = readvalue(buf, pos, len, fieldtype(T, 8))\n    if fieldcount(T) == 8\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8)\n    end\n    pos, x9 = readvalue(buf, pos, len, fieldtype(T, 9))\n    if fieldcount(T) == 9\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9)\n    end\n    pos, x10 = readvalue(buf, pos, len, fieldtype(T, 10))\n    if fieldcount(T) == 10\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10)\n    end\n    pos, x11 = readvalue(buf, pos, len, fieldtype(T, 11))\n    if fieldcount(T) == 11\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11)\n    end\n    pos, x12 = readvalue(buf, pos, len, fieldtype(T, 12))\n    if fieldcount(T) == 12\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12)\n    end\n    pos, x13 = readvalue(buf, pos, len, fieldtype(T, 13))\n    if fieldcount(T) == 13\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13)\n    end\n    pos, x14 = readvalue(buf, pos, len, fieldtype(T, 14))\n    if fieldcount(T) == 14\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14)\n    end\n    pos, x15 = readvalue(buf, pos, len, fieldtype(T, 15))\n    if fieldcount(T) == 15\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15)\n    end\n    pos, x16 = readvalue(buf, pos, len, fieldtype(T, 16))\n    if fieldcount(T) == 16\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16)\n    end\n    vals = []\n    for i = 17:fieldcount(T)\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        @inbounds b = buf[pos]\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    # read value\n    pos, y = read(buf, pos, len, b, T)\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend"}, "files_after": {"src/read.jl": "# by default, assume json key-values are in right order, and just pass to T constructor\n# mutable struct + setfield!\n# keyword args constructor\nabstract type StructType end\nstruct Ordered <: StructType end\nstruct MutableSetField <: StructType end\nstruct KeywordArgConstrutor <: StructType end\nStructType(T) = Ordered()\n\nfunction read(str::String)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\n@label invalid\n    invalid(error, buf, pos, Any)\nend\n\nfunction read(str::String, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        error = UnexpectedEOF\n        pos = 0\n        @goto invalid\n    end\n    pos = 1\n    @inbounds b = buf[pos]\n    @wh\n    pos, x = read(StructType(T), buf, pos, len, b, T)\n    return x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\nfunction read(buf, pos, len, b, U::Union)\n    try\n        return read(buf, pos, len, b, U.a)\n    catch e\n        return read(buf, pos, len, b, U.b)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Any})\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                @inbounds tape[tapeidx] = INT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Any})\n    if b == UInt8('{')\n        return read(Ordered(), buf, pos, len, b, NamedTuple)\n    elseif b == UInt8('[')\n        return read(Ordered(), buf, pos, len, b, Base.Array)\n    elseif b == UInt8('\"')\n        return read(Ordered(), buf, pos, len, b, String)\n    elseif b == UInt8('n')\n        return read(Ordered(), buf, pos, len, b, Nothing)\n    elseif b == UInt8('t')\n        return read(Ordered(), buf, pos, len, b, Bool)\n    elseif b == UInt8('f')\n        return read(Ordered(), buf, pos, len, b, Bool)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, pos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            return pos, ifelse(int == float, int, float)\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    ptr = pointer(buf, strpos)\n    return pos + 1, escaped ? unescape(PointerString(ptr, strlen)) : unsafe_string(ptr, strlen)\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Char})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds x = Char(buf[pos])\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    if b != UInt8('\"')\n        error = InvalidChar\n        @goto invalid\n    end\n    return pos + 1, x\n\n@label invalid\n    invalid(error, buf, pos, Char)\nend\n\nstruct True end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{Bool})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        return pos + 4, true\n    elseif pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        return pos + 5, false\n    else\n        invalid(InvalidChar, buf, pos, Bool)\n    end\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, T::Union{Type{Missing}, Type{Nothing}})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        return pos + 4, T === Missing ? missing : nothing\n    else\n        invalid(InvalidChar, buf, pos, T)\n    end\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{T}) where {T <: AbstractFloat}\n    float, code, pos = Parsers.typeparser(T, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, float\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = 0\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{NamedTuple})\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        return pos + 1, NamedTuple()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    keys = Symbol[]\n    vals = Any[]\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        push!(keys, escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen))\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, y = read(Ordered(), buf, pos, len, b, Any)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            return pos + 1, NamedTuple{Tuple(keys)}(Tuple(vals))\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\nfunction read!(buf, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = 0\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\nfunction read(::Ordered, buf, pos, len, b, ::Type{A}) where {A <: AbstractArray{T}} where {T}\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    vals = A(undef, 0)\n    if b == UInt8(']')\n        return pos + 1, vals\n    end\n    while true\n        # positioned at start of value\n        pos, y = read(StructType(T), buf, pos, len, b, T)\n        push!(vals, y)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            return pos + 1, vals\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label invalid\n    invalid(error, buf, pos, A)\nend\n", "src/structs.jl": "@inline function read(S::ST, buf, pos, len, b, ::Type{T}) where {ST, T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    if S === MutableSetField()\n        x = T()\n    else\n        keys = Symbol[]\n        vals = []\n    end\n    pos += 1\n    @eof\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        key = escaped ? Symbol(unescape(PointerString(pointer(buf, keypos), keylen))) : _symbol(pointer(buf, keypos), keylen)\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        FT = fieldtype(T, key)\n        pos, y = read(StructType(FT), buf, pos, len, b, FT)\n        if S === MutableSetField()\n            setfield!(x, key, y)\n        else\n            push!(keys, key)\n            push!(vals, y)\n        end\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            if S === MutableSetField()\n                return pos, x\n            else\n                return pos, T(; zip(keys, vals)...)\n            end\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function read(::Ordered, buf, pos, len, b, ::Type{T}) where {T}\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, T()\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    pos, x1 = readvalue(buf, pos, len, fieldtype(T, 1))\n    if fieldcount(T) == 1\n        return pos, T(x1)\n    end\n    pos, x2 = readvalue(buf, pos, len, fieldtype(T, 2))\n    if fieldcount(T) == 2\n        return pos, T(x1, x2)\n    end\n    pos, x3 = readvalue(buf, pos, len, fieldtype(T, 3))\n    if fieldcount(T) == 3\n        return pos, T(x1, x2, x3)\n    end\n    pos, x4 = readvalue(buf, pos, len, fieldtype(T, 4))\n    if fieldcount(T) == 4\n        return pos, T(x1, x2, x3, x4)\n    end\n    pos, x5 = readvalue(buf, pos, len, fieldtype(T, 5))\n    if fieldcount(T) == 5\n        return pos, T(x1, x2, x3, x4, x5)\n    end\n    pos, x6 = readvalue(buf, pos, len, fieldtype(T, 6))\n    if fieldcount(T) == 6\n        return pos, T(x1, x2, x3, x4, x5, x6)\n    end\n    pos, x7 = readvalue(buf, pos, len, fieldtype(T, 7))\n    if fieldcount(T) == 7\n        return pos, T(x1, x2, x3, x4, x5, x6, x7)\n    end\n    pos, x8 = readvalue(buf, pos, len, fieldtype(T, 8))\n    if fieldcount(T) == 8\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8)\n    end\n    pos, x9 = readvalue(buf, pos, len, fieldtype(T, 9))\n    if fieldcount(T) == 9\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9)\n    end\n    pos, x10 = readvalue(buf, pos, len, fieldtype(T, 10))\n    if fieldcount(T) == 10\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10)\n    end\n    pos, x11 = readvalue(buf, pos, len, fieldtype(T, 11))\n    if fieldcount(T) == 11\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11)\n    end\n    pos, x12 = readvalue(buf, pos, len, fieldtype(T, 12))\n    if fieldcount(T) == 12\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12)\n    end\n    pos, x13 = readvalue(buf, pos, len, fieldtype(T, 13))\n    if fieldcount(T) == 13\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13)\n    end\n    pos, x14 = readvalue(buf, pos, len, fieldtype(T, 14))\n    if fieldcount(T) == 14\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14)\n    end\n    pos, x15 = readvalue(buf, pos, len, fieldtype(T, 15))\n    if fieldcount(T) == 15\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15)\n    end\n    pos, x16 = readvalue(buf, pos, len, fieldtype(T, 16))\n    if fieldcount(T) == 16\n        return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16)\n    end\n    vals = []\n    for i = 17:fieldcount(T)\n        pos, y = readvalue(buf, pos, len, fieldtype(T, i))\n        push!(vals, y)\n    end\n    return pos, T(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, vals...)\n\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n@inline function readvalue(buf, pos, len, ::Type{T}) where {T}\n    @inbounds b = buf[pos]\n    while b != UInt8('\"')\n        pos += ifelse(b == UInt8('\\\\'), 2, 1)\n        @eof\n        @inbounds b = buf[pos]\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8(':')\n        error = ExpectedSemiColon\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    # read value\n    pos, y = read(StructType(T), buf, pos, len, b, T)\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        pos += 1\n        return pos, y\n    elseif b != UInt8(',')\n        error = ExpectedComma\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    return pos, y\n@label invalid\n    invalid(error, buf, pos, T)\nend"}, "source_files_changed": ["src/read.jl", "src/structs.jl"], "test_files_changed": [], "lines_changed": 99, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "85763f0b5f8034ad28c6094548f45419216fc4a9", "parent_sha": "ed0de6483ae95a866e536114670b10131636f90b", "commit_message": "Start struct integration", "commit_date": "2019-05-14T01:42:45-06:00", "action": {"type": "ADD_METHOD", "target_file": "src/JSON3.jl", "target_symbol": "read", "signature": null, "confidence": 0.85}, "files_before": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object <: AbstractDict{Symbol, Any}\n    buf::Base.CodeUnits{UInt8,String}\n    tape::Vector{UInt64}\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(2), 0])\n\nstruct Array{T} <: AbstractVector{T}\n    buf::Base.CodeUnits{UInt8,String}\n    tape::Vector{UInt64}\nend\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-10):min(end, pos+10)]))\n\"\"\"))\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# Julia structs\n  # immutable\n    # positional arg or keyword args\n  # mutable\n    # noarg, positional, or keyword args\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\nfunction read(str::String)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        return Object()\n    end\n    @inbounds b = buf[1]\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Any})\n    @wh\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                @inbounds tape[tapeidx] = INT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    # positioned at first character of object key\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = 0\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = 0\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\n\nend # module\n"}, "files_after": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\nstruct Object <: AbstractDict{Symbol, Any}\n    buf::Base.CodeUnits{UInt8,String}\n    tape::Vector{UInt64}\nend\n\nObject() = Object(codeunits(\"\"), UInt64[object(2), 0])\n\nstruct Array{T} <: AbstractVector{T}\n    buf::Base.CodeUnits{UInt8,String}\n    tape::Vector{UInt64}\nend\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, buf, pos, T) = throw(ArgumentError(\"\"\"\ninvalid JSON at byte position $pos while parsing type $T: $error\n$(String(buf[max(1, pos-10):min(end, pos+10)]))\n\"\"\"))\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# Julia structs\n  # immutable\n    # positional arg or keyword args\n  # mutable\n    # noarg, positional, or keyword args\n\n# AbstractDict interface\nfunction Base.length(obj::Object)\n    @inbounds len = getnontypemask(gettape(obj)[2])\n    return len\nend\n\n@inline function Base.iterate(obj::Object, (i, tapeidx)=(1, 3))\n    i > length(obj) && return nothing\n    tape = gettape(obj)\n    @inbounds t = tape[tapeidx]\n    key = getvalue(Symbol, getbuf(obj), tape, tapeidx, t)\n    tapeidx += 2\n    @inbounds t = tape[tapeidx]\n    x = Pair{Symbol, Any}(key, getvalue(Any, getbuf(obj), tape, tapeidx, t))\n    tapeidx += gettapelen(Any, t)\n    return x, (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    throw(KeyError(key))\nend\n\nfunction Base.get(obj::Object, key, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nBase.getproperty(obj::Object, prop::Symbol) = get(obj, prop)\nBase.getindex(obj::Object, str::String) = get(obj, Symbol(str))\n\n# AbstractArray interface\nBase.IndexStyle(::Type{<:Array}) = Base.IndexLinear()\n\nfunction Base.size(arr::Array)\n    @inbounds len = getnontypemask(gettape(arr)[2])\n    return (len,)\nend\n\nfunction Base.iterate(arr::Array{T}, (i, tapeidx)=(1, 3)) where {T}\n    i > length(arr) && return nothing\n    tape = gettape(arr)\n    @inbounds t = tape[tapeidx]\n    val = getvalue(T, getbuf(arr), tape, tapeidx, t)\n    tapeidx += gettapelen(T, t)\n    return val, (i + 1, tapeidx)\nend\n\n@inline Base.@propagate_inbounds function Base.getindex(arr::Array{T}, i::Int) where {T}\n    @boundscheck checkbounds(arr, i)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if regularstride(T)\n        tapeidx = 1 + 2 * i\n        @inbounds t = tape[tapeidx]\n        return getvalue(T, buf, tape, tapeidx, t)\n    else\n        tapeidx = 3\n        idx = 1\n        while true \n            @inbounds t = tape[tapeidx]\n            if i == idx\n                return getvalue(T, buf, tape, tapeidx, t)\n            else\n                tapeidx += gettapelen(T, t)\n                idx += 1\n            end\n        end\n    end\nend\n\nfunction read(str::String)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        return Object()\n    end\n    @inbounds b = buf[1]\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) :\n        Vector{UInt64}(undef, len + 2)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    @inbounds t = tape[1]\n    if isobject(t)\n        return Object(buf, tape)\n    elseif isarray(t)\n        return Array{geteltype(tape[2])}(buf, tape)\n    else\n        return getvalue(Any, buf, tape, 1, t)\n    end\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Any})\n    @wh\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                @inbounds tape[tapeidx] = INT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n@label invalid\n    invalid(InvalidChar, buf, pos, Any)\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    # positioned at first character of object key\n    while b != UInt8('\"')\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n        else\n            pos += 1\n            strlen += 1\n        end\n        @eof\n        @inbounds b = buf[pos]\n    end\n    @inbounds tape[tapeidx] = string(strlen)\n    @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | strpos, strpos)\n    return pos + 1, tapeidx + 2\n\n@label invalid\n    invalid(error, buf, pos, String)\nend\n\nstruct True end\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL | UInt64(1)\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, True)\n    end\nend\n\nstruct False end\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = BOOL\n        return pos + 5, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, False)\n    end\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 2\n    else\n        invalid(InvalidChar, buf, pos, Nothing)\n    end\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    eT = EMPTY\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 2\n    nelem = 0\n    while true\n        keypos = pos\n        keylen = 0\n        escaped = false\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                escaped = true\n                # skip next character\n                pos += 2\n                keylen += 2\n            else\n                pos += 1\n                keylen += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        @inbounds tape[tapeidx] = string(keylen)\n        @inbounds tape[tapeidx+1] = ifelse(escaped, ESCAPE_BIT | keypos, keypos)\n        tapeidx += 2\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            @inbounds tape[objidx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Object)\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    eT = EMPTY\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(2)\n        @inbounds tape[tapeidx+1] = eltypelen(eT, 0)\n        tapeidx += 2\n        pos += 1\n        @goto done\n    end\n    tapeidx += 2\n    nelem = 0\n    while true\n        # positioned at start of value\n        prevtapeidx = tapeidx\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        @inbounds eT = promoteeltype(eT, gettypemask(tape[prevtapeidx]))\n        nelem += 1\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            @inbounds tape[arridx+1] = eltypelen(eT, nelem)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, buf, pos, Array)\nend\n\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\ninclude(\"structs.jl\")\n\nend # module\n", "src/structs.jl": "# by default, assume json key-values are in right order, and just pass to T constructor\n# mutable struct + setfield!\n# keyword args constructor\nabstract type StructType end\nstruct Ordered <: StructType end\nstruct MutableSetField <: StructType end\nstruct KeywordArgConstrutor <: StructType end\nStructType(T) = Ordered()\n\nfunction read(buf, pos, len, b, ::Type{T}) where {T <: Integer}\n    int, code, pos = Parsers.typeparser(Int64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n    if code > 0\n        return pos, int\n    end\n    invalid(InvalidChar, buf, pos, T)\nend\n\nfunction read(str::String, ::Type{T}) where {T}\n    buf = codeunits(str)\n    len = length(buf)\n    error = InvalidChar\n    pos = 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        x = T()\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    x = T((ntuple(fieldcount(T)) do i\n        @inbounds b = buf[pos]\n        while b != UInt8('\"')\n            if b == UInt8('\\\\')\n                pos += 2\n            else\n                pos += 1\n            end\n            @eof\n            @inbounds b = buf[pos]\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # read value\n        pos, y = read(buf, pos, len, b, fieldtype(T, i))\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            pos += 1\n            return y\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        return y\n        @label invalid\n            invalid(error, buf, pos, T)\n    end)...)\n\n@label done\n    return pos, x\n@label invalid\n    invalid(error, buf, pos, T)\nend\n\n"}, "source_files_changed": ["src/JSON3.jl", "src/structs.jl"], "test_files_changed": [], "lines_changed": 100, "is_valid": true, "validation_errors": []}
{"repo": "JSON3.jl", "commit_sha": "660500f115acada17589d7e20c4b2d0bac40c649", "parent_sha": "14c5259ecc34b84c044761f245f2c4e7a0b1f904", "commit_message": "updates", "commit_date": "2019-05-10T22:35:15-06:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/JSON3.jl", "target_symbol": "Base.propertynames", "signature": null, "confidence": 0.75}, "files_before": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, b, T) = throw(ArgumentError(\"invalid JSON: $error. Encountered '$(Char(b))' while parsing type: $T\"))\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# Julia structs\n  # immutable\n    # positional arg or keyword args\n  # mutable\n    # noarg, positional, or keyword args\n\nstruct Object{B <: AbstractVector{UInt8}}\n    buf::B\n    tape::Vector{UInt64}\nend\n\nfunction Base.propertynames(obj::Object)\n    tape = gettape(obj)\n    buf = getbuf(obj)\n    props = Symbol[]\n    if getidx(tape[1]) == 1\n        return props\n    end\n    tapeidx = 2\n    last = getidx(tape[1])\n    while tapeidx <= last\n        @inbounds t = tape[tapeidx]\n        push!(props, _symbol(pointer(buf, getpos(t)), getlen(t)))\n        tapeidx += 1\n        @inbounds tapeidx += tapeelements(tape[tapeidx])\n    end\n    return props\nend\n\nfunction Base.getproperty(obj::Object, prop::Symbol)\n    tape = gettape(obj)\n    buf = getbuf(obj)\n    if getidx(tape[1]) == 1\n        return nothing\n    end\n    tapeidx = 2\n    last = getidx(tape[1])\n    while tapeidx <= last\n        @inbounds t = tape[tapeidx]\n        key = _symbol(pointer(buf, getpos(t)), getlen(t))\n        if key == prop\n            return getvalue(buf, tape, tapeidx + 1)\n        else\n            tapeidx += 1\n            @inbounds tapeidx += tapeelements(tape[tapeidx])\n        end\n    end\n    return nothing\nend\nBase.getindex(obj::Object, str::String) = getproperty(obj, Symbol(str))\n\nstruct Array{B <: AbstractVector{UInt8}}\n    buf::B\n    tape::Vector{UInt64}\nend\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\n\n# TODO\n  # make Array subtype AbstractVector\n  # implement interface\n  # properly checkbounds\nfunction Base.getindex(arr::Array, i::Int)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if getidx(tape[1]) == 1\n        return nothing\n    end\n    tapeidx = 2\n    last = getidx(tape[1])\n    idx = 1\n    while tapeidx <= last\n        if i == idx\n            return getvalue(buf, tape, tapeidx)\n        else\n            @inbounds tapeidx += tapeelements(tape[tapeidx])\n            idx += 1\n        end\n    end\n    return nothing\nend\n\nfunction read(str::String)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        return Object(buf, UInt64[])\n    end\n    len = ifelse(len == 1, 2, len)\n    @inbounds b = buf[1]\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) : Vector{UInt64}(undef, len)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    return getvalue(buf, tape, 1)\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Any})\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                @inbounds tape[tapeidx] = INT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n    invalid(InvalidChar, b, Any)\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    # positioned at first character of object key\n    while b != UInt8('\"')\n        pos += 1\n        strlen += 1\n        @eof\n        @inbounds b = buf[pos]\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n            @eof\n            @inbounds b = buf[pos]\n        end\n    end\n    @inbounds tape[tapeidx] = escaped ? escapedstring(strpos, strlen) : string(strpos, strlen)\n    return pos + 1, tapeidx + 1\n\n@label invalid\n    invalid(error, b, String)\nend\n\nstruct True end\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = TRUE\n        return pos + 4, tapeidx + 1\n    else\n        invalid(InvalidChar, b, True)\n    end\nend\n\nstruct False end\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = FALSE\n        return pos + 5, tapeidx + 1\n    else\n        invalid(InvalidChar, b, False)\n    end\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 1\n    else\n        invalid(InvalidChar, b, Nothing)\n    end\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(1)\n        tapeidx += 1\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 1\n    while true\n        keypos = pos\n        keylen = 0\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            pos += 1\n            keylen += 1\n            @eof\n            @inbounds b = buf[pos]\n            if b == UInt8('\\\\')\n                # skip next character\n                pos += 2\n                keylen += 2\n                @eof\n                @inbounds b = buf[pos]\n            end\n        end\n        @inbounds tape[tapeidx] = string(keypos, keylen)\n        tapeidx += 1\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, b, Object)\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(1)\n        tapeidx += 1\n        pos += 1\n        @goto done\n    end\n    tapeidx += 1\n    while true\n        # positioned at start of value\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, b, Array)\nend\n\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\n\nend # module\n", "src/show.jl": "Base.show(io::IO, j::Object) = _show(io, j)\nBase.show(io::IO, j::Array) = _show(io, j)\n_show(io::IO, x, indent=0, offset=0) = show(io, x)\n\nfunction _show(io::IO, obj::Object, indent=0, offset=0)\n    tape = gettape(obj)\n    buf = getbuf(obj)\n    if getidx(tape[1]) == 1\n        print(io, \"{}\")\n        return\n    end\n    println(io, \"{\")\n    indent += 1\n    keys = []\n    vals = []\n    # loop thru all key-value pairs, keeping track of longest key to pad others\n    tapeidx = 2\n    last = getidx(tape[1])\n    while tapeidx <= last\n        t = tape[tapeidx]\n        push!(keys, unsafe_string(pointer(buf, getpos(t)), getlen(t)))\n        tapeidx += 1\n        push!(vals, getvalue(buf, tape, tapeidx))\n        @inbounds tapeidx += tapeelements(tape[tapeidx])\n    end\n    maxlen = maximum(map(length, keys)) + 5\n    # @show maxlen\n    for i = 1:length(keys)\n        Base.write(io, \"  \"^indent)\n        Base.write(io, lpad(\"\\\"$(keys[i])\\\"\" * \": \", maxlen + offset, ' '))\n        _show(io, vals[i], indent, maxlen + offset)\n        if i == length(keys)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"}\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n\nfunction _show(io::IO, arr::Array, indent=0, offset=0)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if getidx(tape[1]) == 1\n        print(io, \"[]\")\n        return\n    end\n    println(io, \"[\")\n    indent += 1\n    vals = []\n    tapeidx = 2\n    last = getidx(tape[1])\n    while tapeidx <= last\n        push!(vals, getvalue(buf, tape, tapeidx))\n        @inbounds tapeidx += tapeelements(tape[tapeidx])\n    end\n    for (i, val) in enumerate(vals)\n        Base.write(io, \"  \"^indent * \" \"^offset)\n        _show(io, vals[i], indent, offset)\n        if i == length(vals)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"]\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n"}, "files_after": {"src/JSON3.jl": "module JSON3\n\nusing Parsers, Mmap\n\ninclude(\"utils.jl\")\n\n@noinline invalid(error, b, T) = throw(ArgumentError(\"invalid JSON: $error. Encountered '$(Char(b))' while parsing type: $T\"))\n@enum Error UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedComma ExpectedSemiColon InvalidChar\n\n# Julia structs\n  # immutable\n    # positional arg or keyword args\n  # mutable\n    # noarg, positional, or keyword args\n\nstruct Object{B <: AbstractVector{UInt8}} <: AbstractDict{Symbol, Any}\n    buf::B\n    tape::Vector{UInt64}\n    len::Int\nend\n\n# AbstractDict interface\nBase.length(obj::Object) = getlen(obj)\n\nfunction Base.iterate(obj::Object, (i, tapeidx)=(1, 2))\n    i > length(obj) && return nothing\n    @inbounds t = gettape(obj)[tapeidx]\n    key = _symbol(pointer(getbuf(obj), getpos(t)), getlen(t))\n    tapeidx += 1\n    val = getvalue(getbuf(obj), gettape(obj), tapeidx)\n    @inbounds tapeidx += tapeelements(tape[tapeidx])\n    return (key, val), (i + 1, tapeidx)\nend\n\nfunction Base.get(obj::Object, key, default)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default\nend\n\nfunction Base.get(default::Base.Callable, obj::Object, key)\n    for (k, v) in obj\n        k == key && return v\n    end\n    return default()\nend\n\nBase.propertynames(obj::Object) = collect(keys(obj))\n\nfunction Base.getproperty(obj::Object, prop::Symbol)\n    tape = gettape(obj)\n    buf = getbuf(obj)\n    if getidx(tape[1]) == 1\n        return nothing\n    end\n    tapeidx = 2\n    last = getidx(tape[1])\n    while tapeidx <= last\n        @inbounds t = tape[tapeidx]\n        key = _symbol(pointer(buf, getpos(t)), getlen(t))\n        if key == prop\n            return getvalue(buf, tape, tapeidx + 1)\n        else\n            tapeidx += 1\n            @inbounds tapeidx += tapeelements(tape[tapeidx])\n        end\n    end\n    return nothing\nend\nBase.getindex(obj::Object, str::String) = getproperty(obj, Symbol(str))\n\nstruct Array{B <: AbstractVector{UInt8}}\n    buf::B\n    tape::Vector{UInt64}\nend\n\ngetbuf(j::Union{Object, Array}) = getfield(j, :buf)\ngettape(j::Union{Object, Array}) = getfield(j, :tape)\ngetlen(j::Union{Object, Array}) = getfield(j, :len)\n\n# TODO\n  # make Array subtype AbstractVector\n  # implement interface\n  # properly checkbounds\nfunction Base.getindex(arr::Array, i::Int)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if getidx(tape[1]) == 1\n        return nothing\n    end\n    tapeidx = 2\n    last = getidx(tape[1])\n    idx = 1\n    while tapeidx <= last\n        if i == idx\n            return getvalue(buf, tape, tapeidx)\n        else\n            @inbounds tapeidx += tapeelements(tape[tapeidx])\n            idx += 1\n        end\n    end\n    return nothing\nend\n\nfunction read(str::String)\n    buf = codeunits(str)\n    len = length(buf)\n    if len == 0\n        return Object(buf, UInt64[])\n    end\n    len = ifelse(len == 1, 2, len)\n    @inbounds b = buf[1]\n    tape = len > div(Mmap.PAGESIZE, 2) ? Mmap.mmap(Vector{UInt64}, len) : Vector{UInt64}(undef, len)\n    pos, tapeidx = read!(buf, 1, len, b, tape, 1, Any)\n    return getvalue(buf, tape, 1)\nend\n\nfunction read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Any})\n    if b == UInt8('{')\n        return read!(buf, pos, len, b, tape, tapeidx, Object)\n    elseif b == UInt8('[')\n        return read!(buf, pos, len, b, tape, tapeidx, Array)\n    elseif b == UInt8('\"')\n        return read!(buf, pos, len, b, tape, tapeidx, String)\n    elseif b == UInt8('n')\n        return read!(buf, pos, len, b, tape, tapeidx, Nothing)\n    elseif b == UInt8('t')\n        return read!(buf, pos, len, b, tape, tapeidx, True)\n    elseif b == UInt8('f')\n        return read!(buf, pos, len, b, tape, tapeidx, False)\n    elseif (UInt8('0') <= b <= UInt8('9')) || b == UInt8('-') || b == UInt8('+')\n        float, code, floatpos = Parsers.typeparser(Float64, buf, pos, len, b, Int16(0), Parsers.OPTIONS)\n        if code > 0\n            int = unsafe_trunc(Int64, float)\n            if int == float\n                @inbounds tape[tapeidx] = INT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, int)\n            else\n                @inbounds tape[tapeidx] = FLOAT\n                @inbounds tape[tapeidx + 1] = Core.bitcast(UInt64, float)\n            end\n            return floatpos, tapeidx + 2\n        end\n    end\n    invalid(InvalidChar, b, Any)\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{String})\n    if b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    strpos = pos\n    strlen = 0\n    escaped = false\n    @inbounds b = buf[pos]\n    # positioned at first character of object key\n    while b != UInt8('\"')\n        pos += 1\n        strlen += 1\n        @eof\n        @inbounds b = buf[pos]\n        if b == UInt8('\\\\')\n            escaped = true\n            # skip next character\n            pos += 2\n            strlen += 2\n            @eof\n            @inbounds b = buf[pos]\n        end\n    end\n    @inbounds tape[tapeidx] = escaped ? escapedstring(strpos, strlen) : string(strpos, strlen)\n    return pos + 1, tapeidx + 1\n\n@label invalid\n    invalid(error, b, String)\nend\n\nstruct True end\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{True})\n    if pos + 3 <= len &&\n        b            == UInt8('t') &&\n        buf[pos + 1] == UInt8('r') &&\n        buf[pos + 2] == UInt8('u') &&\n        buf[pos + 3] == UInt8('e')\n        @inbounds tape[tapeidx] = TRUE\n        return pos + 4, tapeidx + 1\n    else\n        invalid(InvalidChar, b, True)\n    end\nend\n\nstruct False end\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{False})\n    if pos + 4 <= len &&\n        b            == UInt8('f') &&\n        buf[pos + 1] == UInt8('a') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('s') &&\n        buf[pos + 4] == UInt8('e')\n        @inbounds tape[tapeidx] = FALSE\n        return pos + 5, tapeidx + 1\n    else\n        invalid(InvalidChar, b, False)\n    end\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Nothing})\n    if pos + 3 <= len &&\n        b            == UInt8('n') &&\n        buf[pos + 1] == UInt8('u') &&\n        buf[pos + 2] == UInt8('l') &&\n        buf[pos + 3] == UInt8('l')\n        @inbounds tape[tapeidx] = NULL\n        return pos + 4, tapeidx + 1\n    else\n        invalid(InvalidChar, b, Nothing)\n    end\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Object})\n    objidx = tapeidx\n    if b != UInt8('{')\n        error = ExpectedOpeningObjectChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8('}')\n        @inbounds tape[tapeidx] = object(1)\n        tapeidx += 1\n        pos += 1\n        @goto done\n    elseif b != UInt8('\"')\n        error = ExpectedOpeningQuoteChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    tapeidx += 1\n    while true\n        keypos = pos\n        keylen = 0\n        # read first key character\n        @inbounds b = buf[pos]\n        # positioned at first character of object key\n        while b != UInt8('\"')\n            pos += 1\n            keylen += 1\n            @eof\n            @inbounds b = buf[pos]\n            if b == UInt8('\\\\')\n                # skip next character\n                pos += 2\n                keylen += 2\n                @eof\n                @inbounds b = buf[pos]\n            end\n        end\n        @inbounds tape[tapeidx] = string(keypos, keylen)\n        tapeidx += 1\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8(':')\n            error = ExpectedSemiColon\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        # now positioned at start of value\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8('}')\n            @inbounds tape[objidx] = object(tapeidx - objidx)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b != UInt8('\"')\n            error = ExpectedOpeningQuoteChar\n            @goto invalid\n        end\n        pos += 1\n        @eof\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, b, Object)\nend\n\n@inline function read!(buf::AbstractVector{UInt8}, pos, len, b, tape, tapeidx, ::Type{Array})\n    arridx = tapeidx\n    if b != UInt8('[')\n        error = ExpectedOpeningArrayChar\n        @goto invalid\n    end\n    pos += 1\n    @eof\n    @inbounds b = buf[pos]\n    @wh\n    if b == UInt8(']')\n        @inbounds tape[tapeidx] = array(1)\n        tapeidx += 1\n        pos += 1\n        @goto done\n    end\n    tapeidx += 1\n    while true\n        # positioned at start of value\n        pos, tapeidx = read!(buf, pos, len, b, tape, tapeidx, Any)\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n        if b == UInt8(']')\n            @inbounds tape[arridx] = array(tapeidx - arridx)\n            pos += 1\n            @goto done\n        elseif b != UInt8(',')\n            error = ExpectedComma\n            @goto invalid\n        end\n        pos += 1\n        @eof\n        @inbounds b = buf[pos]\n        @wh\n    end\n\n@label done\n    return pos, tapeidx\n@label invalid\n    invalid(error, b, Array)\nend\n\ninclude(\"strings.jl\")\ninclude(\"show.jl\")\n\nend # module\n", "src/show.jl": "Base.show(io::IO, j::Object) = _show(io, j)\nBase.show(io::IO, j::Array) = _show(io, j)\n_show(io::IO, x, indent=0, offset=0) = show(io, x)\n\nfunction _show(io::IO, obj::Object, indent=0, offset=0)\n    tape = gettape(obj)\n    buf = getbuf(obj)\n    if isempty(tape) || getidx(tape[1]) == 1\n        print(io, \"{}\")\n        return\n    end\n    println(io, \"{\")\n    indent += 1\n    keys = []\n    vals = []\n    # loop thru all key-value pairs, keeping track of longest key to pad others\n    tapeidx = 2\n    last = getidx(tape[1])\n    while tapeidx <= last\n        t = tape[tapeidx]\n        push!(keys, unsafe_string(pointer(buf, getpos(t)), getlen(t)))\n        tapeidx += 1\n        push!(vals, getvalue(buf, tape, tapeidx))\n        @inbounds tapeidx += tapeelements(tape[tapeidx])\n    end\n    maxlen = maximum(map(length, keys)) + 5\n    # @show maxlen\n    for i = 1:length(keys)\n        Base.write(io, \"  \"^indent)\n        Base.write(io, lpad(\"\\\"$(keys[i])\\\"\" * \": \", maxlen + offset, ' '))\n        _show(io, vals[i], indent, maxlen + offset)\n        if i == length(keys)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"}\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n\nfunction _show(io::IO, arr::Array, indent=0, offset=0)\n    tape = gettape(arr)\n    buf = getbuf(arr)\n    if getidx(tape[1]) == 1\n        print(io, \"[]\")\n        return\n    end\n    println(io, \"[\")\n    indent += 1\n    vals = []\n    tapeidx = 2\n    last = getidx(tape[1])\n    while tapeidx <= last\n        push!(vals, getvalue(buf, tape, tapeidx))\n        @inbounds tapeidx += tapeelements(tape[tapeidx])\n    end\n    for (i, val) in enumerate(vals)\n        Base.write(io, \"  \"^indent * \" \"^offset)\n        _show(io, vals[i], indent, offset)\n        if i == length(vals)\n            indent -= 1\n            Base.write(io, \"\\n\" * (\"  \"^indent * \" \"^offset) * \"]\")\n        else\n            Base.write(io, \",\\n\")\n        end\n    end\n    return\nend\n"}, "source_files_changed": ["src/JSON3.jl", "src/show.jl"], "test_files_changed": [], "lines_changed": 45, "is_valid": true, "validation_errors": []}
