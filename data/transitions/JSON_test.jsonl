{"repo": "JSON.jl", "commit_sha": "c7130d76ca0b10b4b8b675b1293811b03206589b", "parent_sha": "74798291682b0bc3458c04527c7915699b19502a", "commit_message": "Fix misleading error message for lowerkey (#426)", "commit_date": "2026-01-14T00:27:54-07:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/write.jl", "target_symbol": "StructUtils.lowerkey", "signature": null, "confidence": 0.75}, "files_before": {"src/write.jl": "struct JSONWriteStyle <: JSONStyle end\n\n\"\"\"\n    JSON.Null()\n\nSingleton sentinel that always serializes as the JSON literal `null`,\neven when `omit_null=true` at the struct or callsite level. Useful for\nper-field overrides (e.g. `Union{Nothing, JSON.Null}`) or custom field\nlowering that must force a `null` emission.\n\"\"\"\nstruct Null end\n\n\"\"\"\n    JSON.Omit()\n\nSingleton sentinel that removes the enclosing value from the JSON output,\nregardless of `omit_null` / `omit_empty` settings. Valid within objects\nand arrays; using it as the root value throws an error.\n\"\"\"\nstruct Omit end\n\nsizeguess(::Nothing) = 4\nsizeguess(x::Bool) = 5\nsizeguess(x::Integer) = 20\nsizeguess(x::AbstractFloat) = 20\nsizeguess(x::Union{Float16, Float32, Float64}) = Base.Ryu.neededdigits(typeof(x))\nsizeguess(x::AbstractString) = 2 + sizeof(x)\nsizeguess(::Null) = 4\nsizeguess(::Omit) = 0\nsizeguess(_) = 512\n\nStructUtils.lower(::JSONStyle, ::Missing) = nothing\nStructUtils.lower(::JSONStyle, x::Symbol) = String(x)\nStructUtils.lower(::JSONStyle, x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType, Type, Logging.LogLevel}) = string(x)\nStructUtils.lower(::JSONStyle, x::Regex) = x.pattern\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any,0}) = x[1]\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any, N}) where {N} = (view(x, ntuple(_ -> :, N - 1)..., j) for j in axes(x, N))\nStructUtils.lower(::JSONStyle, x::AbstractVector) = x\nStructUtils.arraylike(::JSONStyle, x::AbstractVector{<:Pair}) = false\nStructUtils.structlike(::JSONStyle, ::Type{<:NamedTuple}) = true\n\n# for pre-1.0 compat, which serialized Tuple object keys by default\nStructUtils.lowerkey(::JSONStyle, x::Tuple) = string(x)\n\n\"\"\"\n    JSON.omit_null(::Type{T})::Bool\n    JSON.omit_null(::JSONStyle, ::Type{T})::Bool\n    \nControls whether struct fields that are undefined or are `nothing` are included in the JSON output.\nReturns `false` by default, meaning all fields are included, regardless of undef or `nothing`. To instead\nensure only *non-null* fields are written, set this to `true`.\nThis can also be controlled via the `omit_null` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_null(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_null(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_null(::Type{T}) where {T} = false\nomit_null(::JSONStyle, ::Type{T}) where {T} = omit_null(T)\n\n\"\"\"\n    @omit_null struct T ...\n    @omit_null T\n\nConvenience macro to set `omit_null(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_null struct T ... end`\n2. Applied to an existing struct name: `@omit_null T`\n3. Chained with other macros: `@omit_null @defaults struct T ... end`\n\nThe macro automatically handles complex macro expansions by walking the expression\ntree to find struct definitions, making it compatible with macros like `StructUtils.@defaults`.\n\n# Examples\n```julia\n# Method 1: Struct annotation\n@omit_null struct Person\n    name::String\n    email::Union{Nothing, String}\nend\n\n# Method 2: Apply to existing struct\nstruct User\n    id::Int\n    profile::Union{Nothing, String}\nend\n@omit_null User\n\n# Method 3: Chain with @defaults\n@omit_null @defaults struct Employee\n    name::String = \"Anonymous\"\n    manager::Union{Nothing, String} = nothing\nend\n```\n\"\"\"\nmacro omit_null(expr)\n    return _omit_macro_impl(expr, :omit_null, __module__)\nend\n\n\"\"\"\n    JSON.omit_empty(::Type{T})::Bool\n    JSON.omit_empty(::JSONStyle, ::Type{T})::Bool\n\nControls whether struct fields that are empty are included in the JSON output.\nReturns `false` by default, meaning empty fields *are* included. To instead exclude empty fields,\nset this to `true`. A field is considered empty if it is `nothing`, an empty collection\n(empty array, dict, string, tuple, or named tuple), or `missing`.\nThis can also be controlled via the `omit_empty` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_empty(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_empty(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_empty(::Type{T}) where {T} = false\nomit_empty(::JSONStyle, ::Type{T}) where {T} = omit_empty(T)\n\nis_empty(x) = false\nis_empty(::Nothing) = true\nis_empty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = Base.isempty(x)\n\n\"\"\"\n    @omit_empty struct T ...\n    @omit_empty T\n\nConvenience macro to set `omit_empty(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_empty struct T ... end`\n2. Applied to an existing struct name: `@omit_empty T`\n3. Chained with other macros: `@omit_empty @other_macro struct T ... end`\n\"\"\"\nmacro omit_empty(expr)\n    return _omit_macro_impl(expr, :omit_empty, __module__)\nend\n\n# Helper function to generate the appropriate type signature for omit functions\nfunction _make_omit_type_sig(T, is_parametric)\n    if is_parametric\n        # For parametric types, use <: to match all instantiations\n        return :(<:$T)\n    else\n        return T\n    end\nend\n\n# Helper function for both @omit_null and @omit_empty macros\nfunction _omit_macro_impl(expr, omit_func_name, module_context)\n    original_expr = expr\n    expr = macroexpand(module_context, expr)\n    # Case 1: Just a type name (Symbol or more complex type expression)\n    if isa(expr, Symbol) || (Meta.isexpr(expr, :curly) || Meta.isexpr(expr, :where))\n        # Extract the base type name\n        T, is_parametric = _extract_type_name(expr)\n        type_sig = _make_omit_type_sig(T, is_parametric)\n        return esc(quote\n            JSON.$omit_func_name(::Type{$type_sig}) = true\n        end)\n    end\n    # Case 2: Struct definition (possibly from macro expansion)\n    if Meta.isexpr(expr, :struct)\n        ismutable, T, fieldsblock = expr.args\n        T, is_parametric = _extract_type_name(T)\n        type_sig = _make_omit_type_sig(T, is_parametric)\n        return esc(quote\n            # insert original expr as-is\n            $expr\n            # omit function overload\n            JSON.$omit_func_name(::Type{$type_sig}) = true\n        end)\n    end\n    # Case 3: Block expression (from complex macros like @defaults)\n    if Meta.isexpr(expr, :block)\n        # Try to find a struct definition in the block\n        struct_expr = _find_struct_in_block(expr)\n        if struct_expr !== nothing\n            ismutable, T, fieldsblock = struct_expr.args\n            T, is_parametric = _extract_type_name(T)\n            type_sig = _make_omit_type_sig(T, is_parametric)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$type_sig}) = true\n            end)\n        end\n    end\n    # Case 4: Macro expression that we hope expands to a struct\n    if Meta.isexpr(original_expr, :macrocall)\n        # Try to see if the expanded form is a struct\n        if Meta.isexpr(expr, :struct)\n            ismutable, T, fieldsblock = expr.args\n            T, is_parametric = _extract_type_name(T)\n            type_sig = _make_omit_type_sig(T, is_parametric)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$type_sig}) = true\n            end)\n        else\n            throw(ArgumentError(\"Macro $(original_expr.args[1]) did not expand to a struct definition\"))\n        end\n    end\n    throw(ArgumentError(\"Invalid usage of @$omit_func_name macro. Expected: struct definition, type name, or macro that expands to struct definition\"))\nend\n\n# Helper function to recursively find a struct definition in a block expression\nfunction _find_struct_in_block(expr)\n    if Meta.isexpr(expr, :struct)\n        return expr\n    elseif Meta.isexpr(expr, :block)\n        for arg in expr.args\n            result = _find_struct_in_block(arg)\n            if result !== nothing\n                return result\n            end\n        end\n    end\n    return nothing\nend\n\n# Helper function to extract the base type name from various type expressions\n# Returns (base_type, is_parametric) tuple\nfunction _extract_type_name(T)\n    if isa(T, Symbol)\n        return (T, false)\n    elseif Meta.isexpr(T, :<:)\n        # Handle subtyping: struct Foo <: Bar\n        return _extract_type_name(T.args[1])\n    elseif Meta.isexpr(T, :curly)\n        # Handle parametric types: return just the base type name (e.g., Foo from Foo{T})\n        # and indicate it's parametric\n        return (T.args[1], true)\n    elseif Meta.isexpr(T, :where)\n        # Handle where clauses: struct Foo{T} where T\n        return _extract_type_name(T.args[1])\n    else\n        return (T, false)\n    end\nend\n\nStructUtils.lowerkey(::JSONStyle, s::AbstractString) = s\nStructUtils.lowerkey(::JSONStyle, sym::Symbol) = String(sym)\nStructUtils.lowerkey(::JSONStyle, n::Union{Integer, Union{Float16, Float32, Float64}}) = string(n)\nStructUtils.lowerkey(::JSONStyle, x) = throw(ArgumentError(\"No key representation for $(typeof(x)). Define StructUtils.lowerkey(::$(typeof(x)))\"))\n\n\"\"\"\n    JSON.json(x) -> String\n    JSON.json(io, x)\n    JSON.json(file_name, x)\n\nSerialize `x` to JSON format. The 1st method takes just the object and returns a `String`.\nIn the 2nd method, `io` is an `IO` object, and the JSON output will be written to it.\nFor the 3rd method, `file_name` is a `String`, a file will be opened and the JSON output will be written to it.\n\nAll methods accept the following keyword arguments:\n\n- `omit_null::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are undefined or are `nothing` are included in the JSON output.\n  If `true`, only non-null fields are written. If `false`, all fields are included regardless of being undefined or `nothing`.\n  If `nothing`, the behavior is determined by `JSON.omit_null(::Type{T})`, which is `false` by default.\n\n- `omit_empty::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are empty are included in the JSON output.\n  If `true`, empty fields are excluded. If `false`, empty fields are included.\n  If `nothing`, the behavior is determined by `JSON.omit_empty(::Type{T})`.\n\n- `JSON.Null()` / `JSON.Omit()` sentinels: `JSON.Null()` always emits a JSON `null`\n  literal even when `omit_null=true`, enabling per-field overrides (for example by\n  declaring a field as `Union{Nothing, JSON.Null}`) or defining a custom `lower` function for a field that returns `JSON.Null`.\n  `JSON.Omit()` removes the enclosing value from the output regardless of global omit settings, making it easy for field-level\n  lowering code to drop optional data entirely. For example, by defining a custom `lower` function for a field that returns `JSON.Omit`.\n    \n- `allownan::Bool=false`: If `true`, allow `Inf`, `-Inf`, and `NaN` in the output.\n  If `false`, throw an error if `Inf`, `-Inf`, or `NaN` is encountered.\n\n- `jsonlines::Bool=false`: If `true`, input must be array-like and the output will be written in the JSON Lines format,\n  where each element of the array is written on a separate line (i.e. separated by a single newline character `\\n`).\n  If `false`, the output will be written in the standard JSON format.\n\n- `pretty::Union{Integer,Bool}=false`: Controls pretty printing of the JSON output.\n  If `true`, the output will be pretty-printed with 2 spaces of indentation.\n  If an integer, it will be used as the number of spaces of indentation.\n  If `false` or `0`, the output will be compact.\n  Note: Pretty printing is not supported when `jsonlines=true`.\n\n- `inline_limit::Int=0`: For arrays shorter than this limit, pretty printing will be disabled (indentation set to 0).\n\n- `ninf::String=\"-Infinity\"`: Custom string representation for negative infinity.\n\n- `inf::String=\"Infinity\"`: Custom string representation for positive infinity.\n\n- `nan::String=\"NaN\"`: Custom string representation for NaN.\n\n- `float_style::Symbol=:shortest`: Controls how floating-point numbers are formatted.\n  Options are:\n  - `:shortest`: Use the shortest representation that preserves the value\n  - `:fixed`: Use fixed-point notation\n  - `:exp`: Use exponential notation\n\n- `float_precision::Int=1`: Number of decimal places to use when `float_style` is `:fixed` or `:exp`.\n\n- `bufsize::Int=2^22`: Buffer size in bytes for IO operations. When writing to IO, the buffer will be flushed \n  to the IO stream once it reaches this size. This helps control memory usage during large write operations.\n  Default is 4MB (2^22 bytes). This parameter is ignored when returning a String.\n\n- `style::JSONStyle=JSONWriteStyle()`: Custom style object that controls serialization behavior. This allows customizing\n    certain aspects of serialization, like defining a custom `lower` method for a non-owned type. Like `struct MyStyle <: JSONStyle end`,\n    `JSON.lower(x::Rational) = (num=x.num, den=x.den)`, then calling `JSON.json(1//3; style=MyStyle())` will output\n    `{\"num\": 1, \"den\": 3}`.\n\nBy default, `x` must be a JSON-serializable object. Supported types include:\n  * `AbstractString` => JSON string: types must support the `AbstractString` interface, specifically with support for\n    `ncodeunits` and `codeunit(x, i)`.\n  * `Bool` => JSON boolean: must be `true` or `false`\n  * `Nothing` => JSON null: must be the `nothing` singleton value\n  * `Number` => JSON number: `Integer` subtypes or `Union{Float16, Float32, Float64}` have default implementations\n    for other `Number` types, [`JSON.tostring`](@ref) is first called to convert\n    the value to a `String` before being written directly to JSON output\n  * `AbstractArray`/`Tuple`/`AbstractSet` => JSON array: objects for which `JSON.arraylike` returns `true`\n     are output as JSON arrays. `arraylike` is defined by default for\n    `AbstractArray`, `AbstractSet`, `Tuple`, and `Base.Generator`. For other types that define,\n    they must also properly implement `StructUtils.applyeach` to iterate over the index => elements pairs.\n    Note that arrays with dimensionality > 1 are written as nested arrays, with `N` nestings for `N` dimensions,\n    and the 1st dimension is always the innermost nested JSON array (column-major order).\n  * `AbstractDict`/`NamedTuple`/structs => JSON object: if a value doesn't fall into any of the above categories,\n    it is output as a JSON object. `StructUtils.applyeach` is called, which has appropriate implementations\n    for `AbstractDict`, `NamedTuple`, and structs, where field names => values are iterated over. Field names can\n    be output with an alternative name via field tag overload, like `field::Type &(json=(name=\"alternative_name\",),)`\n\nIf an object is not JSON-serializable, an override for `JSON.lower` can\nbe defined to convert it to a JSON-serializable object. Some default `lower` defintions\nare defined in JSON itself, for example:\n  * `StructUtils.lower(::Missing) = nothing`\n  * `StructUtils.lower(x::Symbol) = String(x)`\n  * `StructUtils.lower(x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType}) = string(x)`\n  * `StructUtils.lower(x::Regex) = x.pattern`\n\nThese allow common Base/stdlib types to be serialized in an expected format.\n\nCircular references are tracked automatically and cycles are broken by writing `null` for any children references.\n\nFor pre-formatted JSON data as a String, use `JSONText(json)` to write the string out as-is.\n\nFor `AbstractDict` objects with non-string keys, `StructUtils.lowerkey` will be called before serializing. This allows aggregate\nor other types of dict keys to be converted to an appropriate string representation. See `StructUtils.liftkey`\nfor the reverse operation, which is called when parsing JSON data back into a dict type.\n\n*NOTE*: `JSON.json` should _not_ be overloaded directly by custom\ntypes as this isn't robust for various output options (IO, String, etc.)\nnor recursive situations. Types should define an appropriate\n`JSON.lower` definition instead.\n\n*NOTE*: `JSON.json(str, indent::Integer)` is special-cased for backwards compatibility with pre-1.0 JSON.jl,\nas this typically would mean \"write out the `indent` integer to file `str`\". As writing out a single integer to\na file is extremely rare, it was decided to keep the pre-1.0 behavior for compatibility reasons.\n\nExamples:\n```julia\nusing Dates\n\nabstract type AbstractMonster end\n\nstruct Dracula <: AbstractMonster\n    num_victims::Int\nend\n\nstruct Werewolf <: AbstractMonster\n    witching_hour::DateTime\nend\n\nstruct Percent <: Number\n    value::Float64\nend\n\nJSON.lower(x::Percent) = x.value\nStructUtils.lowerkey(x::Percent) = string(x.value)\n\n@noarg mutable struct FrankenStruct\n    id::Int\n    name::String # no default to show serialization of an undefined field\n    address::Union{Nothing, String} = nothing\n    rate::Union{Missing, Float64} = missing\n    type::Symbol = :a &(json=(name=\"franken_type\",),)\n    notsure::Any = JSON.Object(\"key\" => \"value\")\n    monster::AbstractMonster = Dracula(10) &(json=(lower=x -> x isa Dracula ? (monster_type=\"vampire\", num_victims=x.num_victims) : (monster_type=\"werewolf\", witching_hour=x.witching_hour),),)\n    percent::Percent = Percent(0.5)\n    birthdate::Date = Date(2025, 1, 1) &(json=(dateformat=\"yyyy/mm/dd\",),)\n    percentages::Dict{Percent, Int} = Dict{Percent, Int}(Percent(0.0) => 0, Percent(1.0) => 1)\n    json_properties::JSONText = JSONText(\"{\\\"key\\\": \\\"value\\\"}\")\n    matrix::Matrix{Float64} = [1.0 2.0; 3.0 4.0]\n    extra_field::Any = nothing &(json=(ignore=true,),)\nend\n\nfranken = FrankenStruct()\nfranken.id = 1\n\njson = JSON.json(franken; omit_null=false)\n# \"{\\\"id\\\":1,\\\"name\\\":null,\\\"address\\\":null,\\\"rate\\\":null,\\\"franken_type\\\":\\\"a\\\",\\\"notsure\\\":{\\\"key\\\":\\\"value\\\"},\\\"monster\\\":{\\\"monster_type\\\":\\\"vampire\\\",\\\"num_victims\\\":10},\\\"percent\\\":0.5,\\\"birthdate\\\":\\\"2025/01/01\\\",\\\"percentages\\\":{\\\"1.0\\\":1,\\\"0.0\\\":0},\\\"json_properties\\\":{\\\"key\\\": \\\"value\\\"},\\\"matrix\\\":[[1.0,3.0],[2.0,4.0]]}\"\n```\n\nA few comments on the JSON produced in the example above:\n  - The `name` field was `#undef`, and thus was serialized as `null`.\n  - The `address` and `rate` fields were `nothing` and `missing`, respectively, and thus were serialized as `null`.\n  - The `type` field has a `name` field tag, so the JSON key for this field is `franken_type` instead of `type`.\n  - The `notsure` field is a `JSON.Object`, so it is serialized as a JSON object.\n  - The `monster` field is a `AbstractMonster`, which is a custom type. It has a `lower` field tag that specifies how the value of this field specifically (not all AbstractMonster) should be serialized\n  - The `percent` field is a `Percent`, which is a custom type. It has a `lower` method that specifies how `Percent` values should be serialized\n  - The `birthdate` field has a `dateformat` field tag, so the value follows the format (`yyyy/mm/dd`) instead of the default date ISO format (`yyyy-mm-dd`)\n  - The `percentages` field is a `Dict{Percent, Int}`, which is a custom type. It has a `lowerkey` method that specifies how `Percent` keys should be serialized as strings\n  - The `json_properties` field is a `JSONText`, so the JSONText value is serialized as-is\n  - The `matrix` field is a `Matrix{Float64}`, which is a custom type. It is serialized as a JSON array, with the first dimension being the innermost nested JSON array (column-major order)\n  - The `extra_field` field has a `ignore` field tag, so it is skipped when serializing\n\n\"\"\"\nfunction json end\n\n@kwdef struct WriteOptions{S}\n    omit_null::Union{Bool, Nothing} = nothing\n    omit_empty::Union{Bool, Nothing} = nothing\n    allownan::Bool = false\n    jsonlines::Bool = false\n    pretty::Int = 0\n    ninf::String = \"-Infinity\"\n    inf::String = \"Infinity\"\n    nan::String = \"NaN\"\n    inline_limit::Int = 0\n    float_style::Symbol = :shortest # :shortest, :fixed, :exp\n    float_precision::Int = 1\n    bufsize::Int = 2^22 # 4MB default buffer size for IO flushing\n    style::S = JSONWriteStyle()\nend\n\n@noinline float_style_throw(fs) = throw(ArgumentError(\"Invalid float style: $fs\"))\nfloat_style_check(fs) = fs == :shortest || fs == :fixed || fs == :exp || float_style_throw(fs)\n\n@noinline float_precision_throw(fs, fp) = throw(ArgumentError(\"float_precision must be positive when float_style is $fs; got $fp\"))\nfloat_precision_check(fs, fp) = (fs == :shortest || fp > 0) || float_precision_throw(fs, fp)\n\n# if jsonlines and pretty is not 0 or false, throw an ArgumentError\n@noinline _jsonlines_pretty_throw() = throw(ArgumentError(\"pretty printing is not supported when writing jsonlines\"))\n_jsonlines_pretty_check(jsonlines, pretty) = jsonlines && pretty !== false && !iszero(pretty) && _jsonlines_pretty_throw()\n@noinline _root_omit_throw() = throw(ArgumentError(\"JSON.Omit() is only valid inside arrays or objects\"))\n\nfunction json(io::IO, x::T; pretty::Union{Integer,Bool}=false, kw...) where {T}\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    # Use smaller initial buffer size, limited by bufsize\n    initial_size = min(sizeguess(y), opts.bufsize)\n    buf = Vector{UInt8}(undef, initial_size)\n    pos = json!(buf, 1, y, opts, Any[y], io)\n    # Write any remaining buffer contents to IO\n    if pos > 1\n        write(io, view(buf, 1:pos-1))\n    end\n    return nothing\nend\n\nif isdefined(Base, :StringVector)\n    stringvec(n) = Base.StringVector(n)\nelse\n    stringvec(n) = Vector{UInt8}(undef, n)\nend\n\nfunction json(x; pretty::Union{Integer,Bool}=false, kw...)\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    buf = stringvec(sizeguess(y))\n    pos = json!(buf, 1, y, opts, Any[y], nothing)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction json(fname, obj; kw...)\n    if obj isa Integer\n        # special-case for pre-1.0 JSON compat\n        return json(fname; pretty=obj)\n    else\n        @assert fname isa AbstractString \"filename must be a string\"\n    end\n    open(fname, \"w\") do io\n        json(io, obj; kw...)\n    end\n    return fname\nend\n\n# we use the same growth strategy as Base julia does for array growing\n# which starts with small N at ~5x and approaches 1.125x as N grows\n# ref: https://github.com/JuliaLang/julia/pull/40453\nnewlen(n\u2080) = ceil(Int, n\u2080 + 4*n\u2080^(7 / 8) + n\u2080 / 8)\n\nmacro checkn(n, force_resize=false)\n    esc(quote\n        if (pos + $n - 1) > length(buf)\n            # If we have an IO object and buffer would exceed bufsize, flush to IO first\n            # unless force_resize is true (used for comma writing to avoid flushing partial JSON)\n            if io !== nothing && length(buf) >= bufsize && pos > 1 && !$force_resize\n                write(io, view(buf, 1:pos-1))\n                pos = 1\n            end\n            # Resize buffer if still needed\n            if (pos + $n - 1) > length(buf)\n                resize!(buf, newlen(pos + $n))\n            end\n        end\n    end)\nend\n\nstruct WriteClosure{JS, arraylike, T, I} # T is the type of the parent object/array being written\n    buf::Vector{UInt8}\n    pos::Ptr{Int}\n    wroteany::Ptr{Bool} # to track if we wrote any data to the buffer\n    indent::Int\n    depth::Int\n    opts::JS\n    ancestor_stack::Vector{Any} # to track circular references\n    io::I\n    bufsize::Int\nend\n\nfunction indent(buf, pos, ind, depth, io, bufsize)\n    if ind > 0\n        n = ind * depth + 1\n        @checkn n\n        buf[pos] = UInt8('\\n')\n        for i = 1:(n - 1)\n            buf[pos + i] = UInt8(' ')\n        end\n        pos += n\n    end\n    return pos\nend\n\ncheckkey(s) = s isa AbstractString || throw(ArgumentError(\"Value returned from `StructUtils.lowerkey` must be a string: $(typeof(s))\"))\n\nfunction (f::WriteClosure{JS, arraylike, T, I})(key, val) where {JS, arraylike, T, I}\n    track_ref = ismutabletype(typeof(val))\n    is_circ_ref = track_ref && any(x -> x === val, f.ancestor_stack)\n    val isa Omit && return\n    if !arraylike\n        # for objects, check omit_null/omit_empty\n        # and skip if the value is null or empty\n        if f.opts.omit_null === true || (f.opts.omit_null === nothing && omit_null(f.opts.style, T))\n            (is_circ_ref || val === nothing) && return\n        end\n        if f.opts.omit_empty === true || (f.opts.omit_empty === nothing && omit_empty(f.opts.style, T))\n            (is_circ_ref || is_empty(val)) && return\n        end\n    end\n    pos = unsafe_load(f.pos)\n    unsafe_store!(f.wroteany, true) # at this point, we know something will be written\n    buf = f.buf\n    ind = f.indent\n    io = f.io\n    bufsize = f.bufsize\n    pos = indent(buf, pos, ind, f.depth, io, bufsize)\n    # if not an array, we need to write the key + ':'\n    if !arraylike\n        # skey = StructUtils.lowerkey(f.opts, key)\n        # check if the key is a string\n        checkkey(key)\n        pos = _string(buf, pos, key, io, bufsize)\n        @checkn 1\n        buf[pos] = UInt8(':')\n        pos += 1\n        if ind > 0\n            @checkn 1\n            buf[pos] = UInt8(' ')\n            pos += 1\n        end\n    end\n    # check if the lowered value is in our ancestor stack\n    if is_circ_ref\n        # if so, it's a circular reference! so we just write `null`\n        pos = _null(buf, pos, io, bufsize)\n    else\n        track_ref && push!(f.ancestor_stack, val)\n        # if jsonlines, we need to recursively set to false\n        if f.opts.jsonlines\n            opts = WriteOptions(; omit_null=f.opts.omit_null, omit_empty=f.opts.omit_empty, allownan=f.opts.allownan, jsonlines=false, pretty=f.opts.pretty, ninf=f.opts.ninf, inf=f.opts.inf, nan=f.opts.nan, inline_limit=f.opts.inline_limit, float_style=f.opts.float_style, float_precision=f.opts.float_precision)\n        else\n            opts = f.opts\n        end\n        pos = json!(buf, pos, val, opts, f.ancestor_stack, io, ind, f.depth, bufsize)\n        track_ref && pop!(f.ancestor_stack)\n    end\n    @checkn 1 true\n    @inbounds buf[pos] = f.opts.jsonlines ? UInt8('\\n') : UInt8(',')\n    pos += 1\n    # store our updated pos\n    unsafe_store!(f.pos, pos)\n    return\nend\n\n@noinline throwjsonlines() = throw(ArgumentError(\"jsonlines only supported for arraylike\"))\n\n# assume x is lowered value\nfunction json!(buf, pos, x, opts::WriteOptions, ancestor_stack::Union{Nothing, Vector{Any}}=nothing, io::Union{Nothing, IO}=nothing, ind::Int=opts.pretty, depth::Int=0, bufsize::Int=opts.bufsize)\n    # string\n    if x isa Omit\n        _root_omit_throw()\n    elseif x isa Null\n        return _null(buf, pos, io, bufsize)\n    elseif x isa AbstractString\n        return _string(buf, pos, x, io, bufsize)\n    # write JSONText out directly\n    elseif x isa JSONText\n        val = x.value\n        @checkn sizeof(val)\n        for i = 1:sizeof(val)\n            @inbounds buf[pos + i - 1] = codeunit(val, i)\n        end\n        return pos + sizeof(val)\n    # bool; check before Number since Bool <: Number\n    elseif x isa Bool\n        if x\n            @checkn 4\n            @inbounds buf[pos] = 't'\n            @inbounds buf[pos + 1] = 'r'\n            @inbounds buf[pos + 2] = 'u'\n            @inbounds buf[pos + 3] = 'e'\n            return pos + 4\n        else\n            @checkn 5\n            @inbounds buf[pos] = 'f'\n            @inbounds buf[pos + 1] = 'a'\n            @inbounds buf[pos + 2] = 'l'\n            @inbounds buf[pos + 3] = 's'\n            @inbounds buf[pos + 4] = 'e'\n            return pos + 5\n        end\n    # number\n    elseif x isa Number\n        return _number(buf, pos, x, opts, io, bufsize)\n    # null\n    elseif x === nothing\n        return _null(buf, pos, io, bufsize)\n    # object or array\n    elseif StructUtils.dictlike(opts.style, x) || StructUtils.arraylike(opts.style, x) || StructUtils.structlike(opts.style, x)\n        al = StructUtils.arraylike(opts.style, x)\n        # override pretty indent to 0 for arrays shorter than inline_limit\n        if al && opts.pretty > 0 && opts.inline_limit > 0 && length(x) < opts.inline_limit\n            local_ind = 0\n        else\n            local_ind = ind\n        end\n        if !opts.jsonlines\n            @checkn 1\n            @inbounds buf[pos] = al ? UInt8('[') : UInt8('{')\n            pos += 1\n        else\n            al || throwjsonlines()\n        end\n        ref = Ref(pos)\n        wroteany = false\n        wroteanyref = Ref(false)\n        GC.@preserve ref wroteanyref begin\n            c = WriteClosure{typeof(opts), al, typeof(x), typeof(io)}(buf, Base.unsafe_convert(Ptr{Int}, ref), Base.unsafe_convert(Ptr{Bool}, wroteanyref), local_ind, depth + 1, opts, ancestor_stack, io, bufsize)\n            StructUtils.applyeach(opts.style, c, x)\n            # get updated pos\n            pos = unsafe_load(c.pos)\n            wroteany = unsafe_load(c.wroteany)\n        end\n        # in WriteClosure, we eagerly write a comma after each element\n        # so for non-empty object/arrays, we can just overwrite the last comma with the closechar\n        if wroteany\n            pos -= 1\n            pos = indent(buf, pos, local_ind, depth, io, bufsize)\n        end\n        # even if the input is empty and we're jsonlines, the spec says it's ok to end w/ a newline\n        @checkn 1\n        @inbounds buf[pos] = opts.jsonlines ? UInt8('\\n') : al ? UInt8(']') : UInt8('}')\n        return pos + 1\n    else\n        return _string(buf, pos, x, io, bufsize)\n    end\nend\n\nfunction _null(buf, pos, io, bufsize)\n    @checkn 4\n    @inbounds buf[pos] = 'n'\n    @inbounds buf[pos + 1] = 'u'\n    @inbounds buf[pos + 2] = 'l'\n    @inbounds buf[pos + 3] = 'l'\n    return pos + 4\nend\n\n_string(buf, pos, x, io, bufsize) = _string(buf, pos, string(x), io, bufsize)\n_string(buf, pos, x::LazyValues, io, bufsize) = _string(buf, pos, getindex(x), io, bufsize)\n_string(buf, pos, x::PtrString, io, bufsize) = _string(buf, pos, convert(String, x), io, bufsize)\n\nfunction _string(buf, pos, x::AbstractString, io, bufsize)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @checkn (el + 2)\n    @inbounds buf[pos] = UInt8('\"')\n    pos += 1\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds buf[pos] = UInt8('\"')\n    return pos + 1\nend\n\n\"\"\"\n    JSON.tostring(x)\n\nOverloadable function that allows non-`Integer` `Number` types\nto convert themselves to a `String` that is then used\nwhen serializing `x` to JSON. Note that if the result of `tostring`\nis not a valid JSON number, it will be serialized as a JSON string,\nwith double quotes around it.\n\nAn example overload would look something like:\n```julia\nJSON.tostring(x::MyDecimal) = string(x)\n```\n\"\"\"\ntostring(x) = string(Float64(x))\n\nsplit_sign(n::Integer) = unsigned(abs(n)), n < 0\nsplit_sign(n::Unsigned) = n, false\nsplit_sign(x::BigInt) = (abs(x), x < 0)\n\n@noinline infcheck(x, allownan) = isfinite(x) || allownan || throw(ArgumentError(\"$x not allowed to be written in JSON spec; pass `allownan=true` to allow anyway\"))\n\nfunction _number(buf, pos, x::Number, opts::WriteOptions, io, bufsize)\n    if x isa Integer\n        y, neg = split_sign(x)\n        n = i = ndigits(y, base=10, pad=1)\n        @checkn (i + neg)\n        if neg\n            @inbounds buf[pos] = UInt8('-')\n            pos += 1\n        end\n        while i > 0\n            @inbounds buf[pos + i - 1] = 48 + rem(y, 10)\n            y = oftype(y, div(y, 10))\n            i -= 1\n        end\n        return pos + n\n    elseif x isa Union{Float16, Float32, Float64}\n        infcheck(x, opts.allownan)\n        if isnan(x)\n            nan = opts.nan\n            @checkn sizeof(nan)\n            for i = 1:sizeof(nan)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(nan, i))\n            end\n            return pos + sizeof(nan)\n        elseif isinf(x)\n            if x < 0\n                inf = opts.ninf\n            else\n                inf = opts.inf\n            end\n            @checkn sizeof(inf)\n            for i = 1:sizeof(inf)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(inf, i))\n            end\n            return pos + sizeof(inf)\n        end\n        if opts.float_style == :shortest\n            @checkn Base.Ryu.neededdigits(typeof(x))\n            return Base.Ryu.writeshortest(buf, pos, x)\n        elseif opts.float_style == :fixed\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writefixed(buf, pos, x, opts.float_precision, false, false, true)\n        elseif opts.float_style == :exp\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writeexp(buf, pos, x, opts.float_precision, false, false, true)\n        else\n            # unreachable as we validate float_style inputs\n            @assert false\n        end\n    else\n        str = tostring(x)\n        if anyinvalidnumberchars(str)\n            # serialize as string\n            return _string(buf, pos, str, io, bufsize)\n        end\n        bytes = codeunits(str)\n        sz = sizeof(bytes)\n        @checkn sz\n        for i = 1:sz\n            @inbounds buf[pos + i - 1] = bytes[i]\n        end\n        return pos + sz\n    end\nend\n\nfunction anyinvalidnumberchars(x)\n    for i = 1:sizeof(x)\n        b = codeunit(x, i)\n        if !(b == UInt8('-') || b == UInt8('.') || b == UInt8('e') || b == UInt8('E') ||\n            UInt8('0') <= b <= UInt8('9'))\n            return true\n        end\n    end\n    return false\nend\n"}, "files_after": {"src/write.jl": "struct JSONWriteStyle <: JSONStyle end\n\n\"\"\"\n    JSON.Null()\n\nSingleton sentinel that always serializes as the JSON literal `null`,\neven when `omit_null=true` at the struct or callsite level. Useful for\nper-field overrides (e.g. `Union{Nothing, JSON.Null}`) or custom field\nlowering that must force a `null` emission.\n\"\"\"\nstruct Null end\n\n\"\"\"\n    JSON.Omit()\n\nSingleton sentinel that removes the enclosing value from the JSON output,\nregardless of `omit_null` / `omit_empty` settings. Valid within objects\nand arrays; using it as the root value throws an error.\n\"\"\"\nstruct Omit end\n\nsizeguess(::Nothing) = 4\nsizeguess(x::Bool) = 5\nsizeguess(x::Integer) = 20\nsizeguess(x::AbstractFloat) = 20\nsizeguess(x::Union{Float16, Float32, Float64}) = Base.Ryu.neededdigits(typeof(x))\nsizeguess(x::AbstractString) = 2 + sizeof(x)\nsizeguess(::Null) = 4\nsizeguess(::Omit) = 0\nsizeguess(_) = 512\n\nStructUtils.lower(::JSONStyle, ::Missing) = nothing\nStructUtils.lower(::JSONStyle, x::Symbol) = String(x)\nStructUtils.lower(::JSONStyle, x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType, Type, Logging.LogLevel}) = string(x)\nStructUtils.lower(::JSONStyle, x::Regex) = x.pattern\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any,0}) = x[1]\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any, N}) where {N} = (view(x, ntuple(_ -> :, N - 1)..., j) for j in axes(x, N))\nStructUtils.lower(::JSONStyle, x::AbstractVector) = x\nStructUtils.arraylike(::JSONStyle, x::AbstractVector{<:Pair}) = false\nStructUtils.structlike(::JSONStyle, ::Type{<:NamedTuple}) = true\n\n# for pre-1.0 compat, which serialized Tuple object keys by default\nStructUtils.lowerkey(::JSONStyle, x::Tuple) = string(x)\n\n\"\"\"\n    JSON.omit_null(::Type{T})::Bool\n    JSON.omit_null(::JSONStyle, ::Type{T})::Bool\n    \nControls whether struct fields that are undefined or are `nothing` are included in the JSON output.\nReturns `false` by default, meaning all fields are included, regardless of undef or `nothing`. To instead\nensure only *non-null* fields are written, set this to `true`.\nThis can also be controlled via the `omit_null` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_null(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_null(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_null(::Type{T}) where {T} = false\nomit_null(::JSONStyle, ::Type{T}) where {T} = omit_null(T)\n\n\"\"\"\n    @omit_null struct T ...\n    @omit_null T\n\nConvenience macro to set `omit_null(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_null struct T ... end`\n2. Applied to an existing struct name: `@omit_null T`\n3. Chained with other macros: `@omit_null @defaults struct T ... end`\n\nThe macro automatically handles complex macro expansions by walking the expression\ntree to find struct definitions, making it compatible with macros like `StructUtils.@defaults`.\n\n# Examples\n```julia\n# Method 1: Struct annotation\n@omit_null struct Person\n    name::String\n    email::Union{Nothing, String}\nend\n\n# Method 2: Apply to existing struct\nstruct User\n    id::Int\n    profile::Union{Nothing, String}\nend\n@omit_null User\n\n# Method 3: Chain with @defaults\n@omit_null @defaults struct Employee\n    name::String = \"Anonymous\"\n    manager::Union{Nothing, String} = nothing\nend\n```\n\"\"\"\nmacro omit_null(expr)\n    return _omit_macro_impl(expr, :omit_null, __module__)\nend\n\n\"\"\"\n    JSON.omit_empty(::Type{T})::Bool\n    JSON.omit_empty(::JSONStyle, ::Type{T})::Bool\n\nControls whether struct fields that are empty are included in the JSON output.\nReturns `false` by default, meaning empty fields *are* included. To instead exclude empty fields,\nset this to `true`. A field is considered empty if it is `nothing`, an empty collection\n(empty array, dict, string, tuple, or named tuple), or `missing`.\nThis can also be controlled via the `omit_empty` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_empty(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_empty(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_empty(::Type{T}) where {T} = false\nomit_empty(::JSONStyle, ::Type{T}) where {T} = omit_empty(T)\n\nis_empty(x) = false\nis_empty(::Nothing) = true\nis_empty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = Base.isempty(x)\n\n\"\"\"\n    @omit_empty struct T ...\n    @omit_empty T\n\nConvenience macro to set `omit_empty(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_empty struct T ... end`\n2. Applied to an existing struct name: `@omit_empty T`\n3. Chained with other macros: `@omit_empty @other_macro struct T ... end`\n\"\"\"\nmacro omit_empty(expr)\n    return _omit_macro_impl(expr, :omit_empty, __module__)\nend\n\n# Helper function to generate the appropriate type signature for omit functions\nfunction _make_omit_type_sig(T, is_parametric)\n    if is_parametric\n        # For parametric types, use <: to match all instantiations\n        return :(<:$T)\n    else\n        return T\n    end\nend\n\n# Helper function for both @omit_null and @omit_empty macros\nfunction _omit_macro_impl(expr, omit_func_name, module_context)\n    original_expr = expr\n    expr = macroexpand(module_context, expr)\n    # Case 1: Just a type name (Symbol or more complex type expression)\n    if isa(expr, Symbol) || (Meta.isexpr(expr, :curly) || Meta.isexpr(expr, :where))\n        # Extract the base type name\n        T, is_parametric = _extract_type_name(expr)\n        type_sig = _make_omit_type_sig(T, is_parametric)\n        return esc(quote\n            JSON.$omit_func_name(::Type{$type_sig}) = true\n        end)\n    end\n    # Case 2: Struct definition (possibly from macro expansion)\n    if Meta.isexpr(expr, :struct)\n        ismutable, T, fieldsblock = expr.args\n        T, is_parametric = _extract_type_name(T)\n        type_sig = _make_omit_type_sig(T, is_parametric)\n        return esc(quote\n            # insert original expr as-is\n            $expr\n            # omit function overload\n            JSON.$omit_func_name(::Type{$type_sig}) = true\n        end)\n    end\n    # Case 3: Block expression (from complex macros like @defaults)\n    if Meta.isexpr(expr, :block)\n        # Try to find a struct definition in the block\n        struct_expr = _find_struct_in_block(expr)\n        if struct_expr !== nothing\n            ismutable, T, fieldsblock = struct_expr.args\n            T, is_parametric = _extract_type_name(T)\n            type_sig = _make_omit_type_sig(T, is_parametric)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$type_sig}) = true\n            end)\n        end\n    end\n    # Case 4: Macro expression that we hope expands to a struct\n    if Meta.isexpr(original_expr, :macrocall)\n        # Try to see if the expanded form is a struct\n        if Meta.isexpr(expr, :struct)\n            ismutable, T, fieldsblock = expr.args\n            T, is_parametric = _extract_type_name(T)\n            type_sig = _make_omit_type_sig(T, is_parametric)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$type_sig}) = true\n            end)\n        else\n            throw(ArgumentError(\"Macro $(original_expr.args[1]) did not expand to a struct definition\"))\n        end\n    end\n    throw(ArgumentError(\"Invalid usage of @$omit_func_name macro. Expected: struct definition, type name, or macro that expands to struct definition\"))\nend\n\n# Helper function to recursively find a struct definition in a block expression\nfunction _find_struct_in_block(expr)\n    if Meta.isexpr(expr, :struct)\n        return expr\n    elseif Meta.isexpr(expr, :block)\n        for arg in expr.args\n            result = _find_struct_in_block(arg)\n            if result !== nothing\n                return result\n            end\n        end\n    end\n    return nothing\nend\n\n# Helper function to extract the base type name from various type expressions\n# Returns (base_type, is_parametric) tuple\nfunction _extract_type_name(T)\n    if isa(T, Symbol)\n        return (T, false)\n    elseif Meta.isexpr(T, :<:)\n        # Handle subtyping: struct Foo <: Bar\n        return _extract_type_name(T.args[1])\n    elseif Meta.isexpr(T, :curly)\n        # Handle parametric types: return just the base type name (e.g., Foo from Foo{T})\n        # and indicate it's parametric\n        return (T.args[1], true)\n    elseif Meta.isexpr(T, :where)\n        # Handle where clauses: struct Foo{T} where T\n        return _extract_type_name(T.args[1])\n    else\n        return (T, false)\n    end\nend\n\nStructUtils.lowerkey(::JSONStyle, s::AbstractString) = s\nStructUtils.lowerkey(::JSONStyle, sym::Symbol) = String(sym)\nStructUtils.lowerkey(::JSONStyle, n::Union{Integer, Union{Float16, Float32, Float64}}) = string(n)\nStructUtils.lowerkey(::JSONStyle, x) = throw(ArgumentError(\"No key representation for $(typeof(x)). Define StructUtils.lowerkey(::JSON.JSONStyle, ::$(typeof(x)))\"))\n\n\"\"\"\n    JSON.json(x) -> String\n    JSON.json(io, x)\n    JSON.json(file_name, x)\n\nSerialize `x` to JSON format. The 1st method takes just the object and returns a `String`.\nIn the 2nd method, `io` is an `IO` object, and the JSON output will be written to it.\nFor the 3rd method, `file_name` is a `String`, a file will be opened and the JSON output will be written to it.\n\nAll methods accept the following keyword arguments:\n\n- `omit_null::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are undefined or are `nothing` are included in the JSON output.\n  If `true`, only non-null fields are written. If `false`, all fields are included regardless of being undefined or `nothing`.\n  If `nothing`, the behavior is determined by `JSON.omit_null(::Type{T})`, which is `false` by default.\n\n- `omit_empty::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are empty are included in the JSON output.\n  If `true`, empty fields are excluded. If `false`, empty fields are included.\n  If `nothing`, the behavior is determined by `JSON.omit_empty(::Type{T})`.\n\n- `JSON.Null()` / `JSON.Omit()` sentinels: `JSON.Null()` always emits a JSON `null`\n  literal even when `omit_null=true`, enabling per-field overrides (for example by\n  declaring a field as `Union{Nothing, JSON.Null}`) or defining a custom `lower` function for a field that returns `JSON.Null`.\n  `JSON.Omit()` removes the enclosing value from the output regardless of global omit settings, making it easy for field-level\n  lowering code to drop optional data entirely. For example, by defining a custom `lower` function for a field that returns `JSON.Omit`.\n    \n- `allownan::Bool=false`: If `true`, allow `Inf`, `-Inf`, and `NaN` in the output.\n  If `false`, throw an error if `Inf`, `-Inf`, or `NaN` is encountered.\n\n- `jsonlines::Bool=false`: If `true`, input must be array-like and the output will be written in the JSON Lines format,\n  where each element of the array is written on a separate line (i.e. separated by a single newline character `\\n`).\n  If `false`, the output will be written in the standard JSON format.\n\n- `pretty::Union{Integer,Bool}=false`: Controls pretty printing of the JSON output.\n  If `true`, the output will be pretty-printed with 2 spaces of indentation.\n  If an integer, it will be used as the number of spaces of indentation.\n  If `false` or `0`, the output will be compact.\n  Note: Pretty printing is not supported when `jsonlines=true`.\n\n- `inline_limit::Int=0`: For arrays shorter than this limit, pretty printing will be disabled (indentation set to 0).\n\n- `ninf::String=\"-Infinity\"`: Custom string representation for negative infinity.\n\n- `inf::String=\"Infinity\"`: Custom string representation for positive infinity.\n\n- `nan::String=\"NaN\"`: Custom string representation for NaN.\n\n- `float_style::Symbol=:shortest`: Controls how floating-point numbers are formatted.\n  Options are:\n  - `:shortest`: Use the shortest representation that preserves the value\n  - `:fixed`: Use fixed-point notation\n  - `:exp`: Use exponential notation\n\n- `float_precision::Int=1`: Number of decimal places to use when `float_style` is `:fixed` or `:exp`.\n\n- `bufsize::Int=2^22`: Buffer size in bytes for IO operations. When writing to IO, the buffer will be flushed \n  to the IO stream once it reaches this size. This helps control memory usage during large write operations.\n  Default is 4MB (2^22 bytes). This parameter is ignored when returning a String.\n\n- `style::JSONStyle=JSONWriteStyle()`: Custom style object that controls serialization behavior. This allows customizing\n    certain aspects of serialization, like defining a custom `lower` method for a non-owned type. Like `struct MyStyle <: JSONStyle end`,\n    `JSON.lower(x::Rational) = (num=x.num, den=x.den)`, then calling `JSON.json(1//3; style=MyStyle())` will output\n    `{\"num\": 1, \"den\": 3}`.\n\nBy default, `x` must be a JSON-serializable object. Supported types include:\n  * `AbstractString` => JSON string: types must support the `AbstractString` interface, specifically with support for\n    `ncodeunits` and `codeunit(x, i)`.\n  * `Bool` => JSON boolean: must be `true` or `false`\n  * `Nothing` => JSON null: must be the `nothing` singleton value\n  * `Number` => JSON number: `Integer` subtypes or `Union{Float16, Float32, Float64}` have default implementations\n    for other `Number` types, [`JSON.tostring`](@ref) is first called to convert\n    the value to a `String` before being written directly to JSON output\n  * `AbstractArray`/`Tuple`/`AbstractSet` => JSON array: objects for which `JSON.arraylike` returns `true`\n     are output as JSON arrays. `arraylike` is defined by default for\n    `AbstractArray`, `AbstractSet`, `Tuple`, and `Base.Generator`. For other types that define,\n    they must also properly implement `StructUtils.applyeach` to iterate over the index => elements pairs.\n    Note that arrays with dimensionality > 1 are written as nested arrays, with `N` nestings for `N` dimensions,\n    and the 1st dimension is always the innermost nested JSON array (column-major order).\n  * `AbstractDict`/`NamedTuple`/structs => JSON object: if a value doesn't fall into any of the above categories,\n    it is output as a JSON object. `StructUtils.applyeach` is called, which has appropriate implementations\n    for `AbstractDict`, `NamedTuple`, and structs, where field names => values are iterated over. Field names can\n    be output with an alternative name via field tag overload, like `field::Type &(json=(name=\"alternative_name\",),)`\n\nIf an object is not JSON-serializable, an override for `JSON.lower` can\nbe defined to convert it to a JSON-serializable object. Some default `lower` defintions\nare defined in JSON itself, for example:\n  * `StructUtils.lower(::Missing) = nothing`\n  * `StructUtils.lower(x::Symbol) = String(x)`\n  * `StructUtils.lower(x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType}) = string(x)`\n  * `StructUtils.lower(x::Regex) = x.pattern`\n\nThese allow common Base/stdlib types to be serialized in an expected format.\n\nCircular references are tracked automatically and cycles are broken by writing `null` for any children references.\n\nFor pre-formatted JSON data as a String, use `JSONText(json)` to write the string out as-is.\n\nFor `AbstractDict` objects with non-string keys, `StructUtils.lowerkey` will be called before serializing. This allows aggregate\nor other types of dict keys to be converted to an appropriate string representation. See `StructUtils.liftkey`\nfor the reverse operation, which is called when parsing JSON data back into a dict type.\n\n*NOTE*: `JSON.json` should _not_ be overloaded directly by custom\ntypes as this isn't robust for various output options (IO, String, etc.)\nnor recursive situations. Types should define an appropriate\n`JSON.lower` definition instead.\n\n*NOTE*: `JSON.json(str, indent::Integer)` is special-cased for backwards compatibility with pre-1.0 JSON.jl,\nas this typically would mean \"write out the `indent` integer to file `str`\". As writing out a single integer to\na file is extremely rare, it was decided to keep the pre-1.0 behavior for compatibility reasons.\n\nExamples:\n```julia\nusing Dates\n\nabstract type AbstractMonster end\n\nstruct Dracula <: AbstractMonster\n    num_victims::Int\nend\n\nstruct Werewolf <: AbstractMonster\n    witching_hour::DateTime\nend\n\nstruct Percent <: Number\n    value::Float64\nend\n\nJSON.lower(x::Percent) = x.value\nStructUtils.lowerkey(x::Percent) = string(x.value)\n\n@noarg mutable struct FrankenStruct\n    id::Int\n    name::String # no default to show serialization of an undefined field\n    address::Union{Nothing, String} = nothing\n    rate::Union{Missing, Float64} = missing\n    type::Symbol = :a &(json=(name=\"franken_type\",),)\n    notsure::Any = JSON.Object(\"key\" => \"value\")\n    monster::AbstractMonster = Dracula(10) &(json=(lower=x -> x isa Dracula ? (monster_type=\"vampire\", num_victims=x.num_victims) : (monster_type=\"werewolf\", witching_hour=x.witching_hour),),)\n    percent::Percent = Percent(0.5)\n    birthdate::Date = Date(2025, 1, 1) &(json=(dateformat=\"yyyy/mm/dd\",),)\n    percentages::Dict{Percent, Int} = Dict{Percent, Int}(Percent(0.0) => 0, Percent(1.0) => 1)\n    json_properties::JSONText = JSONText(\"{\\\"key\\\": \\\"value\\\"}\")\n    matrix::Matrix{Float64} = [1.0 2.0; 3.0 4.0]\n    extra_field::Any = nothing &(json=(ignore=true,),)\nend\n\nfranken = FrankenStruct()\nfranken.id = 1\n\njson = JSON.json(franken; omit_null=false)\n# \"{\\\"id\\\":1,\\\"name\\\":null,\\\"address\\\":null,\\\"rate\\\":null,\\\"franken_type\\\":\\\"a\\\",\\\"notsure\\\":{\\\"key\\\":\\\"value\\\"},\\\"monster\\\":{\\\"monster_type\\\":\\\"vampire\\\",\\\"num_victims\\\":10},\\\"percent\\\":0.5,\\\"birthdate\\\":\\\"2025/01/01\\\",\\\"percentages\\\":{\\\"1.0\\\":1,\\\"0.0\\\":0},\\\"json_properties\\\":{\\\"key\\\": \\\"value\\\"},\\\"matrix\\\":[[1.0,3.0],[2.0,4.0]]}\"\n```\n\nA few comments on the JSON produced in the example above:\n  - The `name` field was `#undef`, and thus was serialized as `null`.\n  - The `address` and `rate` fields were `nothing` and `missing`, respectively, and thus were serialized as `null`.\n  - The `type` field has a `name` field tag, so the JSON key for this field is `franken_type` instead of `type`.\n  - The `notsure` field is a `JSON.Object`, so it is serialized as a JSON object.\n  - The `monster` field is a `AbstractMonster`, which is a custom type. It has a `lower` field tag that specifies how the value of this field specifically (not all AbstractMonster) should be serialized\n  - The `percent` field is a `Percent`, which is a custom type. It has a `lower` method that specifies how `Percent` values should be serialized\n  - The `birthdate` field has a `dateformat` field tag, so the value follows the format (`yyyy/mm/dd`) instead of the default date ISO format (`yyyy-mm-dd`)\n  - The `percentages` field is a `Dict{Percent, Int}`, which is a custom type. It has a `lowerkey` method that specifies how `Percent` keys should be serialized as strings\n  - The `json_properties` field is a `JSONText`, so the JSONText value is serialized as-is\n  - The `matrix` field is a `Matrix{Float64}`, which is a custom type. It is serialized as a JSON array, with the first dimension being the innermost nested JSON array (column-major order)\n  - The `extra_field` field has a `ignore` field tag, so it is skipped when serializing\n\n\"\"\"\nfunction json end\n\n@kwdef struct WriteOptions{S}\n    omit_null::Union{Bool, Nothing} = nothing\n    omit_empty::Union{Bool, Nothing} = nothing\n    allownan::Bool = false\n    jsonlines::Bool = false\n    pretty::Int = 0\n    ninf::String = \"-Infinity\"\n    inf::String = \"Infinity\"\n    nan::String = \"NaN\"\n    inline_limit::Int = 0\n    float_style::Symbol = :shortest # :shortest, :fixed, :exp\n    float_precision::Int = 1\n    bufsize::Int = 2^22 # 4MB default buffer size for IO flushing\n    style::S = JSONWriteStyle()\nend\n\n@noinline float_style_throw(fs) = throw(ArgumentError(\"Invalid float style: $fs\"))\nfloat_style_check(fs) = fs == :shortest || fs == :fixed || fs == :exp || float_style_throw(fs)\n\n@noinline float_precision_throw(fs, fp) = throw(ArgumentError(\"float_precision must be positive when float_style is $fs; got $fp\"))\nfloat_precision_check(fs, fp) = (fs == :shortest || fp > 0) || float_precision_throw(fs, fp)\n\n# if jsonlines and pretty is not 0 or false, throw an ArgumentError\n@noinline _jsonlines_pretty_throw() = throw(ArgumentError(\"pretty printing is not supported when writing jsonlines\"))\n_jsonlines_pretty_check(jsonlines, pretty) = jsonlines && pretty !== false && !iszero(pretty) && _jsonlines_pretty_throw()\n@noinline _root_omit_throw() = throw(ArgumentError(\"JSON.Omit() is only valid inside arrays or objects\"))\n\nfunction json(io::IO, x::T; pretty::Union{Integer,Bool}=false, kw...) where {T}\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    # Use smaller initial buffer size, limited by bufsize\n    initial_size = min(sizeguess(y), opts.bufsize)\n    buf = Vector{UInt8}(undef, initial_size)\n    pos = json!(buf, 1, y, opts, Any[y], io)\n    # Write any remaining buffer contents to IO\n    if pos > 1\n        write(io, view(buf, 1:pos-1))\n    end\n    return nothing\nend\n\nif isdefined(Base, :StringVector)\n    stringvec(n) = Base.StringVector(n)\nelse\n    stringvec(n) = Vector{UInt8}(undef, n)\nend\n\nfunction json(x; pretty::Union{Integer,Bool}=false, kw...)\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    buf = stringvec(sizeguess(y))\n    pos = json!(buf, 1, y, opts, Any[y], nothing)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction json(fname, obj; kw...)\n    if obj isa Integer\n        # special-case for pre-1.0 JSON compat\n        return json(fname; pretty=obj)\n    else\n        @assert fname isa AbstractString \"filename must be a string\"\n    end\n    open(fname, \"w\") do io\n        json(io, obj; kw...)\n    end\n    return fname\nend\n\n# we use the same growth strategy as Base julia does for array growing\n# which starts with small N at ~5x and approaches 1.125x as N grows\n# ref: https://github.com/JuliaLang/julia/pull/40453\nnewlen(n\u2080) = ceil(Int, n\u2080 + 4*n\u2080^(7 / 8) + n\u2080 / 8)\n\nmacro checkn(n, force_resize=false)\n    esc(quote\n        if (pos + $n - 1) > length(buf)\n            # If we have an IO object and buffer would exceed bufsize, flush to IO first\n            # unless force_resize is true (used for comma writing to avoid flushing partial JSON)\n            if io !== nothing && length(buf) >= bufsize && pos > 1 && !$force_resize\n                write(io, view(buf, 1:pos-1))\n                pos = 1\n            end\n            # Resize buffer if still needed\n            if (pos + $n - 1) > length(buf)\n                resize!(buf, newlen(pos + $n))\n            end\n        end\n    end)\nend\n\nstruct WriteClosure{JS, arraylike, T, I} # T is the type of the parent object/array being written\n    buf::Vector{UInt8}\n    pos::Ptr{Int}\n    wroteany::Ptr{Bool} # to track if we wrote any data to the buffer\n    indent::Int\n    depth::Int\n    opts::JS\n    ancestor_stack::Vector{Any} # to track circular references\n    io::I\n    bufsize::Int\nend\n\nfunction indent(buf, pos, ind, depth, io, bufsize)\n    if ind > 0\n        n = ind * depth + 1\n        @checkn n\n        buf[pos] = UInt8('\\n')\n        for i = 1:(n - 1)\n            buf[pos + i] = UInt8(' ')\n        end\n        pos += n\n    end\n    return pos\nend\n\ncheckkey(s) = s isa AbstractString || throw(ArgumentError(\"Value returned from `StructUtils.lowerkey` must be a string: $(typeof(s))\"))\n\nfunction (f::WriteClosure{JS, arraylike, T, I})(key, val) where {JS, arraylike, T, I}\n    track_ref = ismutabletype(typeof(val))\n    is_circ_ref = track_ref && any(x -> x === val, f.ancestor_stack)\n    val isa Omit && return\n    if !arraylike\n        # for objects, check omit_null/omit_empty\n        # and skip if the value is null or empty\n        if f.opts.omit_null === true || (f.opts.omit_null === nothing && omit_null(f.opts.style, T))\n            (is_circ_ref || val === nothing) && return\n        end\n        if f.opts.omit_empty === true || (f.opts.omit_empty === nothing && omit_empty(f.opts.style, T))\n            (is_circ_ref || is_empty(val)) && return\n        end\n    end\n    pos = unsafe_load(f.pos)\n    unsafe_store!(f.wroteany, true) # at this point, we know something will be written\n    buf = f.buf\n    ind = f.indent\n    io = f.io\n    bufsize = f.bufsize\n    pos = indent(buf, pos, ind, f.depth, io, bufsize)\n    # if not an array, we need to write the key + ':'\n    if !arraylike\n        # skey = StructUtils.lowerkey(f.opts, key)\n        # check if the key is a string\n        checkkey(key)\n        pos = _string(buf, pos, key, io, bufsize)\n        @checkn 1\n        buf[pos] = UInt8(':')\n        pos += 1\n        if ind > 0\n            @checkn 1\n            buf[pos] = UInt8(' ')\n            pos += 1\n        end\n    end\n    # check if the lowered value is in our ancestor stack\n    if is_circ_ref\n        # if so, it's a circular reference! so we just write `null`\n        pos = _null(buf, pos, io, bufsize)\n    else\n        track_ref && push!(f.ancestor_stack, val)\n        # if jsonlines, we need to recursively set to false\n        if f.opts.jsonlines\n            opts = WriteOptions(; omit_null=f.opts.omit_null, omit_empty=f.opts.omit_empty, allownan=f.opts.allownan, jsonlines=false, pretty=f.opts.pretty, ninf=f.opts.ninf, inf=f.opts.inf, nan=f.opts.nan, inline_limit=f.opts.inline_limit, float_style=f.opts.float_style, float_precision=f.opts.float_precision)\n        else\n            opts = f.opts\n        end\n        pos = json!(buf, pos, val, opts, f.ancestor_stack, io, ind, f.depth, bufsize)\n        track_ref && pop!(f.ancestor_stack)\n    end\n    @checkn 1 true\n    @inbounds buf[pos] = f.opts.jsonlines ? UInt8('\\n') : UInt8(',')\n    pos += 1\n    # store our updated pos\n    unsafe_store!(f.pos, pos)\n    return\nend\n\n@noinline throwjsonlines() = throw(ArgumentError(\"jsonlines only supported for arraylike\"))\n\n# assume x is lowered value\nfunction json!(buf, pos, x, opts::WriteOptions, ancestor_stack::Union{Nothing, Vector{Any}}=nothing, io::Union{Nothing, IO}=nothing, ind::Int=opts.pretty, depth::Int=0, bufsize::Int=opts.bufsize)\n    # string\n    if x isa Omit\n        _root_omit_throw()\n    elseif x isa Null\n        return _null(buf, pos, io, bufsize)\n    elseif x isa AbstractString\n        return _string(buf, pos, x, io, bufsize)\n    # write JSONText out directly\n    elseif x isa JSONText\n        val = x.value\n        @checkn sizeof(val)\n        for i = 1:sizeof(val)\n            @inbounds buf[pos + i - 1] = codeunit(val, i)\n        end\n        return pos + sizeof(val)\n    # bool; check before Number since Bool <: Number\n    elseif x isa Bool\n        if x\n            @checkn 4\n            @inbounds buf[pos] = 't'\n            @inbounds buf[pos + 1] = 'r'\n            @inbounds buf[pos + 2] = 'u'\n            @inbounds buf[pos + 3] = 'e'\n            return pos + 4\n        else\n            @checkn 5\n            @inbounds buf[pos] = 'f'\n            @inbounds buf[pos + 1] = 'a'\n            @inbounds buf[pos + 2] = 'l'\n            @inbounds buf[pos + 3] = 's'\n            @inbounds buf[pos + 4] = 'e'\n            return pos + 5\n        end\n    # number\n    elseif x isa Number\n        return _number(buf, pos, x, opts, io, bufsize)\n    # null\n    elseif x === nothing\n        return _null(buf, pos, io, bufsize)\n    # object or array\n    elseif StructUtils.dictlike(opts.style, x) || StructUtils.arraylike(opts.style, x) || StructUtils.structlike(opts.style, x)\n        al = StructUtils.arraylike(opts.style, x)\n        # override pretty indent to 0 for arrays shorter than inline_limit\n        if al && opts.pretty > 0 && opts.inline_limit > 0 && length(x) < opts.inline_limit\n            local_ind = 0\n        else\n            local_ind = ind\n        end\n        if !opts.jsonlines\n            @checkn 1\n            @inbounds buf[pos] = al ? UInt8('[') : UInt8('{')\n            pos += 1\n        else\n            al || throwjsonlines()\n        end\n        ref = Ref(pos)\n        wroteany = false\n        wroteanyref = Ref(false)\n        GC.@preserve ref wroteanyref begin\n            c = WriteClosure{typeof(opts), al, typeof(x), typeof(io)}(buf, Base.unsafe_convert(Ptr{Int}, ref), Base.unsafe_convert(Ptr{Bool}, wroteanyref), local_ind, depth + 1, opts, ancestor_stack, io, bufsize)\n            StructUtils.applyeach(opts.style, c, x)\n            # get updated pos\n            pos = unsafe_load(c.pos)\n            wroteany = unsafe_load(c.wroteany)\n        end\n        # in WriteClosure, we eagerly write a comma after each element\n        # so for non-empty object/arrays, we can just overwrite the last comma with the closechar\n        if wroteany\n            pos -= 1\n            pos = indent(buf, pos, local_ind, depth, io, bufsize)\n        end\n        # even if the input is empty and we're jsonlines, the spec says it's ok to end w/ a newline\n        @checkn 1\n        @inbounds buf[pos] = opts.jsonlines ? UInt8('\\n') : al ? UInt8(']') : UInt8('}')\n        return pos + 1\n    else\n        return _string(buf, pos, x, io, bufsize)\n    end\nend\n\nfunction _null(buf, pos, io, bufsize)\n    @checkn 4\n    @inbounds buf[pos] = 'n'\n    @inbounds buf[pos + 1] = 'u'\n    @inbounds buf[pos + 2] = 'l'\n    @inbounds buf[pos + 3] = 'l'\n    return pos + 4\nend\n\n_string(buf, pos, x, io, bufsize) = _string(buf, pos, string(x), io, bufsize)\n_string(buf, pos, x::LazyValues, io, bufsize) = _string(buf, pos, getindex(x), io, bufsize)\n_string(buf, pos, x::PtrString, io, bufsize) = _string(buf, pos, convert(String, x), io, bufsize)\n\nfunction _string(buf, pos, x::AbstractString, io, bufsize)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @checkn (el + 2)\n    @inbounds buf[pos] = UInt8('\"')\n    pos += 1\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds buf[pos] = UInt8('\"')\n    return pos + 1\nend\n\n\"\"\"\n    JSON.tostring(x)\n\nOverloadable function that allows non-`Integer` `Number` types\nto convert themselves to a `String` that is then used\nwhen serializing `x` to JSON. Note that if the result of `tostring`\nis not a valid JSON number, it will be serialized as a JSON string,\nwith double quotes around it.\n\nAn example overload would look something like:\n```julia\nJSON.tostring(x::MyDecimal) = string(x)\n```\n\"\"\"\ntostring(x) = string(Float64(x))\n\nsplit_sign(n::Integer) = unsigned(abs(n)), n < 0\nsplit_sign(n::Unsigned) = n, false\nsplit_sign(x::BigInt) = (abs(x), x < 0)\n\n@noinline infcheck(x, allownan) = isfinite(x) || allownan || throw(ArgumentError(\"$x not allowed to be written in JSON spec; pass `allownan=true` to allow anyway\"))\n\nfunction _number(buf, pos, x::Number, opts::WriteOptions, io, bufsize)\n    if x isa Integer\n        y, neg = split_sign(x)\n        n = i = ndigits(y, base=10, pad=1)\n        @checkn (i + neg)\n        if neg\n            @inbounds buf[pos] = UInt8('-')\n            pos += 1\n        end\n        while i > 0\n            @inbounds buf[pos + i - 1] = 48 + rem(y, 10)\n            y = oftype(y, div(y, 10))\n            i -= 1\n        end\n        return pos + n\n    elseif x isa Union{Float16, Float32, Float64}\n        infcheck(x, opts.allownan)\n        if isnan(x)\n            nan = opts.nan\n            @checkn sizeof(nan)\n            for i = 1:sizeof(nan)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(nan, i))\n            end\n            return pos + sizeof(nan)\n        elseif isinf(x)\n            if x < 0\n                inf = opts.ninf\n            else\n                inf = opts.inf\n            end\n            @checkn sizeof(inf)\n            for i = 1:sizeof(inf)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(inf, i))\n            end\n            return pos + sizeof(inf)\n        end\n        if opts.float_style == :shortest\n            @checkn Base.Ryu.neededdigits(typeof(x))\n            return Base.Ryu.writeshortest(buf, pos, x)\n        elseif opts.float_style == :fixed\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writefixed(buf, pos, x, opts.float_precision, false, false, true)\n        elseif opts.float_style == :exp\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writeexp(buf, pos, x, opts.float_precision, false, false, true)\n        else\n            # unreachable as we validate float_style inputs\n            @assert false\n        end\n    else\n        str = tostring(x)\n        if anyinvalidnumberchars(str)\n            # serialize as string\n            return _string(buf, pos, str, io, bufsize)\n        end\n        bytes = codeunits(str)\n        sz = sizeof(bytes)\n        @checkn sz\n        for i = 1:sz\n            @inbounds buf[pos + i - 1] = bytes[i]\n        end\n        return pos + sz\n    end\nend\n\nfunction anyinvalidnumberchars(x)\n    for i = 1:sizeof(x)\n        b = codeunit(x, i)\n        if !(b == UInt8('-') || b == UInt8('.') || b == UInt8('e') || b == UInt8('E') ||\n            UInt8('0') <= b <= UInt8('9'))\n            return true\n        end\n    end\n    return false\nend\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": true, "validation_errors": []}
{"repo": "JSON.jl", "commit_sha": "74798291682b0bc3458c04527c7915699b19502a", "parent_sha": "8d648bd094ddaa760d9d7dc146acb39edd6538e1", "commit_message": "fix @omit_null/@omit_empty macros for parametric types (#425)", "commit_date": "2026-01-14T00:27:07-07:00", "action": {"type": "ADD_METHOD", "target_file": "src/write.jl", "target_symbol": "_make_omit_type_sig", "signature": null, "confidence": 0.85}, "files_before": {"src/write.jl": "struct JSONWriteStyle <: JSONStyle end\n\n\"\"\"\n    JSON.Null()\n\nSingleton sentinel that always serializes as the JSON literal `null`,\neven when `omit_null=true` at the struct or callsite level. Useful for\nper-field overrides (e.g. `Union{Nothing, JSON.Null}`) or custom field\nlowering that must force a `null` emission.\n\"\"\"\nstruct Null end\n\n\"\"\"\n    JSON.Omit()\n\nSingleton sentinel that removes the enclosing value from the JSON output,\nregardless of `omit_null` / `omit_empty` settings. Valid within objects\nand arrays; using it as the root value throws an error.\n\"\"\"\nstruct Omit end\n\nsizeguess(::Nothing) = 4\nsizeguess(x::Bool) = 5\nsizeguess(x::Integer) = 20\nsizeguess(x::AbstractFloat) = 20\nsizeguess(x::Union{Float16, Float32, Float64}) = Base.Ryu.neededdigits(typeof(x))\nsizeguess(x::AbstractString) = 2 + sizeof(x)\nsizeguess(::Null) = 4\nsizeguess(::Omit) = 0\nsizeguess(_) = 512\n\nStructUtils.lower(::JSONStyle, ::Missing) = nothing\nStructUtils.lower(::JSONStyle, x::Symbol) = String(x)\nStructUtils.lower(::JSONStyle, x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType, Type, Logging.LogLevel}) = string(x)\nStructUtils.lower(::JSONStyle, x::Regex) = x.pattern\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any,0}) = x[1]\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any, N}) where {N} = (view(x, ntuple(_ -> :, N - 1)..., j) for j in axes(x, N))\nStructUtils.lower(::JSONStyle, x::AbstractVector) = x\nStructUtils.arraylike(::JSONStyle, x::AbstractVector{<:Pair}) = false\nStructUtils.structlike(::JSONStyle, ::Type{<:NamedTuple}) = true\n\n# for pre-1.0 compat, which serialized Tuple object keys by default\nStructUtils.lowerkey(::JSONStyle, x::Tuple) = string(x)\n\n\"\"\"\n    JSON.omit_null(::Type{T})::Bool\n    JSON.omit_null(::JSONStyle, ::Type{T})::Bool\n    \nControls whether struct fields that are undefined or are `nothing` are included in the JSON output.\nReturns `false` by default, meaning all fields are included, regardless of undef or `nothing`. To instead\nensure only *non-null* fields are written, set this to `true`.\nThis can also be controlled via the `omit_null` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_null(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_null(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_null(::Type{T}) where {T} = false\nomit_null(::JSONStyle, ::Type{T}) where {T} = omit_null(T)\n\n\"\"\"\n    @omit_null struct T ...\n    @omit_null T\n\nConvenience macro to set `omit_null(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_null struct T ... end`\n2. Applied to an existing struct name: `@omit_null T`\n3. Chained with other macros: `@omit_null @defaults struct T ... end`\n\nThe macro automatically handles complex macro expansions by walking the expression\ntree to find struct definitions, making it compatible with macros like `StructUtils.@defaults`.\n\n# Examples\n```julia\n# Method 1: Struct annotation\n@omit_null struct Person\n    name::String\n    email::Union{Nothing, String}\nend\n\n# Method 2: Apply to existing struct\nstruct User\n    id::Int\n    profile::Union{Nothing, String}\nend\n@omit_null User\n\n# Method 3: Chain with @defaults\n@omit_null @defaults struct Employee\n    name::String = \"Anonymous\"\n    manager::Union{Nothing, String} = nothing\nend\n```\n\"\"\"\nmacro omit_null(expr)\n    return _omit_macro_impl(expr, :omit_null, __module__)\nend\n\n\"\"\"\n    JSON.omit_empty(::Type{T})::Bool\n    JSON.omit_empty(::JSONStyle, ::Type{T})::Bool\n\nControls whether struct fields that are empty are included in the JSON output.\nReturns `false` by default, meaning empty fields *are* included. To instead exclude empty fields,\nset this to `true`. A field is considered empty if it is `nothing`, an empty collection\n(empty array, dict, string, tuple, or named tuple), or `missing`.\nThis can also be controlled via the `omit_empty` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_empty(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_empty(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_empty(::Type{T}) where {T} = false\nomit_empty(::JSONStyle, ::Type{T}) where {T} = omit_empty(T)\n\nis_empty(x) = false\nis_empty(::Nothing) = true\nis_empty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = Base.isempty(x)\n\n\"\"\"\n    @omit_empty struct T ...\n    @omit_empty T\n\nConvenience macro to set `omit_empty(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_empty struct T ... end`\n2. Applied to an existing struct name: `@omit_empty T`\n3. Chained with other macros: `@omit_empty @other_macro struct T ... end`\n\"\"\"\nmacro omit_empty(expr)\n    return _omit_macro_impl(expr, :omit_empty, __module__)\nend\n\n# Helper function for both @omit_null and @omit_empty macros\nfunction _omit_macro_impl(expr, omit_func_name, module_context)\n    original_expr = expr\n    expr = macroexpand(module_context, expr)\n    # Case 1: Just a type name (Symbol or more complex type expression)\n    if isa(expr, Symbol) || (Meta.isexpr(expr, :curly) || Meta.isexpr(expr, :where))\n        # Extract the base type name\n        T = _extract_type_name(expr)\n        return esc(quote\n            JSON.$omit_func_name(::Type{$T}) = true\n        end)\n    end\n    # Case 2: Struct definition (possibly from macro expansion)\n    if Meta.isexpr(expr, :struct)\n        ismutable, T, fieldsblock = expr.args\n        T = _extract_type_name(T)\n        return esc(quote\n            # insert original expr as-is\n            $expr\n            # omit function overload\n            JSON.$omit_func_name(::Type{$T}) = true\n        end)\n    end\n    # Case 3: Block expression (from complex macros like @defaults)\n    if Meta.isexpr(expr, :block)\n        # Try to find a struct definition in the block\n        struct_expr = _find_struct_in_block(expr)\n        if struct_expr !== nothing\n            ismutable, T, fieldsblock = struct_expr.args\n            T = _extract_type_name(T)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$T}) = true\n            end)\n        end\n    end\n    # Case 4: Macro expression that we hope expands to a struct\n    if Meta.isexpr(original_expr, :macrocall)\n        # Try to see if the expanded form is a struct\n        if Meta.isexpr(expr, :struct)\n            ismutable, T, fieldsblock = expr.args\n            T = _extract_type_name(T)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$T}) = true\n            end)\n        else\n            throw(ArgumentError(\"Macro $(original_expr.args[1]) did not expand to a struct definition\"))\n        end\n    end\n    throw(ArgumentError(\"Invalid usage of @$omit_func_name macro. Expected: struct definition, type name, or macro that expands to struct definition\"))\nend\n\n# Helper function to recursively find a struct definition in a block expression\nfunction _find_struct_in_block(expr)\n    if Meta.isexpr(expr, :struct)\n        return expr\n    elseif Meta.isexpr(expr, :block)\n        for arg in expr.args\n            result = _find_struct_in_block(arg)\n            if result !== nothing\n                return result\n            end\n        end\n    end\n    return nothing\nend\n\n# Helper function to extract the base type name from various type expressions\nfunction _extract_type_name(T)\n    if isa(T, Symbol)\n        return T\n    elseif Meta.isexpr(T, :<:)\n        # Handle subtyping: struct Foo <: Bar\n        return _extract_type_name(T.args[1])\n    elseif Meta.isexpr(T, :curly)\n        # Handle parametric types: keep the full parametric type Foo{T}\n        return T\n    elseif Meta.isexpr(T, :where)\n        # Handle where clauses: struct Foo{T} where T\n        return _extract_type_name(T.args[1])\n    else\n        return T\n    end\nend\n\nStructUtils.lowerkey(::JSONStyle, s::AbstractString) = s\nStructUtils.lowerkey(::JSONStyle, sym::Symbol) = String(sym)\nStructUtils.lowerkey(::JSONStyle, n::Union{Integer, Union{Float16, Float32, Float64}}) = string(n)\nStructUtils.lowerkey(::JSONStyle, x) = throw(ArgumentError(\"No key representation for $(typeof(x)). Define StructUtils.lowerkey(::$(typeof(x)))\"))\n\n\"\"\"\n    JSON.json(x) -> String\n    JSON.json(io, x)\n    JSON.json(file_name, x)\n\nSerialize `x` to JSON format. The 1st method takes just the object and returns a `String`.\nIn the 2nd method, `io` is an `IO` object, and the JSON output will be written to it.\nFor the 3rd method, `file_name` is a `String`, a file will be opened and the JSON output will be written to it.\n\nAll methods accept the following keyword arguments:\n\n- `omit_null::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are undefined or are `nothing` are included in the JSON output.\n  If `true`, only non-null fields are written. If `false`, all fields are included regardless of being undefined or `nothing`.\n  If `nothing`, the behavior is determined by `JSON.omit_null(::Type{T})`, which is `false` by default.\n\n- `omit_empty::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are empty are included in the JSON output.\n  If `true`, empty fields are excluded. If `false`, empty fields are included.\n  If `nothing`, the behavior is determined by `JSON.omit_empty(::Type{T})`.\n\n- `JSON.Null()` / `JSON.Omit()` sentinels: `JSON.Null()` always emits a JSON `null`\n  literal even when `omit_null=true`, enabling per-field overrides (for example by\n  declaring a field as `Union{Nothing, JSON.Null}`) or defining a custom `lower` function for a field that returns `JSON.Null`.\n  `JSON.Omit()` removes the enclosing value from the output regardless of global omit settings, making it easy for field-level\n  lowering code to drop optional data entirely. For example, by defining a custom `lower` function for a field that returns `JSON.Omit`.\n    \n- `allownan::Bool=false`: If `true`, allow `Inf`, `-Inf`, and `NaN` in the output.\n  If `false`, throw an error if `Inf`, `-Inf`, or `NaN` is encountered.\n\n- `jsonlines::Bool=false`: If `true`, input must be array-like and the output will be written in the JSON Lines format,\n  where each element of the array is written on a separate line (i.e. separated by a single newline character `\\n`).\n  If `false`, the output will be written in the standard JSON format.\n\n- `pretty::Union{Integer,Bool}=false`: Controls pretty printing of the JSON output.\n  If `true`, the output will be pretty-printed with 2 spaces of indentation.\n  If an integer, it will be used as the number of spaces of indentation.\n  If `false` or `0`, the output will be compact.\n  Note: Pretty printing is not supported when `jsonlines=true`.\n\n- `inline_limit::Int=0`: For arrays shorter than this limit, pretty printing will be disabled (indentation set to 0).\n\n- `ninf::String=\"-Infinity\"`: Custom string representation for negative infinity.\n\n- `inf::String=\"Infinity\"`: Custom string representation for positive infinity.\n\n- `nan::String=\"NaN\"`: Custom string representation for NaN.\n\n- `float_style::Symbol=:shortest`: Controls how floating-point numbers are formatted.\n  Options are:\n  - `:shortest`: Use the shortest representation that preserves the value\n  - `:fixed`: Use fixed-point notation\n  - `:exp`: Use exponential notation\n\n- `float_precision::Int=1`: Number of decimal places to use when `float_style` is `:fixed` or `:exp`.\n\n- `bufsize::Int=2^22`: Buffer size in bytes for IO operations. When writing to IO, the buffer will be flushed \n  to the IO stream once it reaches this size. This helps control memory usage during large write operations.\n  Default is 4MB (2^22 bytes). This parameter is ignored when returning a String.\n\n- `style::JSONStyle=JSONWriteStyle()`: Custom style object that controls serialization behavior. This allows customizing\n    certain aspects of serialization, like defining a custom `lower` method for a non-owned type. Like `struct MyStyle <: JSONStyle end`,\n    `JSON.lower(x::Rational) = (num=x.num, den=x.den)`, then calling `JSON.json(1//3; style=MyStyle())` will output\n    `{\"num\": 1, \"den\": 3}`.\n\nBy default, `x` must be a JSON-serializable object. Supported types include:\n  * `AbstractString` => JSON string: types must support the `AbstractString` interface, specifically with support for\n    `ncodeunits` and `codeunit(x, i)`.\n  * `Bool` => JSON boolean: must be `true` or `false`\n  * `Nothing` => JSON null: must be the `nothing` singleton value\n  * `Number` => JSON number: `Integer` subtypes or `Union{Float16, Float32, Float64}` have default implementations\n    for other `Number` types, [`JSON.tostring`](@ref) is first called to convert\n    the value to a `String` before being written directly to JSON output\n  * `AbstractArray`/`Tuple`/`AbstractSet` => JSON array: objects for which `JSON.arraylike` returns `true`\n     are output as JSON arrays. `arraylike` is defined by default for\n    `AbstractArray`, `AbstractSet`, `Tuple`, and `Base.Generator`. For other types that define,\n    they must also properly implement `StructUtils.applyeach` to iterate over the index => elements pairs.\n    Note that arrays with dimensionality > 1 are written as nested arrays, with `N` nestings for `N` dimensions,\n    and the 1st dimension is always the innermost nested JSON array (column-major order).\n  * `AbstractDict`/`NamedTuple`/structs => JSON object: if a value doesn't fall into any of the above categories,\n    it is output as a JSON object. `StructUtils.applyeach` is called, which has appropriate implementations\n    for `AbstractDict`, `NamedTuple`, and structs, where field names => values are iterated over. Field names can\n    be output with an alternative name via field tag overload, like `field::Type &(json=(name=\"alternative_name\",),)`\n\nIf an object is not JSON-serializable, an override for `JSON.lower` can\nbe defined to convert it to a JSON-serializable object. Some default `lower` defintions\nare defined in JSON itself, for example:\n  * `StructUtils.lower(::Missing) = nothing`\n  * `StructUtils.lower(x::Symbol) = String(x)`\n  * `StructUtils.lower(x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType}) = string(x)`\n  * `StructUtils.lower(x::Regex) = x.pattern`\n\nThese allow common Base/stdlib types to be serialized in an expected format.\n\nCircular references are tracked automatically and cycles are broken by writing `null` for any children references.\n\nFor pre-formatted JSON data as a String, use `JSONText(json)` to write the string out as-is.\n\nFor `AbstractDict` objects with non-string keys, `StructUtils.lowerkey` will be called before serializing. This allows aggregate\nor other types of dict keys to be converted to an appropriate string representation. See `StructUtils.liftkey`\nfor the reverse operation, which is called when parsing JSON data back into a dict type.\n\n*NOTE*: `JSON.json` should _not_ be overloaded directly by custom\ntypes as this isn't robust for various output options (IO, String, etc.)\nnor recursive situations. Types should define an appropriate\n`JSON.lower` definition instead.\n\n*NOTE*: `JSON.json(str, indent::Integer)` is special-cased for backwards compatibility with pre-1.0 JSON.jl,\nas this typically would mean \"write out the `indent` integer to file `str`\". As writing out a single integer to\na file is extremely rare, it was decided to keep the pre-1.0 behavior for compatibility reasons.\n\nExamples:\n```julia\nusing Dates\n\nabstract type AbstractMonster end\n\nstruct Dracula <: AbstractMonster\n    num_victims::Int\nend\n\nstruct Werewolf <: AbstractMonster\n    witching_hour::DateTime\nend\n\nstruct Percent <: Number\n    value::Float64\nend\n\nJSON.lower(x::Percent) = x.value\nStructUtils.lowerkey(x::Percent) = string(x.value)\n\n@noarg mutable struct FrankenStruct\n    id::Int\n    name::String # no default to show serialization of an undefined field\n    address::Union{Nothing, String} = nothing\n    rate::Union{Missing, Float64} = missing\n    type::Symbol = :a &(json=(name=\"franken_type\",),)\n    notsure::Any = JSON.Object(\"key\" => \"value\")\n    monster::AbstractMonster = Dracula(10) &(json=(lower=x -> x isa Dracula ? (monster_type=\"vampire\", num_victims=x.num_victims) : (monster_type=\"werewolf\", witching_hour=x.witching_hour),),)\n    percent::Percent = Percent(0.5)\n    birthdate::Date = Date(2025, 1, 1) &(json=(dateformat=\"yyyy/mm/dd\",),)\n    percentages::Dict{Percent, Int} = Dict{Percent, Int}(Percent(0.0) => 0, Percent(1.0) => 1)\n    json_properties::JSONText = JSONText(\"{\\\"key\\\": \\\"value\\\"}\")\n    matrix::Matrix{Float64} = [1.0 2.0; 3.0 4.0]\n    extra_field::Any = nothing &(json=(ignore=true,),)\nend\n\nfranken = FrankenStruct()\nfranken.id = 1\n\njson = JSON.json(franken; omit_null=false)\n# \"{\\\"id\\\":1,\\\"name\\\":null,\\\"address\\\":null,\\\"rate\\\":null,\\\"franken_type\\\":\\\"a\\\",\\\"notsure\\\":{\\\"key\\\":\\\"value\\\"},\\\"monster\\\":{\\\"monster_type\\\":\\\"vampire\\\",\\\"num_victims\\\":10},\\\"percent\\\":0.5,\\\"birthdate\\\":\\\"2025/01/01\\\",\\\"percentages\\\":{\\\"1.0\\\":1,\\\"0.0\\\":0},\\\"json_properties\\\":{\\\"key\\\": \\\"value\\\"},\\\"matrix\\\":[[1.0,3.0],[2.0,4.0]]}\"\n```\n\nA few comments on the JSON produced in the example above:\n  - The `name` field was `#undef`, and thus was serialized as `null`.\n  - The `address` and `rate` fields were `nothing` and `missing`, respectively, and thus were serialized as `null`.\n  - The `type` field has a `name` field tag, so the JSON key for this field is `franken_type` instead of `type`.\n  - The `notsure` field is a `JSON.Object`, so it is serialized as a JSON object.\n  - The `monster` field is a `AbstractMonster`, which is a custom type. It has a `lower` field tag that specifies how the value of this field specifically (not all AbstractMonster) should be serialized\n  - The `percent` field is a `Percent`, which is a custom type. It has a `lower` method that specifies how `Percent` values should be serialized\n  - The `birthdate` field has a `dateformat` field tag, so the value follows the format (`yyyy/mm/dd`) instead of the default date ISO format (`yyyy-mm-dd`)\n  - The `percentages` field is a `Dict{Percent, Int}`, which is a custom type. It has a `lowerkey` method that specifies how `Percent` keys should be serialized as strings\n  - The `json_properties` field is a `JSONText`, so the JSONText value is serialized as-is\n  - The `matrix` field is a `Matrix{Float64}`, which is a custom type. It is serialized as a JSON array, with the first dimension being the innermost nested JSON array (column-major order)\n  - The `extra_field` field has a `ignore` field tag, so it is skipped when serializing\n\n\"\"\"\nfunction json end\n\n@kwdef struct WriteOptions{S}\n    omit_null::Union{Bool, Nothing} = nothing\n    omit_empty::Union{Bool, Nothing} = nothing\n    allownan::Bool = false\n    jsonlines::Bool = false\n    pretty::Int = 0\n    ninf::String = \"-Infinity\"\n    inf::String = \"Infinity\"\n    nan::String = \"NaN\"\n    inline_limit::Int = 0\n    float_style::Symbol = :shortest # :shortest, :fixed, :exp\n    float_precision::Int = 1\n    bufsize::Int = 2^22 # 4MB default buffer size for IO flushing\n    style::S = JSONWriteStyle()\nend\n\n@noinline float_style_throw(fs) = throw(ArgumentError(\"Invalid float style: $fs\"))\nfloat_style_check(fs) = fs == :shortest || fs == :fixed || fs == :exp || float_style_throw(fs)\n\n@noinline float_precision_throw(fs, fp) = throw(ArgumentError(\"float_precision must be positive when float_style is $fs; got $fp\"))\nfloat_precision_check(fs, fp) = (fs == :shortest || fp > 0) || float_precision_throw(fs, fp)\n\n# if jsonlines and pretty is not 0 or false, throw an ArgumentError\n@noinline _jsonlines_pretty_throw() = throw(ArgumentError(\"pretty printing is not supported when writing jsonlines\"))\n_jsonlines_pretty_check(jsonlines, pretty) = jsonlines && pretty !== false && !iszero(pretty) && _jsonlines_pretty_throw()\n@noinline _root_omit_throw() = throw(ArgumentError(\"JSON.Omit() is only valid inside arrays or objects\"))\n\nfunction json(io::IO, x::T; pretty::Union{Integer,Bool}=false, kw...) where {T}\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    # Use smaller initial buffer size, limited by bufsize\n    initial_size = min(sizeguess(y), opts.bufsize)\n    buf = Vector{UInt8}(undef, initial_size)\n    pos = json!(buf, 1, y, opts, Any[y], io)\n    # Write any remaining buffer contents to IO\n    if pos > 1\n        write(io, view(buf, 1:pos-1))\n    end\n    return nothing\nend\n\nif isdefined(Base, :StringVector)\n    stringvec(n) = Base.StringVector(n)\nelse\n    stringvec(n) = Vector{UInt8}(undef, n)\nend\n\nfunction json(x; pretty::Union{Integer,Bool}=false, kw...)\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    buf = stringvec(sizeguess(y))\n    pos = json!(buf, 1, y, opts, Any[y], nothing)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction json(fname, obj; kw...)\n    if obj isa Integer\n        # special-case for pre-1.0 JSON compat\n        return json(fname; pretty=obj)\n    else\n        @assert fname isa AbstractString \"filename must be a string\"\n    end\n    open(fname, \"w\") do io\n        json(io, obj; kw...)\n    end\n    return fname\nend\n\n# we use the same growth strategy as Base julia does for array growing\n# which starts with small N at ~5x and approaches 1.125x as N grows\n# ref: https://github.com/JuliaLang/julia/pull/40453\nnewlen(n\u2080) = ceil(Int, n\u2080 + 4*n\u2080^(7 / 8) + n\u2080 / 8)\n\nmacro checkn(n, force_resize=false)\n    esc(quote\n        if (pos + $n - 1) > length(buf)\n            # If we have an IO object and buffer would exceed bufsize, flush to IO first\n            # unless force_resize is true (used for comma writing to avoid flushing partial JSON)\n            if io !== nothing && length(buf) >= bufsize && pos > 1 && !$force_resize\n                write(io, view(buf, 1:pos-1))\n                pos = 1\n            end\n            # Resize buffer if still needed\n            if (pos + $n - 1) > length(buf)\n                resize!(buf, newlen(pos + $n))\n            end\n        end\n    end)\nend\n\nstruct WriteClosure{JS, arraylike, T, I} # T is the type of the parent object/array being written\n    buf::Vector{UInt8}\n    pos::Ptr{Int}\n    wroteany::Ptr{Bool} # to track if we wrote any data to the buffer\n    indent::Int\n    depth::Int\n    opts::JS\n    ancestor_stack::Vector{Any} # to track circular references\n    io::I\n    bufsize::Int\nend\n\nfunction indent(buf, pos, ind, depth, io, bufsize)\n    if ind > 0\n        n = ind * depth + 1\n        @checkn n\n        buf[pos] = UInt8('\\n')\n        for i = 1:(n - 1)\n            buf[pos + i] = UInt8(' ')\n        end\n        pos += n\n    end\n    return pos\nend\n\ncheckkey(s) = s isa AbstractString || throw(ArgumentError(\"Value returned from `StructUtils.lowerkey` must be a string: $(typeof(s))\"))\n\nfunction (f::WriteClosure{JS, arraylike, T, I})(key, val) where {JS, arraylike, T, I}\n    track_ref = ismutabletype(typeof(val))\n    is_circ_ref = track_ref && any(x -> x === val, f.ancestor_stack)\n    val isa Omit && return\n    if !arraylike\n        # for objects, check omit_null/omit_empty\n        # and skip if the value is null or empty\n        if f.opts.omit_null === true || (f.opts.omit_null === nothing && omit_null(f.opts.style, T))\n            (is_circ_ref || val === nothing) && return\n        end\n        if f.opts.omit_empty === true || (f.opts.omit_empty === nothing && omit_empty(f.opts.style, T))\n            (is_circ_ref || is_empty(val)) && return\n        end\n    end\n    pos = unsafe_load(f.pos)\n    unsafe_store!(f.wroteany, true) # at this point, we know something will be written\n    buf = f.buf\n    ind = f.indent\n    io = f.io\n    bufsize = f.bufsize\n    pos = indent(buf, pos, ind, f.depth, io, bufsize)\n    # if not an array, we need to write the key + ':'\n    if !arraylike\n        # skey = StructUtils.lowerkey(f.opts, key)\n        # check if the key is a string\n        checkkey(key)\n        pos = _string(buf, pos, key, io, bufsize)\n        @checkn 1\n        buf[pos] = UInt8(':')\n        pos += 1\n        if ind > 0\n            @checkn 1\n            buf[pos] = UInt8(' ')\n            pos += 1\n        end\n    end\n    # check if the lowered value is in our ancestor stack\n    if is_circ_ref\n        # if so, it's a circular reference! so we just write `null`\n        pos = _null(buf, pos, io, bufsize)\n    else\n        track_ref && push!(f.ancestor_stack, val)\n        # if jsonlines, we need to recursively set to false\n        if f.opts.jsonlines\n            opts = WriteOptions(; omit_null=f.opts.omit_null, omit_empty=f.opts.omit_empty, allownan=f.opts.allownan, jsonlines=false, pretty=f.opts.pretty, ninf=f.opts.ninf, inf=f.opts.inf, nan=f.opts.nan, inline_limit=f.opts.inline_limit, float_style=f.opts.float_style, float_precision=f.opts.float_precision)\n        else\n            opts = f.opts\n        end\n        pos = json!(buf, pos, val, opts, f.ancestor_stack, io, ind, f.depth, bufsize)\n        track_ref && pop!(f.ancestor_stack)\n    end\n    @checkn 1 true\n    @inbounds buf[pos] = f.opts.jsonlines ? UInt8('\\n') : UInt8(',')\n    pos += 1\n    # store our updated pos\n    unsafe_store!(f.pos, pos)\n    return\nend\n\n@noinline throwjsonlines() = throw(ArgumentError(\"jsonlines only supported for arraylike\"))\n\n# assume x is lowered value\nfunction json!(buf, pos, x, opts::WriteOptions, ancestor_stack::Union{Nothing, Vector{Any}}=nothing, io::Union{Nothing, IO}=nothing, ind::Int=opts.pretty, depth::Int=0, bufsize::Int=opts.bufsize)\n    # string\n    if x isa Omit\n        _root_omit_throw()\n    elseif x isa Null\n        return _null(buf, pos, io, bufsize)\n    elseif x isa AbstractString\n        return _string(buf, pos, x, io, bufsize)\n    # write JSONText out directly\n    elseif x isa JSONText\n        val = x.value\n        @checkn sizeof(val)\n        for i = 1:sizeof(val)\n            @inbounds buf[pos + i - 1] = codeunit(val, i)\n        end\n        return pos + sizeof(val)\n    # bool; check before Number since Bool <: Number\n    elseif x isa Bool\n        if x\n            @checkn 4\n            @inbounds buf[pos] = 't'\n            @inbounds buf[pos + 1] = 'r'\n            @inbounds buf[pos + 2] = 'u'\n            @inbounds buf[pos + 3] = 'e'\n            return pos + 4\n        else\n            @checkn 5\n            @inbounds buf[pos] = 'f'\n            @inbounds buf[pos + 1] = 'a'\n            @inbounds buf[pos + 2] = 'l'\n            @inbounds buf[pos + 3] = 's'\n            @inbounds buf[pos + 4] = 'e'\n            return pos + 5\n        end\n    # number\n    elseif x isa Number\n        return _number(buf, pos, x, opts, io, bufsize)\n    # null\n    elseif x === nothing\n        return _null(buf, pos, io, bufsize)\n    # object or array\n    elseif StructUtils.dictlike(opts.style, x) || StructUtils.arraylike(opts.style, x) || StructUtils.structlike(opts.style, x)\n        al = StructUtils.arraylike(opts.style, x)\n        # override pretty indent to 0 for arrays shorter than inline_limit\n        if al && opts.pretty > 0 && opts.inline_limit > 0 && length(x) < opts.inline_limit\n            local_ind = 0\n        else\n            local_ind = ind\n        end\n        if !opts.jsonlines\n            @checkn 1\n            @inbounds buf[pos] = al ? UInt8('[') : UInt8('{')\n            pos += 1\n        else\n            al || throwjsonlines()\n        end\n        ref = Ref(pos)\n        wroteany = false\n        wroteanyref = Ref(false)\n        GC.@preserve ref wroteanyref begin\n            c = WriteClosure{typeof(opts), al, typeof(x), typeof(io)}(buf, Base.unsafe_convert(Ptr{Int}, ref), Base.unsafe_convert(Ptr{Bool}, wroteanyref), local_ind, depth + 1, opts, ancestor_stack, io, bufsize)\n            StructUtils.applyeach(opts.style, c, x)\n            # get updated pos\n            pos = unsafe_load(c.pos)\n            wroteany = unsafe_load(c.wroteany)\n        end\n        # in WriteClosure, we eagerly write a comma after each element\n        # so for non-empty object/arrays, we can just overwrite the last comma with the closechar\n        if wroteany\n            pos -= 1\n            pos = indent(buf, pos, local_ind, depth, io, bufsize)\n        end\n        # even if the input is empty and we're jsonlines, the spec says it's ok to end w/ a newline\n        @checkn 1\n        @inbounds buf[pos] = opts.jsonlines ? UInt8('\\n') : al ? UInt8(']') : UInt8('}')\n        return pos + 1\n    else\n        return _string(buf, pos, x, io, bufsize)\n    end\nend\n\nfunction _null(buf, pos, io, bufsize)\n    @checkn 4\n    @inbounds buf[pos] = 'n'\n    @inbounds buf[pos + 1] = 'u'\n    @inbounds buf[pos + 2] = 'l'\n    @inbounds buf[pos + 3] = 'l'\n    return pos + 4\nend\n\n_string(buf, pos, x, io, bufsize) = _string(buf, pos, string(x), io, bufsize)\n_string(buf, pos, x::LazyValues, io, bufsize) = _string(buf, pos, getindex(x), io, bufsize)\n_string(buf, pos, x::PtrString, io, bufsize) = _string(buf, pos, convert(String, x), io, bufsize)\n\nfunction _string(buf, pos, x::AbstractString, io, bufsize)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @checkn (el + 2)\n    @inbounds buf[pos] = UInt8('\"')\n    pos += 1\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds buf[pos] = UInt8('\"')\n    return pos + 1\nend\n\n\"\"\"\n    JSON.tostring(x)\n\nOverloadable function that allows non-`Integer` `Number` types\nto convert themselves to a `String` that is then used\nwhen serializing `x` to JSON. Note that if the result of `tostring`\nis not a valid JSON number, it will be serialized as a JSON string,\nwith double quotes around it.\n\nAn example overload would look something like:\n```julia\nJSON.tostring(x::MyDecimal) = string(x)\n```\n\"\"\"\ntostring(x) = string(Float64(x))\n\nsplit_sign(n::Integer) = unsigned(abs(n)), n < 0\nsplit_sign(n::Unsigned) = n, false\nsplit_sign(x::BigInt) = (abs(x), x < 0)\n\n@noinline infcheck(x, allownan) = isfinite(x) || allownan || throw(ArgumentError(\"$x not allowed to be written in JSON spec; pass `allownan=true` to allow anyway\"))\n\nfunction _number(buf, pos, x::Number, opts::WriteOptions, io, bufsize)\n    if x isa Integer\n        y, neg = split_sign(x)\n        n = i = ndigits(y, base=10, pad=1)\n        @checkn (i + neg)\n        if neg\n            @inbounds buf[pos] = UInt8('-')\n            pos += 1\n        end\n        while i > 0\n            @inbounds buf[pos + i - 1] = 48 + rem(y, 10)\n            y = oftype(y, div(y, 10))\n            i -= 1\n        end\n        return pos + n\n    elseif x isa Union{Float16, Float32, Float64}\n        infcheck(x, opts.allownan)\n        if isnan(x)\n            nan = opts.nan\n            @checkn sizeof(nan)\n            for i = 1:sizeof(nan)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(nan, i))\n            end\n            return pos + sizeof(nan)\n        elseif isinf(x)\n            if x < 0\n                inf = opts.ninf\n            else\n                inf = opts.inf\n            end\n            @checkn sizeof(inf)\n            for i = 1:sizeof(inf)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(inf, i))\n            end\n            return pos + sizeof(inf)\n        end\n        if opts.float_style == :shortest\n            @checkn Base.Ryu.neededdigits(typeof(x))\n            return Base.Ryu.writeshortest(buf, pos, x)\n        elseif opts.float_style == :fixed\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writefixed(buf, pos, x, opts.float_precision, false, false, true)\n        elseif opts.float_style == :exp\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writeexp(buf, pos, x, opts.float_precision, false, false, true)\n        else\n            # unreachable as we validate float_style inputs\n            @assert false\n        end\n    else\n        str = tostring(x)\n        if anyinvalidnumberchars(str)\n            # serialize as string\n            return _string(buf, pos, str, io, bufsize)\n        end\n        bytes = codeunits(str)\n        sz = sizeof(bytes)\n        @checkn sz\n        for i = 1:sz\n            @inbounds buf[pos + i - 1] = bytes[i]\n        end\n        return pos + sz\n    end\nend\n\nfunction anyinvalidnumberchars(x)\n    for i = 1:sizeof(x)\n        b = codeunit(x, i)\n        if !(b == UInt8('-') || b == UInt8('.') || b == UInt8('e') || b == UInt8('E') ||\n            UInt8('0') <= b <= UInt8('9'))\n            return true\n        end\n    end\n    return false\nend\n"}, "files_after": {"src/write.jl": "struct JSONWriteStyle <: JSONStyle end\n\n\"\"\"\n    JSON.Null()\n\nSingleton sentinel that always serializes as the JSON literal `null`,\neven when `omit_null=true` at the struct or callsite level. Useful for\nper-field overrides (e.g. `Union{Nothing, JSON.Null}`) or custom field\nlowering that must force a `null` emission.\n\"\"\"\nstruct Null end\n\n\"\"\"\n    JSON.Omit()\n\nSingleton sentinel that removes the enclosing value from the JSON output,\nregardless of `omit_null` / `omit_empty` settings. Valid within objects\nand arrays; using it as the root value throws an error.\n\"\"\"\nstruct Omit end\n\nsizeguess(::Nothing) = 4\nsizeguess(x::Bool) = 5\nsizeguess(x::Integer) = 20\nsizeguess(x::AbstractFloat) = 20\nsizeguess(x::Union{Float16, Float32, Float64}) = Base.Ryu.neededdigits(typeof(x))\nsizeguess(x::AbstractString) = 2 + sizeof(x)\nsizeguess(::Null) = 4\nsizeguess(::Omit) = 0\nsizeguess(_) = 512\n\nStructUtils.lower(::JSONStyle, ::Missing) = nothing\nStructUtils.lower(::JSONStyle, x::Symbol) = String(x)\nStructUtils.lower(::JSONStyle, x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType, Type, Logging.LogLevel}) = string(x)\nStructUtils.lower(::JSONStyle, x::Regex) = x.pattern\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any,0}) = x[1]\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any, N}) where {N} = (view(x, ntuple(_ -> :, N - 1)..., j) for j in axes(x, N))\nStructUtils.lower(::JSONStyle, x::AbstractVector) = x\nStructUtils.arraylike(::JSONStyle, x::AbstractVector{<:Pair}) = false\nStructUtils.structlike(::JSONStyle, ::Type{<:NamedTuple}) = true\n\n# for pre-1.0 compat, which serialized Tuple object keys by default\nStructUtils.lowerkey(::JSONStyle, x::Tuple) = string(x)\n\n\"\"\"\n    JSON.omit_null(::Type{T})::Bool\n    JSON.omit_null(::JSONStyle, ::Type{T})::Bool\n    \nControls whether struct fields that are undefined or are `nothing` are included in the JSON output.\nReturns `false` by default, meaning all fields are included, regardless of undef or `nothing`. To instead\nensure only *non-null* fields are written, set this to `true`.\nThis can also be controlled via the `omit_null` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_null(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_null(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_null(::Type{T}) where {T} = false\nomit_null(::JSONStyle, ::Type{T}) where {T} = omit_null(T)\n\n\"\"\"\n    @omit_null struct T ...\n    @omit_null T\n\nConvenience macro to set `omit_null(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_null struct T ... end`\n2. Applied to an existing struct name: `@omit_null T`\n3. Chained with other macros: `@omit_null @defaults struct T ... end`\n\nThe macro automatically handles complex macro expansions by walking the expression\ntree to find struct definitions, making it compatible with macros like `StructUtils.@defaults`.\n\n# Examples\n```julia\n# Method 1: Struct annotation\n@omit_null struct Person\n    name::String\n    email::Union{Nothing, String}\nend\n\n# Method 2: Apply to existing struct\nstruct User\n    id::Int\n    profile::Union{Nothing, String}\nend\n@omit_null User\n\n# Method 3: Chain with @defaults\n@omit_null @defaults struct Employee\n    name::String = \"Anonymous\"\n    manager::Union{Nothing, String} = nothing\nend\n```\n\"\"\"\nmacro omit_null(expr)\n    return _omit_macro_impl(expr, :omit_null, __module__)\nend\n\n\"\"\"\n    JSON.omit_empty(::Type{T})::Bool\n    JSON.omit_empty(::JSONStyle, ::Type{T})::Bool\n\nControls whether struct fields that are empty are included in the JSON output.\nReturns `false` by default, meaning empty fields *are* included. To instead exclude empty fields,\nset this to `true`. A field is considered empty if it is `nothing`, an empty collection\n(empty array, dict, string, tuple, or named tuple), or `missing`.\nThis can also be controlled via the `omit_empty` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_empty(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_empty(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_empty(::Type{T}) where {T} = false\nomit_empty(::JSONStyle, ::Type{T}) where {T} = omit_empty(T)\n\nis_empty(x) = false\nis_empty(::Nothing) = true\nis_empty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = Base.isempty(x)\n\n\"\"\"\n    @omit_empty struct T ...\n    @omit_empty T\n\nConvenience macro to set `omit_empty(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_empty struct T ... end`\n2. Applied to an existing struct name: `@omit_empty T`\n3. Chained with other macros: `@omit_empty @other_macro struct T ... end`\n\"\"\"\nmacro omit_empty(expr)\n    return _omit_macro_impl(expr, :omit_empty, __module__)\nend\n\n# Helper function to generate the appropriate type signature for omit functions\nfunction _make_omit_type_sig(T, is_parametric)\n    if is_parametric\n        # For parametric types, use <: to match all instantiations\n        return :(<:$T)\n    else\n        return T\n    end\nend\n\n# Helper function for both @omit_null and @omit_empty macros\nfunction _omit_macro_impl(expr, omit_func_name, module_context)\n    original_expr = expr\n    expr = macroexpand(module_context, expr)\n    # Case 1: Just a type name (Symbol or more complex type expression)\n    if isa(expr, Symbol) || (Meta.isexpr(expr, :curly) || Meta.isexpr(expr, :where))\n        # Extract the base type name\n        T, is_parametric = _extract_type_name(expr)\n        type_sig = _make_omit_type_sig(T, is_parametric)\n        return esc(quote\n            JSON.$omit_func_name(::Type{$type_sig}) = true\n        end)\n    end\n    # Case 2: Struct definition (possibly from macro expansion)\n    if Meta.isexpr(expr, :struct)\n        ismutable, T, fieldsblock = expr.args\n        T, is_parametric = _extract_type_name(T)\n        type_sig = _make_omit_type_sig(T, is_parametric)\n        return esc(quote\n            # insert original expr as-is\n            $expr\n            # omit function overload\n            JSON.$omit_func_name(::Type{$type_sig}) = true\n        end)\n    end\n    # Case 3: Block expression (from complex macros like @defaults)\n    if Meta.isexpr(expr, :block)\n        # Try to find a struct definition in the block\n        struct_expr = _find_struct_in_block(expr)\n        if struct_expr !== nothing\n            ismutable, T, fieldsblock = struct_expr.args\n            T, is_parametric = _extract_type_name(T)\n            type_sig = _make_omit_type_sig(T, is_parametric)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$type_sig}) = true\n            end)\n        end\n    end\n    # Case 4: Macro expression that we hope expands to a struct\n    if Meta.isexpr(original_expr, :macrocall)\n        # Try to see if the expanded form is a struct\n        if Meta.isexpr(expr, :struct)\n            ismutable, T, fieldsblock = expr.args\n            T, is_parametric = _extract_type_name(T)\n            type_sig = _make_omit_type_sig(T, is_parametric)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$type_sig}) = true\n            end)\n        else\n            throw(ArgumentError(\"Macro $(original_expr.args[1]) did not expand to a struct definition\"))\n        end\n    end\n    throw(ArgumentError(\"Invalid usage of @$omit_func_name macro. Expected: struct definition, type name, or macro that expands to struct definition\"))\nend\n\n# Helper function to recursively find a struct definition in a block expression\nfunction _find_struct_in_block(expr)\n    if Meta.isexpr(expr, :struct)\n        return expr\n    elseif Meta.isexpr(expr, :block)\n        for arg in expr.args\n            result = _find_struct_in_block(arg)\n            if result !== nothing\n                return result\n            end\n        end\n    end\n    return nothing\nend\n\n# Helper function to extract the base type name from various type expressions\n# Returns (base_type, is_parametric) tuple\nfunction _extract_type_name(T)\n    if isa(T, Symbol)\n        return (T, false)\n    elseif Meta.isexpr(T, :<:)\n        # Handle subtyping: struct Foo <: Bar\n        return _extract_type_name(T.args[1])\n    elseif Meta.isexpr(T, :curly)\n        # Handle parametric types: return just the base type name (e.g., Foo from Foo{T})\n        # and indicate it's parametric\n        return (T.args[1], true)\n    elseif Meta.isexpr(T, :where)\n        # Handle where clauses: struct Foo{T} where T\n        return _extract_type_name(T.args[1])\n    else\n        return (T, false)\n    end\nend\n\nStructUtils.lowerkey(::JSONStyle, s::AbstractString) = s\nStructUtils.lowerkey(::JSONStyle, sym::Symbol) = String(sym)\nStructUtils.lowerkey(::JSONStyle, n::Union{Integer, Union{Float16, Float32, Float64}}) = string(n)\nStructUtils.lowerkey(::JSONStyle, x) = throw(ArgumentError(\"No key representation for $(typeof(x)). Define StructUtils.lowerkey(::$(typeof(x)))\"))\n\n\"\"\"\n    JSON.json(x) -> String\n    JSON.json(io, x)\n    JSON.json(file_name, x)\n\nSerialize `x` to JSON format. The 1st method takes just the object and returns a `String`.\nIn the 2nd method, `io` is an `IO` object, and the JSON output will be written to it.\nFor the 3rd method, `file_name` is a `String`, a file will be opened and the JSON output will be written to it.\n\nAll methods accept the following keyword arguments:\n\n- `omit_null::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are undefined or are `nothing` are included in the JSON output.\n  If `true`, only non-null fields are written. If `false`, all fields are included regardless of being undefined or `nothing`.\n  If `nothing`, the behavior is determined by `JSON.omit_null(::Type{T})`, which is `false` by default.\n\n- `omit_empty::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are empty are included in the JSON output.\n  If `true`, empty fields are excluded. If `false`, empty fields are included.\n  If `nothing`, the behavior is determined by `JSON.omit_empty(::Type{T})`.\n\n- `JSON.Null()` / `JSON.Omit()` sentinels: `JSON.Null()` always emits a JSON `null`\n  literal even when `omit_null=true`, enabling per-field overrides (for example by\n  declaring a field as `Union{Nothing, JSON.Null}`) or defining a custom `lower` function for a field that returns `JSON.Null`.\n  `JSON.Omit()` removes the enclosing value from the output regardless of global omit settings, making it easy for field-level\n  lowering code to drop optional data entirely. For example, by defining a custom `lower` function for a field that returns `JSON.Omit`.\n    \n- `allownan::Bool=false`: If `true`, allow `Inf`, `-Inf`, and `NaN` in the output.\n  If `false`, throw an error if `Inf`, `-Inf`, or `NaN` is encountered.\n\n- `jsonlines::Bool=false`: If `true`, input must be array-like and the output will be written in the JSON Lines format,\n  where each element of the array is written on a separate line (i.e. separated by a single newline character `\\n`).\n  If `false`, the output will be written in the standard JSON format.\n\n- `pretty::Union{Integer,Bool}=false`: Controls pretty printing of the JSON output.\n  If `true`, the output will be pretty-printed with 2 spaces of indentation.\n  If an integer, it will be used as the number of spaces of indentation.\n  If `false` or `0`, the output will be compact.\n  Note: Pretty printing is not supported when `jsonlines=true`.\n\n- `inline_limit::Int=0`: For arrays shorter than this limit, pretty printing will be disabled (indentation set to 0).\n\n- `ninf::String=\"-Infinity\"`: Custom string representation for negative infinity.\n\n- `inf::String=\"Infinity\"`: Custom string representation for positive infinity.\n\n- `nan::String=\"NaN\"`: Custom string representation for NaN.\n\n- `float_style::Symbol=:shortest`: Controls how floating-point numbers are formatted.\n  Options are:\n  - `:shortest`: Use the shortest representation that preserves the value\n  - `:fixed`: Use fixed-point notation\n  - `:exp`: Use exponential notation\n\n- `float_precision::Int=1`: Number of decimal places to use when `float_style` is `:fixed` or `:exp`.\n\n- `bufsize::Int=2^22`: Buffer size in bytes for IO operations. When writing to IO, the buffer will be flushed \n  to the IO stream once it reaches this size. This helps control memory usage during large write operations.\n  Default is 4MB (2^22 bytes). This parameter is ignored when returning a String.\n\n- `style::JSONStyle=JSONWriteStyle()`: Custom style object that controls serialization behavior. This allows customizing\n    certain aspects of serialization, like defining a custom `lower` method for a non-owned type. Like `struct MyStyle <: JSONStyle end`,\n    `JSON.lower(x::Rational) = (num=x.num, den=x.den)`, then calling `JSON.json(1//3; style=MyStyle())` will output\n    `{\"num\": 1, \"den\": 3}`.\n\nBy default, `x` must be a JSON-serializable object. Supported types include:\n  * `AbstractString` => JSON string: types must support the `AbstractString` interface, specifically with support for\n    `ncodeunits` and `codeunit(x, i)`.\n  * `Bool` => JSON boolean: must be `true` or `false`\n  * `Nothing` => JSON null: must be the `nothing` singleton value\n  * `Number` => JSON number: `Integer` subtypes or `Union{Float16, Float32, Float64}` have default implementations\n    for other `Number` types, [`JSON.tostring`](@ref) is first called to convert\n    the value to a `String` before being written directly to JSON output\n  * `AbstractArray`/`Tuple`/`AbstractSet` => JSON array: objects for which `JSON.arraylike` returns `true`\n     are output as JSON arrays. `arraylike` is defined by default for\n    `AbstractArray`, `AbstractSet`, `Tuple`, and `Base.Generator`. For other types that define,\n    they must also properly implement `StructUtils.applyeach` to iterate over the index => elements pairs.\n    Note that arrays with dimensionality > 1 are written as nested arrays, with `N` nestings for `N` dimensions,\n    and the 1st dimension is always the innermost nested JSON array (column-major order).\n  * `AbstractDict`/`NamedTuple`/structs => JSON object: if a value doesn't fall into any of the above categories,\n    it is output as a JSON object. `StructUtils.applyeach` is called, which has appropriate implementations\n    for `AbstractDict`, `NamedTuple`, and structs, where field names => values are iterated over. Field names can\n    be output with an alternative name via field tag overload, like `field::Type &(json=(name=\"alternative_name\",),)`\n\nIf an object is not JSON-serializable, an override for `JSON.lower` can\nbe defined to convert it to a JSON-serializable object. Some default `lower` defintions\nare defined in JSON itself, for example:\n  * `StructUtils.lower(::Missing) = nothing`\n  * `StructUtils.lower(x::Symbol) = String(x)`\n  * `StructUtils.lower(x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType}) = string(x)`\n  * `StructUtils.lower(x::Regex) = x.pattern`\n\nThese allow common Base/stdlib types to be serialized in an expected format.\n\nCircular references are tracked automatically and cycles are broken by writing `null` for any children references.\n\nFor pre-formatted JSON data as a String, use `JSONText(json)` to write the string out as-is.\n\nFor `AbstractDict` objects with non-string keys, `StructUtils.lowerkey` will be called before serializing. This allows aggregate\nor other types of dict keys to be converted to an appropriate string representation. See `StructUtils.liftkey`\nfor the reverse operation, which is called when parsing JSON data back into a dict type.\n\n*NOTE*: `JSON.json` should _not_ be overloaded directly by custom\ntypes as this isn't robust for various output options (IO, String, etc.)\nnor recursive situations. Types should define an appropriate\n`JSON.lower` definition instead.\n\n*NOTE*: `JSON.json(str, indent::Integer)` is special-cased for backwards compatibility with pre-1.0 JSON.jl,\nas this typically would mean \"write out the `indent` integer to file `str`\". As writing out a single integer to\na file is extremely rare, it was decided to keep the pre-1.0 behavior for compatibility reasons.\n\nExamples:\n```julia\nusing Dates\n\nabstract type AbstractMonster end\n\nstruct Dracula <: AbstractMonster\n    num_victims::Int\nend\n\nstruct Werewolf <: AbstractMonster\n    witching_hour::DateTime\nend\n\nstruct Percent <: Number\n    value::Float64\nend\n\nJSON.lower(x::Percent) = x.value\nStructUtils.lowerkey(x::Percent) = string(x.value)\n\n@noarg mutable struct FrankenStruct\n    id::Int\n    name::String # no default to show serialization of an undefined field\n    address::Union{Nothing, String} = nothing\n    rate::Union{Missing, Float64} = missing\n    type::Symbol = :a &(json=(name=\"franken_type\",),)\n    notsure::Any = JSON.Object(\"key\" => \"value\")\n    monster::AbstractMonster = Dracula(10) &(json=(lower=x -> x isa Dracula ? (monster_type=\"vampire\", num_victims=x.num_victims) : (monster_type=\"werewolf\", witching_hour=x.witching_hour),),)\n    percent::Percent = Percent(0.5)\n    birthdate::Date = Date(2025, 1, 1) &(json=(dateformat=\"yyyy/mm/dd\",),)\n    percentages::Dict{Percent, Int} = Dict{Percent, Int}(Percent(0.0) => 0, Percent(1.0) => 1)\n    json_properties::JSONText = JSONText(\"{\\\"key\\\": \\\"value\\\"}\")\n    matrix::Matrix{Float64} = [1.0 2.0; 3.0 4.0]\n    extra_field::Any = nothing &(json=(ignore=true,),)\nend\n\nfranken = FrankenStruct()\nfranken.id = 1\n\njson = JSON.json(franken; omit_null=false)\n# \"{\\\"id\\\":1,\\\"name\\\":null,\\\"address\\\":null,\\\"rate\\\":null,\\\"franken_type\\\":\\\"a\\\",\\\"notsure\\\":{\\\"key\\\":\\\"value\\\"},\\\"monster\\\":{\\\"monster_type\\\":\\\"vampire\\\",\\\"num_victims\\\":10},\\\"percent\\\":0.5,\\\"birthdate\\\":\\\"2025/01/01\\\",\\\"percentages\\\":{\\\"1.0\\\":1,\\\"0.0\\\":0},\\\"json_properties\\\":{\\\"key\\\": \\\"value\\\"},\\\"matrix\\\":[[1.0,3.0],[2.0,4.0]]}\"\n```\n\nA few comments on the JSON produced in the example above:\n  - The `name` field was `#undef`, and thus was serialized as `null`.\n  - The `address` and `rate` fields were `nothing` and `missing`, respectively, and thus were serialized as `null`.\n  - The `type` field has a `name` field tag, so the JSON key for this field is `franken_type` instead of `type`.\n  - The `notsure` field is a `JSON.Object`, so it is serialized as a JSON object.\n  - The `monster` field is a `AbstractMonster`, which is a custom type. It has a `lower` field tag that specifies how the value of this field specifically (not all AbstractMonster) should be serialized\n  - The `percent` field is a `Percent`, which is a custom type. It has a `lower` method that specifies how `Percent` values should be serialized\n  - The `birthdate` field has a `dateformat` field tag, so the value follows the format (`yyyy/mm/dd`) instead of the default date ISO format (`yyyy-mm-dd`)\n  - The `percentages` field is a `Dict{Percent, Int}`, which is a custom type. It has a `lowerkey` method that specifies how `Percent` keys should be serialized as strings\n  - The `json_properties` field is a `JSONText`, so the JSONText value is serialized as-is\n  - The `matrix` field is a `Matrix{Float64}`, which is a custom type. It is serialized as a JSON array, with the first dimension being the innermost nested JSON array (column-major order)\n  - The `extra_field` field has a `ignore` field tag, so it is skipped when serializing\n\n\"\"\"\nfunction json end\n\n@kwdef struct WriteOptions{S}\n    omit_null::Union{Bool, Nothing} = nothing\n    omit_empty::Union{Bool, Nothing} = nothing\n    allownan::Bool = false\n    jsonlines::Bool = false\n    pretty::Int = 0\n    ninf::String = \"-Infinity\"\n    inf::String = \"Infinity\"\n    nan::String = \"NaN\"\n    inline_limit::Int = 0\n    float_style::Symbol = :shortest # :shortest, :fixed, :exp\n    float_precision::Int = 1\n    bufsize::Int = 2^22 # 4MB default buffer size for IO flushing\n    style::S = JSONWriteStyle()\nend\n\n@noinline float_style_throw(fs) = throw(ArgumentError(\"Invalid float style: $fs\"))\nfloat_style_check(fs) = fs == :shortest || fs == :fixed || fs == :exp || float_style_throw(fs)\n\n@noinline float_precision_throw(fs, fp) = throw(ArgumentError(\"float_precision must be positive when float_style is $fs; got $fp\"))\nfloat_precision_check(fs, fp) = (fs == :shortest || fp > 0) || float_precision_throw(fs, fp)\n\n# if jsonlines and pretty is not 0 or false, throw an ArgumentError\n@noinline _jsonlines_pretty_throw() = throw(ArgumentError(\"pretty printing is not supported when writing jsonlines\"))\n_jsonlines_pretty_check(jsonlines, pretty) = jsonlines && pretty !== false && !iszero(pretty) && _jsonlines_pretty_throw()\n@noinline _root_omit_throw() = throw(ArgumentError(\"JSON.Omit() is only valid inside arrays or objects\"))\n\nfunction json(io::IO, x::T; pretty::Union{Integer,Bool}=false, kw...) where {T}\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    # Use smaller initial buffer size, limited by bufsize\n    initial_size = min(sizeguess(y), opts.bufsize)\n    buf = Vector{UInt8}(undef, initial_size)\n    pos = json!(buf, 1, y, opts, Any[y], io)\n    # Write any remaining buffer contents to IO\n    if pos > 1\n        write(io, view(buf, 1:pos-1))\n    end\n    return nothing\nend\n\nif isdefined(Base, :StringVector)\n    stringvec(n) = Base.StringVector(n)\nelse\n    stringvec(n) = Vector{UInt8}(undef, n)\nend\n\nfunction json(x; pretty::Union{Integer,Bool}=false, kw...)\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    buf = stringvec(sizeguess(y))\n    pos = json!(buf, 1, y, opts, Any[y], nothing)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction json(fname, obj; kw...)\n    if obj isa Integer\n        # special-case for pre-1.0 JSON compat\n        return json(fname; pretty=obj)\n    else\n        @assert fname isa AbstractString \"filename must be a string\"\n    end\n    open(fname, \"w\") do io\n        json(io, obj; kw...)\n    end\n    return fname\nend\n\n# we use the same growth strategy as Base julia does for array growing\n# which starts with small N at ~5x and approaches 1.125x as N grows\n# ref: https://github.com/JuliaLang/julia/pull/40453\nnewlen(n\u2080) = ceil(Int, n\u2080 + 4*n\u2080^(7 / 8) + n\u2080 / 8)\n\nmacro checkn(n, force_resize=false)\n    esc(quote\n        if (pos + $n - 1) > length(buf)\n            # If we have an IO object and buffer would exceed bufsize, flush to IO first\n            # unless force_resize is true (used for comma writing to avoid flushing partial JSON)\n            if io !== nothing && length(buf) >= bufsize && pos > 1 && !$force_resize\n                write(io, view(buf, 1:pos-1))\n                pos = 1\n            end\n            # Resize buffer if still needed\n            if (pos + $n - 1) > length(buf)\n                resize!(buf, newlen(pos + $n))\n            end\n        end\n    end)\nend\n\nstruct WriteClosure{JS, arraylike, T, I} # T is the type of the parent object/array being written\n    buf::Vector{UInt8}\n    pos::Ptr{Int}\n    wroteany::Ptr{Bool} # to track if we wrote any data to the buffer\n    indent::Int\n    depth::Int\n    opts::JS\n    ancestor_stack::Vector{Any} # to track circular references\n    io::I\n    bufsize::Int\nend\n\nfunction indent(buf, pos, ind, depth, io, bufsize)\n    if ind > 0\n        n = ind * depth + 1\n        @checkn n\n        buf[pos] = UInt8('\\n')\n        for i = 1:(n - 1)\n            buf[pos + i] = UInt8(' ')\n        end\n        pos += n\n    end\n    return pos\nend\n\ncheckkey(s) = s isa AbstractString || throw(ArgumentError(\"Value returned from `StructUtils.lowerkey` must be a string: $(typeof(s))\"))\n\nfunction (f::WriteClosure{JS, arraylike, T, I})(key, val) where {JS, arraylike, T, I}\n    track_ref = ismutabletype(typeof(val))\n    is_circ_ref = track_ref && any(x -> x === val, f.ancestor_stack)\n    val isa Omit && return\n    if !arraylike\n        # for objects, check omit_null/omit_empty\n        # and skip if the value is null or empty\n        if f.opts.omit_null === true || (f.opts.omit_null === nothing && omit_null(f.opts.style, T))\n            (is_circ_ref || val === nothing) && return\n        end\n        if f.opts.omit_empty === true || (f.opts.omit_empty === nothing && omit_empty(f.opts.style, T))\n            (is_circ_ref || is_empty(val)) && return\n        end\n    end\n    pos = unsafe_load(f.pos)\n    unsafe_store!(f.wroteany, true) # at this point, we know something will be written\n    buf = f.buf\n    ind = f.indent\n    io = f.io\n    bufsize = f.bufsize\n    pos = indent(buf, pos, ind, f.depth, io, bufsize)\n    # if not an array, we need to write the key + ':'\n    if !arraylike\n        # skey = StructUtils.lowerkey(f.opts, key)\n        # check if the key is a string\n        checkkey(key)\n        pos = _string(buf, pos, key, io, bufsize)\n        @checkn 1\n        buf[pos] = UInt8(':')\n        pos += 1\n        if ind > 0\n            @checkn 1\n            buf[pos] = UInt8(' ')\n            pos += 1\n        end\n    end\n    # check if the lowered value is in our ancestor stack\n    if is_circ_ref\n        # if so, it's a circular reference! so we just write `null`\n        pos = _null(buf, pos, io, bufsize)\n    else\n        track_ref && push!(f.ancestor_stack, val)\n        # if jsonlines, we need to recursively set to false\n        if f.opts.jsonlines\n            opts = WriteOptions(; omit_null=f.opts.omit_null, omit_empty=f.opts.omit_empty, allownan=f.opts.allownan, jsonlines=false, pretty=f.opts.pretty, ninf=f.opts.ninf, inf=f.opts.inf, nan=f.opts.nan, inline_limit=f.opts.inline_limit, float_style=f.opts.float_style, float_precision=f.opts.float_precision)\n        else\n            opts = f.opts\n        end\n        pos = json!(buf, pos, val, opts, f.ancestor_stack, io, ind, f.depth, bufsize)\n        track_ref && pop!(f.ancestor_stack)\n    end\n    @checkn 1 true\n    @inbounds buf[pos] = f.opts.jsonlines ? UInt8('\\n') : UInt8(',')\n    pos += 1\n    # store our updated pos\n    unsafe_store!(f.pos, pos)\n    return\nend\n\n@noinline throwjsonlines() = throw(ArgumentError(\"jsonlines only supported for arraylike\"))\n\n# assume x is lowered value\nfunction json!(buf, pos, x, opts::WriteOptions, ancestor_stack::Union{Nothing, Vector{Any}}=nothing, io::Union{Nothing, IO}=nothing, ind::Int=opts.pretty, depth::Int=0, bufsize::Int=opts.bufsize)\n    # string\n    if x isa Omit\n        _root_omit_throw()\n    elseif x isa Null\n        return _null(buf, pos, io, bufsize)\n    elseif x isa AbstractString\n        return _string(buf, pos, x, io, bufsize)\n    # write JSONText out directly\n    elseif x isa JSONText\n        val = x.value\n        @checkn sizeof(val)\n        for i = 1:sizeof(val)\n            @inbounds buf[pos + i - 1] = codeunit(val, i)\n        end\n        return pos + sizeof(val)\n    # bool; check before Number since Bool <: Number\n    elseif x isa Bool\n        if x\n            @checkn 4\n            @inbounds buf[pos] = 't'\n            @inbounds buf[pos + 1] = 'r'\n            @inbounds buf[pos + 2] = 'u'\n            @inbounds buf[pos + 3] = 'e'\n            return pos + 4\n        else\n            @checkn 5\n            @inbounds buf[pos] = 'f'\n            @inbounds buf[pos + 1] = 'a'\n            @inbounds buf[pos + 2] = 'l'\n            @inbounds buf[pos + 3] = 's'\n            @inbounds buf[pos + 4] = 'e'\n            return pos + 5\n        end\n    # number\n    elseif x isa Number\n        return _number(buf, pos, x, opts, io, bufsize)\n    # null\n    elseif x === nothing\n        return _null(buf, pos, io, bufsize)\n    # object or array\n    elseif StructUtils.dictlike(opts.style, x) || StructUtils.arraylike(opts.style, x) || StructUtils.structlike(opts.style, x)\n        al = StructUtils.arraylike(opts.style, x)\n        # override pretty indent to 0 for arrays shorter than inline_limit\n        if al && opts.pretty > 0 && opts.inline_limit > 0 && length(x) < opts.inline_limit\n            local_ind = 0\n        else\n            local_ind = ind\n        end\n        if !opts.jsonlines\n            @checkn 1\n            @inbounds buf[pos] = al ? UInt8('[') : UInt8('{')\n            pos += 1\n        else\n            al || throwjsonlines()\n        end\n        ref = Ref(pos)\n        wroteany = false\n        wroteanyref = Ref(false)\n        GC.@preserve ref wroteanyref begin\n            c = WriteClosure{typeof(opts), al, typeof(x), typeof(io)}(buf, Base.unsafe_convert(Ptr{Int}, ref), Base.unsafe_convert(Ptr{Bool}, wroteanyref), local_ind, depth + 1, opts, ancestor_stack, io, bufsize)\n            StructUtils.applyeach(opts.style, c, x)\n            # get updated pos\n            pos = unsafe_load(c.pos)\n            wroteany = unsafe_load(c.wroteany)\n        end\n        # in WriteClosure, we eagerly write a comma after each element\n        # so for non-empty object/arrays, we can just overwrite the last comma with the closechar\n        if wroteany\n            pos -= 1\n            pos = indent(buf, pos, local_ind, depth, io, bufsize)\n        end\n        # even if the input is empty and we're jsonlines, the spec says it's ok to end w/ a newline\n        @checkn 1\n        @inbounds buf[pos] = opts.jsonlines ? UInt8('\\n') : al ? UInt8(']') : UInt8('}')\n        return pos + 1\n    else\n        return _string(buf, pos, x, io, bufsize)\n    end\nend\n\nfunction _null(buf, pos, io, bufsize)\n    @checkn 4\n    @inbounds buf[pos] = 'n'\n    @inbounds buf[pos + 1] = 'u'\n    @inbounds buf[pos + 2] = 'l'\n    @inbounds buf[pos + 3] = 'l'\n    return pos + 4\nend\n\n_string(buf, pos, x, io, bufsize) = _string(buf, pos, string(x), io, bufsize)\n_string(buf, pos, x::LazyValues, io, bufsize) = _string(buf, pos, getindex(x), io, bufsize)\n_string(buf, pos, x::PtrString, io, bufsize) = _string(buf, pos, convert(String, x), io, bufsize)\n\nfunction _string(buf, pos, x::AbstractString, io, bufsize)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @checkn (el + 2)\n    @inbounds buf[pos] = UInt8('\"')\n    pos += 1\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds buf[pos] = UInt8('\"')\n    return pos + 1\nend\n\n\"\"\"\n    JSON.tostring(x)\n\nOverloadable function that allows non-`Integer` `Number` types\nto convert themselves to a `String` that is then used\nwhen serializing `x` to JSON. Note that if the result of `tostring`\nis not a valid JSON number, it will be serialized as a JSON string,\nwith double quotes around it.\n\nAn example overload would look something like:\n```julia\nJSON.tostring(x::MyDecimal) = string(x)\n```\n\"\"\"\ntostring(x) = string(Float64(x))\n\nsplit_sign(n::Integer) = unsigned(abs(n)), n < 0\nsplit_sign(n::Unsigned) = n, false\nsplit_sign(x::BigInt) = (abs(x), x < 0)\n\n@noinline infcheck(x, allownan) = isfinite(x) || allownan || throw(ArgumentError(\"$x not allowed to be written in JSON spec; pass `allownan=true` to allow anyway\"))\n\nfunction _number(buf, pos, x::Number, opts::WriteOptions, io, bufsize)\n    if x isa Integer\n        y, neg = split_sign(x)\n        n = i = ndigits(y, base=10, pad=1)\n        @checkn (i + neg)\n        if neg\n            @inbounds buf[pos] = UInt8('-')\n            pos += 1\n        end\n        while i > 0\n            @inbounds buf[pos + i - 1] = 48 + rem(y, 10)\n            y = oftype(y, div(y, 10))\n            i -= 1\n        end\n        return pos + n\n    elseif x isa Union{Float16, Float32, Float64}\n        infcheck(x, opts.allownan)\n        if isnan(x)\n            nan = opts.nan\n            @checkn sizeof(nan)\n            for i = 1:sizeof(nan)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(nan, i))\n            end\n            return pos + sizeof(nan)\n        elseif isinf(x)\n            if x < 0\n                inf = opts.ninf\n            else\n                inf = opts.inf\n            end\n            @checkn sizeof(inf)\n            for i = 1:sizeof(inf)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(inf, i))\n            end\n            return pos + sizeof(inf)\n        end\n        if opts.float_style == :shortest\n            @checkn Base.Ryu.neededdigits(typeof(x))\n            return Base.Ryu.writeshortest(buf, pos, x)\n        elseif opts.float_style == :fixed\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writefixed(buf, pos, x, opts.float_precision, false, false, true)\n        elseif opts.float_style == :exp\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writeexp(buf, pos, x, opts.float_precision, false, false, true)\n        else\n            # unreachable as we validate float_style inputs\n            @assert false\n        end\n    else\n        str = tostring(x)\n        if anyinvalidnumberchars(str)\n            # serialize as string\n            return _string(buf, pos, str, io, bufsize)\n        end\n        bytes = codeunits(str)\n        sz = sizeof(bytes)\n        @checkn sz\n        for i = 1:sz\n            @inbounds buf[pos + i - 1] = bytes[i]\n        end\n        return pos + sz\n    end\nend\n\nfunction anyinvalidnumberchars(x)\n    for i = 1:sizeof(x)\n        b = codeunit(x, i)\n        if !(b == UInt8('-') || b == UInt8('.') || b == UInt8('e') || b == UInt8('E') ||\n            UInt8('0') <= b <= UInt8('9'))\n            return true\n        end\n    end\n    return false\nend\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": ["test/json.jl"], "lines_changed": 83, "is_valid": true, "validation_errors": []}
{"repo": "JSON.jl", "commit_sha": "8d648bd094ddaa760d9d7dc146acb39edd6538e1", "parent_sha": "738fda98278153c927e521c04f1f179da5d8bde9", "commit_message": "add get methods for cross-key-type support on Object", "commit_date": "2026-01-12T16:48:51-07:00", "action": {"type": "ADD_METHOD", "target_file": "src/object.jl", "target_symbol": "Base.get", "signature": null, "confidence": 0.85}, "files_before": {"src/object.jl": "struct NotSet end\nconst notset = NotSet()\n\n\"\"\"\n    JSON.Object{K,V}\n\nA mutable `AbstractDict` type for JSON objects. Internally is a linked list of key-value pairs, where each pair is represented by an `Object` instance. The first instance is the root object.\nThe `Object` type is used to represent JSON objects in a mutable way, allowing for efficient insertion and deletion of key-value pairs. It is designed to be used with the `JSON` package for parsing and deserializing JSON data.\n\nBecause of the linked-list representation, key lookups are O(n), using a simple linear scan.\nFor small objects, this is very efficient, and worth the memory overhead vs. a full `Dict` or `OrderedDict`.\nFor Objects with many entries (hundreds or thousands), this is not as efficient. In that case, consider using a `Dict` or `OrderedDict` instead.\n\"\"\"\n# empty Object: key, value, child all notset\n# root Object: key, value are notset, child is defined\n# non-root Object: key, value are set, child is notset for last node\nmutable struct Object{K,V} <: AbstractDict{K,V}\n    key::Union{NotSet, K} # for root object, key/value are notset\n    value::Union{NotSet, V}\n    child::Union{NotSet, Object{K,V}} # possibly notset\n\n    # root constructor: key is const notset\n    function Object{K,V}() where {K,V}\n        x = new{K,V}(notset, notset, notset)\n        return x\n    end\n\n    # all non-root Objects *must* be set as the child of another Object\n    # WARNING: this constructor can allow duplicate `k` in a root Object as no check is done\n    function Object{K,V}(obj::Object{K,V}, k, v) where {K,V}\n        @assert _ch(obj) === notset \"Object child already defined\"\n        nobj = new{K,V}(k, v, notset)\n        setfield!(obj, :child, nobj)\n        return nobj\n    end\nend\n\nObject() = Object{Any, Any}() # default empty object\n\n_k(obj::Object) = getfield(obj, :key)\n_v(obj::Object) = getfield(obj, :value)\n_ch(obj::Object) = getfield(obj, :child)\n\nObject(d::AbstractDict{K,V}) where {K,V} = Object{K,V}(d)\n\nfunction Object{K,V}(d::AbstractDict{K,V}) where {K,V}\n    root = obj = Object{K,V}()\n    for (k, v) in d\n        obj = Object{K,V}(obj, k, v)\n    end\n    return root\nend\n\nObject(pairs::Pair{K,V}...) where {K,V} = Object{K,V}(pairs...)\nObject(pairs::Pair...) = Object{Any,Any}(pairs...)\n\nfunction Object{K,V}(pairs::Pair...) where {K,V}\n    root = obj = Object{K,V}()\n    for (k, v) in pairs\n        obj = Object{K,V}(obj, k, v)\n    end\n    return root\nend\n\n# generic iterator constructors\nfunction Object(itr)\n    root = obj = nothing\n    st = iterate(itr)\n    while st !== nothing\n        kv, state = st\n        if kv isa Pair || kv isa Tuple{Any,Any}\n            k, v = kv\n            if root === nothing\n                root = Object{typeof(k), typeof(v)}()\n                obj = root\n            end\n            obj = Object{typeof(k), typeof(v)}(obj, k, v)\n        else\n            throw(ArgumentError(\"Iterator must yield Pair or 2-tuple, got $(typeof(kv))\"))\n        end\n        st = iterate(itr, state)\n    end\n    return root === nothing ? Object{Any,Any}() : root\nend\n\nfunction Object{K,V}(itr) where {K,V}\n    root = obj = Object{K,V}()\n    st = iterate(itr)\n    while st !== nothing\n        kv, state = st\n        if kv isa Pair || kv isa Tuple{Any,Any}\n            k, v = kv\n            obj = Object{K, V}(obj, k, v)\n        else\n            throw(ArgumentError(\"Iterator must yield Pair or 2-tuple, got $(typeof(kv))\"))\n        end\n        st = iterate(itr, state)\n    end\n    return root\nend\n\nfunction Base.iterate(orig::Object{K,V}, obj=orig) where {K,V}\n    obj === nothing && return nothing\n    if _k(obj) === notset\n        # if key is notset, we either have to iterate from the child or we're done\n        return _ch(obj) === notset ? nothing : iterate(_ch(obj)::Object{K,V})\n    end\n    return (Pair{K,V}(_k(obj)::K, _v(obj)::V), _ch(obj) === notset ? nothing : _ch(obj)::Object{K,V})\nend\n\nfunction Base.length(obj::Object{K,V}) where {K,V}\n    count = 0\n    while true\n        _k(obj) !== notset && (count += 1)\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    return count\nend\nBase.isempty(obj::Object) = _k(obj) === notset && _ch(obj) === notset\nBase.empty(::Object{K,V}) where {K,V} = Object{K,V}() # empty object\n\n# linear node lookup\n@inline function find_node_by_key(obj::Object{K,V}, key::K) where {K,V}\n    while true\n        _k(obj) !== notset && isequal(_k(obj)::K, key) && return obj\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    return nothing\nend\n\n# get with fallback callable\nfunction Base.get(f::Base.Callable, obj::Object{K,V}, key) where {K,V}\n    node = find_node_by_key(obj, key)\n    node !== nothing && return _v(node)::V\n    return f()\nend\n\nBase.getindex(obj::Object, key) = get(() -> throw(KeyError(key)), obj, key)\nBase.getindex(obj::Object{String}, key::Symbol) = get(() -> throw(KeyError(key)), obj, String(key))\nBase.getindex(obj::Object{Symbol}, key::String) = get(() -> throw(KeyError(key)), obj, Symbol(key))\nBase.setindex!(obj::Object{String}, value, key::Symbol) = setindex!(obj, value, String(key))\nBase.setindex!(obj::Object{Symbol}, value, key::String) = setindex!(obj, value, Symbol(key))\nBase.delete!(obj::Object{String}, key::Symbol) = delete!(obj, String(key))\nBase.delete!(obj::Object{Symbol}, key::String) = delete!(obj, Symbol(key))\nBase.get(obj::Object, key, default) = get(() -> default, obj, key)\n\n# support getproperty for dot access\nBase.getproperty(obj::Object{Symbol}, sym::Symbol) = getindex(obj, sym)\nBase.getproperty(obj::Object{String}, sym::Symbol) = getindex(obj, String(sym))\nBase.propertynames(obj::Object{K,V}) where {K,V} = _k(obj) === notset && _ch(obj) === notset ? () : _propertynames(_ch(obj)::Object{K,V}, ())\n\nfunction _propertynames(obj::Object{K,V}, acc) where {K,V}\n    new = (acc..., Symbol(_k(obj)::K))\n    return _ch(obj) === notset ? new : _propertynames(_ch(obj)::Object{K,V}, new)\nend\n\n# haskey\nBase.haskey(obj::Object, key) = find_node_by_key(obj, key) !== nothing\nBase.haskey(obj::Object{String}, key::Symbol) = haskey(obj, String(key))\nBase.haskey(obj::Object{Symbol}, key::String) = haskey(obj, Symbol(key))\n\n# setindex! finds node with key and sets value or inserts a new node\nfunction Base.setindex!(obj::Object{K,V}, value, key::K) where {K,V}\n    root = obj\n    while true\n        if _k(obj) !== notset && isequal(_k(obj)::K, key)\n            setfield!(obj, :value, convert(V, value))\n            return root\n        end\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    # if we reach here, we need to insert a new node\n    Object{K,V}(obj, key, value)\n    return value\nend\n\n# delete! removes node\nfunction Base.delete!(obj::Object{K,V}, key::K) where {K,V}\n    # check empty case\n    _ch(obj) === notset && return obj\n    root = parent = obj\n    obj = _ch(obj)::Object{K,V}\n    while true\n        if _k(obj) !== notset && isequal(_k(obj)::K, key)\n            # we found the node to remove\n            # if node is leaf, we need to set parent as leaf\n            # otherwise, we set child as child of parent\n            if _ch(obj) === notset\n                setfield!(parent, :child, notset)\n            else\n                setfield!(parent, :child, _ch(obj)::Object{K,V})\n            end\n        end\n        _ch(obj) === notset && break\n        parent = obj\n        obj = _ch(obj)::Object{K,V}\n    end\n    return root\nend\n\nfunction Base.empty!(obj::Object)\n    setfield!(obj, :child, notset)\n    return obj\nend\n\n# support setproperty for dot access\nBase.setproperty!(obj::Object, sym::Symbol, val) = setindex!(obj, val, sym)\nBase.setproperty!(obj::Object{String}, sym::Symbol, val) = setindex!(obj, val, String(sym))\n\nBase.merge(a::NamedTuple, b::Object{String,Any}) = merge(a, (Symbol(k) => v for (k, v) in b))"}, "files_after": {"src/object.jl": "struct NotSet end\nconst notset = NotSet()\n\n\"\"\"\n    JSON.Object{K,V}\n\nA mutable `AbstractDict` type for JSON objects. Internally is a linked list of key-value pairs, where each pair is represented by an `Object` instance. The first instance is the root object.\nThe `Object` type is used to represent JSON objects in a mutable way, allowing for efficient insertion and deletion of key-value pairs. It is designed to be used with the `JSON` package for parsing and deserializing JSON data.\n\nBecause of the linked-list representation, key lookups are O(n), using a simple linear scan.\nFor small objects, this is very efficient, and worth the memory overhead vs. a full `Dict` or `OrderedDict`.\nFor Objects with many entries (hundreds or thousands), this is not as efficient. In that case, consider using a `Dict` or `OrderedDict` instead.\n\"\"\"\n# empty Object: key, value, child all notset\n# root Object: key, value are notset, child is defined\n# non-root Object: key, value are set, child is notset for last node\nmutable struct Object{K,V} <: AbstractDict{K,V}\n    key::Union{NotSet, K} # for root object, key/value are notset\n    value::Union{NotSet, V}\n    child::Union{NotSet, Object{K,V}} # possibly notset\n\n    # root constructor: key is const notset\n    function Object{K,V}() where {K,V}\n        x = new{K,V}(notset, notset, notset)\n        return x\n    end\n\n    # all non-root Objects *must* be set as the child of another Object\n    # WARNING: this constructor can allow duplicate `k` in a root Object as no check is done\n    function Object{K,V}(obj::Object{K,V}, k, v) where {K,V}\n        @assert _ch(obj) === notset \"Object child already defined\"\n        nobj = new{K,V}(k, v, notset)\n        setfield!(obj, :child, nobj)\n        return nobj\n    end\nend\n\nObject() = Object{Any, Any}() # default empty object\n\n_k(obj::Object) = getfield(obj, :key)\n_v(obj::Object) = getfield(obj, :value)\n_ch(obj::Object) = getfield(obj, :child)\n\nObject(d::AbstractDict{K,V}) where {K,V} = Object{K,V}(d)\n\nfunction Object{K,V}(d::AbstractDict{K,V}) where {K,V}\n    root = obj = Object{K,V}()\n    for (k, v) in d\n        obj = Object{K,V}(obj, k, v)\n    end\n    return root\nend\n\nObject(pairs::Pair{K,V}...) where {K,V} = Object{K,V}(pairs...)\nObject(pairs::Pair...) = Object{Any,Any}(pairs...)\n\nfunction Object{K,V}(pairs::Pair...) where {K,V}\n    root = obj = Object{K,V}()\n    for (k, v) in pairs\n        obj = Object{K,V}(obj, k, v)\n    end\n    return root\nend\n\n# generic iterator constructors\nfunction Object(itr)\n    root = obj = nothing\n    st = iterate(itr)\n    while st !== nothing\n        kv, state = st\n        if kv isa Pair || kv isa Tuple{Any,Any}\n            k, v = kv\n            if root === nothing\n                root = Object{typeof(k), typeof(v)}()\n                obj = root\n            end\n            obj = Object{typeof(k), typeof(v)}(obj, k, v)\n        else\n            throw(ArgumentError(\"Iterator must yield Pair or 2-tuple, got $(typeof(kv))\"))\n        end\n        st = iterate(itr, state)\n    end\n    return root === nothing ? Object{Any,Any}() : root\nend\n\nfunction Object{K,V}(itr) where {K,V}\n    root = obj = Object{K,V}()\n    st = iterate(itr)\n    while st !== nothing\n        kv, state = st\n        if kv isa Pair || kv isa Tuple{Any,Any}\n            k, v = kv\n            obj = Object{K, V}(obj, k, v)\n        else\n            throw(ArgumentError(\"Iterator must yield Pair or 2-tuple, got $(typeof(kv))\"))\n        end\n        st = iterate(itr, state)\n    end\n    return root\nend\n\nfunction Base.iterate(orig::Object{K,V}, obj=orig) where {K,V}\n    obj === nothing && return nothing\n    if _k(obj) === notset\n        # if key is notset, we either have to iterate from the child or we're done\n        return _ch(obj) === notset ? nothing : iterate(_ch(obj)::Object{K,V})\n    end\n    return (Pair{K,V}(_k(obj)::K, _v(obj)::V), _ch(obj) === notset ? nothing : _ch(obj)::Object{K,V})\nend\n\nfunction Base.length(obj::Object{K,V}) where {K,V}\n    count = 0\n    while true\n        _k(obj) !== notset && (count += 1)\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    return count\nend\nBase.isempty(obj::Object) = _k(obj) === notset && _ch(obj) === notset\nBase.empty(::Object{K,V}) where {K,V} = Object{K,V}() # empty object\n\n# linear node lookup\n@inline function find_node_by_key(obj::Object{K,V}, key::K) where {K,V}\n    while true\n        _k(obj) !== notset && isequal(_k(obj)::K, key) && return obj\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    return nothing\nend\n\n# get with fallback callable\nfunction Base.get(f::Base.Callable, obj::Object{K,V}, key) where {K,V}\n    node = find_node_by_key(obj, key)\n    node !== nothing && return _v(node)::V\n    return f()\nend\nBase.get(f::Base.Callable, obj::Object{String}, key::Symbol) = get(f, obj, String(key))\nBase.get(f::Base.Callable, obj::Object{Symbol}, key::String) = get(f, obj, Symbol(key))\n\nBase.getindex(obj::Object, key) = get(() -> throw(KeyError(key)), obj, key)\nBase.getindex(obj::Object{String}, key::Symbol) = get(() -> throw(KeyError(key)), obj, String(key))\nBase.getindex(obj::Object{Symbol}, key::String) = get(() -> throw(KeyError(key)), obj, Symbol(key))\nBase.setindex!(obj::Object{String}, value, key::Symbol) = setindex!(obj, value, String(key))\nBase.setindex!(obj::Object{Symbol}, value, key::String) = setindex!(obj, value, Symbol(key))\nBase.delete!(obj::Object{String}, key::Symbol) = delete!(obj, String(key))\nBase.delete!(obj::Object{Symbol}, key::String) = delete!(obj, Symbol(key))\nBase.get(obj::Object, key, default) = get(() -> default, obj, key)\nBase.get(obj::Object{String}, key::Symbol, default) = get(obj, String(key), default)\nBase.get(obj::Object{Symbol}, key::String, default) = get(obj, Symbol(key), default)\n\n# support getproperty for dot access\nBase.getproperty(obj::Object{Symbol}, sym::Symbol) = getindex(obj, sym)\nBase.getproperty(obj::Object{String}, sym::Symbol) = getindex(obj, String(sym))\nBase.propertynames(obj::Object{K,V}) where {K,V} = _k(obj) === notset && _ch(obj) === notset ? () : _propertynames(_ch(obj)::Object{K,V}, ())\n\nfunction _propertynames(obj::Object{K,V}, acc) where {K,V}\n    new = (acc..., Symbol(_k(obj)::K))\n    return _ch(obj) === notset ? new : _propertynames(_ch(obj)::Object{K,V}, new)\nend\n\n# haskey\nBase.haskey(obj::Object, key) = find_node_by_key(obj, key) !== nothing\nBase.haskey(obj::Object{String}, key::Symbol) = haskey(obj, String(key))\nBase.haskey(obj::Object{Symbol}, key::String) = haskey(obj, Symbol(key))\n\n# setindex! finds node with key and sets value or inserts a new node\nfunction Base.setindex!(obj::Object{K,V}, value, key::K) where {K,V}\n    root = obj\n    while true\n        if _k(obj) !== notset && isequal(_k(obj)::K, key)\n            setfield!(obj, :value, convert(V, value))\n            return root\n        end\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    # if we reach here, we need to insert a new node\n    Object{K,V}(obj, key, value)\n    return value\nend\n\n# delete! removes node\nfunction Base.delete!(obj::Object{K,V}, key::K) where {K,V}\n    # check empty case\n    _ch(obj) === notset && return obj\n    root = parent = obj\n    obj = _ch(obj)::Object{K,V}\n    while true\n        if _k(obj) !== notset && isequal(_k(obj)::K, key)\n            # we found the node to remove\n            # if node is leaf, we need to set parent as leaf\n            # otherwise, we set child as child of parent\n            if _ch(obj) === notset\n                setfield!(parent, :child, notset)\n            else\n                setfield!(parent, :child, _ch(obj)::Object{K,V})\n            end\n        end\n        _ch(obj) === notset && break\n        parent = obj\n        obj = _ch(obj)::Object{K,V}\n    end\n    return root\nend\n\nfunction Base.empty!(obj::Object)\n    setfield!(obj, :child, notset)\n    return obj\nend\n\n# support setproperty for dot access\nBase.setproperty!(obj::Object, sym::Symbol, val) = setindex!(obj, val, sym)\nBase.setproperty!(obj::Object{String}, sym::Symbol, val) = setindex!(obj, val, String(sym))\n\nBase.merge(a::NamedTuple, b::Object{String,Any}) = merge(a, (Symbol(k) => v for (k, v) in b))"}, "source_files_changed": ["src/object.jl"], "test_files_changed": ["test/object.jl"], "lines_changed": 20, "is_valid": true, "validation_errors": []}
{"repo": "JSON.jl", "commit_sha": "738fda98278153c927e521c04f1f179da5d8bde9", "parent_sha": "81fa0713962950107e6eb2de95583ee291d3558a", "commit_message": "add methods for setindex!, delete!, haskey for obj::Object{String}, key::Symbol and vice versa plus respective tests (#421)", "commit_date": "2026-01-13T00:45:22+01:00", "action": {"type": "ADD_METHOD", "target_file": "src/object.jl", "target_symbol": "Base.haskey", "signature": null, "confidence": 0.85}, "files_before": {"src/object.jl": "struct NotSet end\nconst notset = NotSet()\n\n\"\"\"\n    JSON.Object{K,V}\n\nA mutable `AbstractDict` type for JSON objects. Internally is a linked list of key-value pairs, where each pair is represented by an `Object` instance. The first instance is the root object.\nThe `Object` type is used to represent JSON objects in a mutable way, allowing for efficient insertion and deletion of key-value pairs. It is designed to be used with the `JSON` package for parsing and deserializing JSON data.\n\nBecause of the linked-list representation, key lookups are O(n), using a simple linear scan.\nFor small objects, this is very efficient, and worth the memory overhead vs. a full `Dict` or `OrderedDict`.\nFor Objects with many entries (hundreds or thousands), this is not as efficient. In that case, consider using a `Dict` or `OrderedDict` instead.\n\"\"\"\n# empty Object: key, value, child all notset\n# root Object: key, value are notset, child is defined\n# non-root Object: key, value are set, child is notset for last node\nmutable struct Object{K,V} <: AbstractDict{K,V}\n    key::Union{NotSet, K} # for root object, key/value are notset\n    value::Union{NotSet, V}\n    child::Union{NotSet, Object{K,V}} # possibly notset\n\n    # root constructor: key is const notset\n    function Object{K,V}() where {K,V}\n        x = new{K,V}(notset, notset, notset)\n        return x\n    end\n\n    # all non-root Objects *must* be set as the child of another Object\n    # WARNING: this constructor can allow duplicate `k` in a root Object as no check is done\n    function Object{K,V}(obj::Object{K,V}, k, v) where {K,V}\n        @assert _ch(obj) === notset \"Object child already defined\"\n        nobj = new{K,V}(k, v, notset)\n        setfield!(obj, :child, nobj)\n        return nobj\n    end\nend\n\nObject() = Object{Any, Any}() # default empty object\n\n_k(obj::Object) = getfield(obj, :key)\n_v(obj::Object) = getfield(obj, :value)\n_ch(obj::Object) = getfield(obj, :child)\n\nObject(d::AbstractDict{K,V}) where {K,V} = Object{K,V}(d)\n\nfunction Object{K,V}(d::AbstractDict{K,V}) where {K,V}\n    root = obj = Object{K,V}()\n    for (k, v) in d\n        obj = Object{K,V}(obj, k, v)\n    end\n    return root\nend\n\nObject(pairs::Pair{K,V}...) where {K,V} = Object{K,V}(pairs...)\nObject(pairs::Pair...) = Object{Any,Any}(pairs...)\n\nfunction Object{K,V}(pairs::Pair...) where {K,V}\n    root = obj = Object{K,V}()\n    for (k, v) in pairs\n        obj = Object{K,V}(obj, k, v)\n    end\n    return root\nend\n\n# generic iterator constructors\nfunction Object(itr)\n    root = obj = nothing\n    st = iterate(itr)\n    while st !== nothing\n        kv, state = st\n        if kv isa Pair || kv isa Tuple{Any,Any}\n            k, v = kv\n            if root === nothing\n                root = Object{typeof(k), typeof(v)}()\n                obj = root\n            end\n            obj = Object{typeof(k), typeof(v)}(obj, k, v)\n        else\n            throw(ArgumentError(\"Iterator must yield Pair or 2-tuple, got $(typeof(kv))\"))\n        end\n        st = iterate(itr, state)\n    end\n    return root === nothing ? Object{Any,Any}() : root\nend\n\nfunction Object{K,V}(itr) where {K,V}\n    root = obj = Object{K,V}()\n    st = iterate(itr)\n    while st !== nothing\n        kv, state = st\n        if kv isa Pair || kv isa Tuple{Any,Any}\n            k, v = kv\n            obj = Object{K, V}(obj, k, v)\n        else\n            throw(ArgumentError(\"Iterator must yield Pair or 2-tuple, got $(typeof(kv))\"))\n        end\n        st = iterate(itr, state)\n    end\n    return root\nend\n\nfunction Base.iterate(orig::Object{K,V}, obj=orig) where {K,V}\n    obj === nothing && return nothing\n    if _k(obj) === notset\n        # if key is notset, we either have to iterate from the child or we're done\n        return _ch(obj) === notset ? nothing : iterate(_ch(obj)::Object{K,V})\n    end\n    return (Pair{K,V}(_k(obj)::K, _v(obj)::V), _ch(obj) === notset ? nothing : _ch(obj)::Object{K,V})\nend\n\nfunction Base.length(obj::Object{K,V}) where {K,V}\n    count = 0\n    while true\n        _k(obj) !== notset && (count += 1)\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    return count\nend\nBase.isempty(obj::Object) = _k(obj) === notset && _ch(obj) === notset\nBase.empty(::Object{K,V}) where {K,V} = Object{K,V}() # empty object\n\n# linear node lookup\n@inline function find_node_by_key(obj::Object{K,V}, key::K) where {K,V}\n    while true\n        _k(obj) !== notset && isequal(_k(obj)::K, key) && return obj\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    return nothing\nend\n\n# get with fallback callable\nfunction Base.get(f::Base.Callable, obj::Object{K,V}, key) where {K,V}\n    node = find_node_by_key(obj, key)\n    node !== nothing && return _v(node)::V\n    return f()\nend\n\nBase.getindex(obj::Object, key) = get(() -> throw(KeyError(key)), obj, key)\nBase.getindex(obj::Object{String}, key::Symbol) = get(() -> throw(KeyError(key)), obj, String(key))\nBase.getindex(obj::Object{Symbol}, key::String) = get(() -> throw(KeyError(key)), obj, Symbol(key))\nBase.get(obj::Object, key, default) = get(() -> default, obj, key)\n\n# support getproperty for dot access\nBase.getproperty(obj::Object{Symbol}, sym::Symbol) = getindex(obj, sym)\nBase.getproperty(obj::Object{String}, sym::Symbol) = getindex(obj, String(sym))\nBase.propertynames(obj::Object{K,V}) where {K,V} = _k(obj) === notset && _ch(obj) === notset ? () : _propertynames(_ch(obj)::Object{K,V}, ())\n\nfunction _propertynames(obj::Object{K,V}, acc) where {K,V}\n    new = (acc..., Symbol(_k(obj)::K))\n    return _ch(obj) === notset ? new : _propertynames(_ch(obj)::Object{K,V}, new)\nend\n\n# haskey\nBase.haskey(obj::Object, key) = find_node_by_key(obj, key) !== nothing\nBase.haskey(obj::Object{String}, key::Symbol) = haskey(obj, String(key))\n\n# setindex! finds node with key and sets value or inserts a new node\nfunction Base.setindex!(obj::Object{K,V}, value, key::K) where {K,V}\n    root = obj\n    while true\n        if _k(obj) !== notset && isequal(_k(obj)::K, key)\n            setfield!(obj, :value, convert(V, value))\n            return root\n        end\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    # if we reach here, we need to insert a new node\n    Object{K,V}(obj, key, value)\n    return value\nend\n\n# delete! removes node\nfunction Base.delete!(obj::Object{K,V}, key::K) where {K,V}\n    # check empty case\n    _ch(obj) === notset && return obj\n    root = parent = obj\n    obj = _ch(obj)::Object{K,V}\n    while true\n        if _k(obj) !== notset && isequal(_k(obj)::K, key)\n            # we found the node to remove\n            # if node is leaf, we need to set parent as leaf\n            # otherwise, we set child as child of parent\n            if _ch(obj) === notset\n                setfield!(parent, :child, notset)\n            else\n                setfield!(parent, :child, _ch(obj)::Object{K,V})\n            end\n        end\n        _ch(obj) === notset && break\n        parent = obj\n        obj = _ch(obj)::Object{K,V}\n    end\n    return root\nend\n\nfunction Base.empty!(obj::Object)\n    setfield!(obj, :child, notset)\n    return obj\nend\n\n# support setproperty for dot access\nBase.setproperty!(obj::Object, sym::Symbol, val) = setindex!(obj, val, sym)\nBase.setproperty!(obj::Object{String}, sym::Symbol, val) = setindex!(obj, val, String(sym))\n\nBase.merge(a::NamedTuple, b::Object{String,Any}) = merge(a, (Symbol(k) => v for (k, v) in b))"}, "files_after": {"src/object.jl": "struct NotSet end\nconst notset = NotSet()\n\n\"\"\"\n    JSON.Object{K,V}\n\nA mutable `AbstractDict` type for JSON objects. Internally is a linked list of key-value pairs, where each pair is represented by an `Object` instance. The first instance is the root object.\nThe `Object` type is used to represent JSON objects in a mutable way, allowing for efficient insertion and deletion of key-value pairs. It is designed to be used with the `JSON` package for parsing and deserializing JSON data.\n\nBecause of the linked-list representation, key lookups are O(n), using a simple linear scan.\nFor small objects, this is very efficient, and worth the memory overhead vs. a full `Dict` or `OrderedDict`.\nFor Objects with many entries (hundreds or thousands), this is not as efficient. In that case, consider using a `Dict` or `OrderedDict` instead.\n\"\"\"\n# empty Object: key, value, child all notset\n# root Object: key, value are notset, child is defined\n# non-root Object: key, value are set, child is notset for last node\nmutable struct Object{K,V} <: AbstractDict{K,V}\n    key::Union{NotSet, K} # for root object, key/value are notset\n    value::Union{NotSet, V}\n    child::Union{NotSet, Object{K,V}} # possibly notset\n\n    # root constructor: key is const notset\n    function Object{K,V}() where {K,V}\n        x = new{K,V}(notset, notset, notset)\n        return x\n    end\n\n    # all non-root Objects *must* be set as the child of another Object\n    # WARNING: this constructor can allow duplicate `k` in a root Object as no check is done\n    function Object{K,V}(obj::Object{K,V}, k, v) where {K,V}\n        @assert _ch(obj) === notset \"Object child already defined\"\n        nobj = new{K,V}(k, v, notset)\n        setfield!(obj, :child, nobj)\n        return nobj\n    end\nend\n\nObject() = Object{Any, Any}() # default empty object\n\n_k(obj::Object) = getfield(obj, :key)\n_v(obj::Object) = getfield(obj, :value)\n_ch(obj::Object) = getfield(obj, :child)\n\nObject(d::AbstractDict{K,V}) where {K,V} = Object{K,V}(d)\n\nfunction Object{K,V}(d::AbstractDict{K,V}) where {K,V}\n    root = obj = Object{K,V}()\n    for (k, v) in d\n        obj = Object{K,V}(obj, k, v)\n    end\n    return root\nend\n\nObject(pairs::Pair{K,V}...) where {K,V} = Object{K,V}(pairs...)\nObject(pairs::Pair...) = Object{Any,Any}(pairs...)\n\nfunction Object{K,V}(pairs::Pair...) where {K,V}\n    root = obj = Object{K,V}()\n    for (k, v) in pairs\n        obj = Object{K,V}(obj, k, v)\n    end\n    return root\nend\n\n# generic iterator constructors\nfunction Object(itr)\n    root = obj = nothing\n    st = iterate(itr)\n    while st !== nothing\n        kv, state = st\n        if kv isa Pair || kv isa Tuple{Any,Any}\n            k, v = kv\n            if root === nothing\n                root = Object{typeof(k), typeof(v)}()\n                obj = root\n            end\n            obj = Object{typeof(k), typeof(v)}(obj, k, v)\n        else\n            throw(ArgumentError(\"Iterator must yield Pair or 2-tuple, got $(typeof(kv))\"))\n        end\n        st = iterate(itr, state)\n    end\n    return root === nothing ? Object{Any,Any}() : root\nend\n\nfunction Object{K,V}(itr) where {K,V}\n    root = obj = Object{K,V}()\n    st = iterate(itr)\n    while st !== nothing\n        kv, state = st\n        if kv isa Pair || kv isa Tuple{Any,Any}\n            k, v = kv\n            obj = Object{K, V}(obj, k, v)\n        else\n            throw(ArgumentError(\"Iterator must yield Pair or 2-tuple, got $(typeof(kv))\"))\n        end\n        st = iterate(itr, state)\n    end\n    return root\nend\n\nfunction Base.iterate(orig::Object{K,V}, obj=orig) where {K,V}\n    obj === nothing && return nothing\n    if _k(obj) === notset\n        # if key is notset, we either have to iterate from the child or we're done\n        return _ch(obj) === notset ? nothing : iterate(_ch(obj)::Object{K,V})\n    end\n    return (Pair{K,V}(_k(obj)::K, _v(obj)::V), _ch(obj) === notset ? nothing : _ch(obj)::Object{K,V})\nend\n\nfunction Base.length(obj::Object{K,V}) where {K,V}\n    count = 0\n    while true\n        _k(obj) !== notset && (count += 1)\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    return count\nend\nBase.isempty(obj::Object) = _k(obj) === notset && _ch(obj) === notset\nBase.empty(::Object{K,V}) where {K,V} = Object{K,V}() # empty object\n\n# linear node lookup\n@inline function find_node_by_key(obj::Object{K,V}, key::K) where {K,V}\n    while true\n        _k(obj) !== notset && isequal(_k(obj)::K, key) && return obj\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    return nothing\nend\n\n# get with fallback callable\nfunction Base.get(f::Base.Callable, obj::Object{K,V}, key) where {K,V}\n    node = find_node_by_key(obj, key)\n    node !== nothing && return _v(node)::V\n    return f()\nend\n\nBase.getindex(obj::Object, key) = get(() -> throw(KeyError(key)), obj, key)\nBase.getindex(obj::Object{String}, key::Symbol) = get(() -> throw(KeyError(key)), obj, String(key))\nBase.getindex(obj::Object{Symbol}, key::String) = get(() -> throw(KeyError(key)), obj, Symbol(key))\nBase.setindex!(obj::Object{String}, value, key::Symbol) = setindex!(obj, value, String(key))\nBase.setindex!(obj::Object{Symbol}, value, key::String) = setindex!(obj, value, Symbol(key))\nBase.delete!(obj::Object{String}, key::Symbol) = delete!(obj, String(key))\nBase.delete!(obj::Object{Symbol}, key::String) = delete!(obj, Symbol(key))\nBase.get(obj::Object, key, default) = get(() -> default, obj, key)\n\n# support getproperty for dot access\nBase.getproperty(obj::Object{Symbol}, sym::Symbol) = getindex(obj, sym)\nBase.getproperty(obj::Object{String}, sym::Symbol) = getindex(obj, String(sym))\nBase.propertynames(obj::Object{K,V}) where {K,V} = _k(obj) === notset && _ch(obj) === notset ? () : _propertynames(_ch(obj)::Object{K,V}, ())\n\nfunction _propertynames(obj::Object{K,V}, acc) where {K,V}\n    new = (acc..., Symbol(_k(obj)::K))\n    return _ch(obj) === notset ? new : _propertynames(_ch(obj)::Object{K,V}, new)\nend\n\n# haskey\nBase.haskey(obj::Object, key) = find_node_by_key(obj, key) !== nothing\nBase.haskey(obj::Object{String}, key::Symbol) = haskey(obj, String(key))\nBase.haskey(obj::Object{Symbol}, key::String) = haskey(obj, Symbol(key))\n\n# setindex! finds node with key and sets value or inserts a new node\nfunction Base.setindex!(obj::Object{K,V}, value, key::K) where {K,V}\n    root = obj\n    while true\n        if _k(obj) !== notset && isequal(_k(obj)::K, key)\n            setfield!(obj, :value, convert(V, value))\n            return root\n        end\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    # if we reach here, we need to insert a new node\n    Object{K,V}(obj, key, value)\n    return value\nend\n\n# delete! removes node\nfunction Base.delete!(obj::Object{K,V}, key::K) where {K,V}\n    # check empty case\n    _ch(obj) === notset && return obj\n    root = parent = obj\n    obj = _ch(obj)::Object{K,V}\n    while true\n        if _k(obj) !== notset && isequal(_k(obj)::K, key)\n            # we found the node to remove\n            # if node is leaf, we need to set parent as leaf\n            # otherwise, we set child as child of parent\n            if _ch(obj) === notset\n                setfield!(parent, :child, notset)\n            else\n                setfield!(parent, :child, _ch(obj)::Object{K,V})\n            end\n        end\n        _ch(obj) === notset && break\n        parent = obj\n        obj = _ch(obj)::Object{K,V}\n    end\n    return root\nend\n\nfunction Base.empty!(obj::Object)\n    setfield!(obj, :child, notset)\n    return obj\nend\n\n# support setproperty for dot access\nBase.setproperty!(obj::Object, sym::Symbol, val) = setindex!(obj, val, sym)\nBase.setproperty!(obj::Object{String}, sym::Symbol, val) = setindex!(obj, val, String(sym))\n\nBase.merge(a::NamedTuple, b::Object{String,Any}) = merge(a, (Symbol(k) => v for (k, v) in b))"}, "source_files_changed": ["src/object.jl"], "test_files_changed": ["test/object.jl"], "lines_changed": 56, "is_valid": true, "validation_errors": []}
{"repo": "JSON.jl", "commit_sha": "81fa0713962950107e6eb2de95583ee291d3558a", "parent_sha": "928a3cc5b3433657a828b3b86c70aa569c668051", "commit_message": "add liftkey for numeric dict key types (#423)", "commit_date": "2026-01-12T16:29:33-07:00", "action": {"type": "ADD_METHOD", "target_file": "src/parse.jl", "target_symbol": "StructUtils.liftkey", "signature": null, "confidence": 0.85}, "files_before": {"src/parse.jl": "\"\"\"\n    JSON.parse(json)\n    JSON.parse(json, T)\n    JSON.parse!(json, x)\n    JSON.parsefile(filename)\n    JSON.parsefile(filename, T)\n    JSON.parsefile!(filename, x)\n\nParse a JSON input (string, vector, stream, LazyValue, etc.) into a Julia value. The `parsefile` variants\ntake a filename, open the file, and pass the `IOStream` to `parse`.\n\nCurrently supported keyword arguments include:\n  * `allownan`: allows parsing `NaN`, `Inf`, and `-Inf` since they are otherwise invalid JSON\n  * `ninf`: string to use for `-Inf` (default: `\"-Infinity\"`)\n  * `inf`: string to use for `Inf` (default: `\"Infinity\"`)\n  * `nan`: string to use for `NaN` (default: `\"NaN\"`)\n  * `jsonlines`: treat the `json` input as an implicit JSON array, delimited by newlines, each element being parsed from each row/line in the input\n  * `dicttype`: a custom `AbstractDict` type to use instead of `$DEFAULT_OBJECT_TYPE` as the default type for JSON object materialization\n  * `null`: a custom value to use for JSON null values (default: `nothing`)\n  * `style`: a custom `StructUtils.StructStyle` subtype instance to be used in calls to `StructUtils.make` and `StructUtils.lift`. This allows overriding\n    default behaviors for non-owned types.\n\nThe methods without a type specified (`JSON.parse(json)`, `JSON.parsefile(filename)`), do a generic materialization into\npredefined default types, including:\n  * JSON object => `$DEFAULT_OBJECT_TYPE` (**see note below**)\n  * JSON array => `Vector{Any}`\n  * JSON string => `String`\n  * JSON number => `Int64`, `BigInt`, `Float64`, or `BigFloat`\n  * JSON true => `true`\n  * JSON false => `false`\n  * JSON null => `nothing`\n\nWhen a type `T` is specified (`JSON.parse(json, T)`, `JSON.parsefile(filename, T)`), materialization to a value\nof type `T` will be attempted utilizing machinery and interfaces provided by the StructUtils.jl package, including:\n  * For JSON objects, JSON keys will be matched against field names of `T` with a value being constructed via `T(args...)`\n  * If `T` was defined with the `@noarg` macro, an empty instance will be constructed, and field values set as JSON keys match field names\n  * If `T` had default field values defined using the `@defaults` or `@kwarg` macros (from StructUtils.jl package), those will be set in the value of `T` unless different values are parsed from the JSON\n  * If `T` was defined with the `@nonstruct` macro, the struct will be treated as a primitive type and constructed using the `lift` function rather than from field values\n  * JSON keys that don't match field names in `T` will be ignored (skipped over)\n  * If a field in `T` has a `name` fieldtag, the `name` value will be used to match JSON keys instead\n  * If `T` or any recursive field type of `T` is abstract, an appropriate `JSON.@choosetype T x -> ...` definition should exist for \"choosing\" a concrete type at runtime; default type choosing exists for `Union{T, Missing}` and `Union{T, Nothing}` where the JSON value is checked if `null`. If the `Any` type is encountered, the default materialization types will be used (`JSON.Object`, `Vector{Any}`, etc.)\n  * For any non-JSON-standard non-aggregate (i.e. non-object, non-array) field type of `T`, a `JSON.lift(::Type{T}, x) = ...` definition can be defined for how to \"lift\" the default JSON value (String, Number, Bool, `nothing`) to the type `T`; a default lift definition exists, for example, for `JSON.lift(::Type{Missing}, x) = missing` where the standard JSON value for `null` is `nothing` and it can be \"lifted\" to `missing`\n  * For any `T` or recursive field type of `T` that is `AbstractDict`, non-string/symbol/integer keys will need to have a `StructUtils.liftkey(::Type{T}, x))` definition for how to \"lift\" the JSON string key to the key type of `T`\n\nFor any `T` or recursive field type of `T` that is `JSON.JSONText`, the next full raw JSON value will be preserved in the `JSONText` wrapper as-is.\n\nFor the unique case of nested JSON arrays and prior knowledge of the expected dimensionality,\na target type `T` can be given as an `AbstractArray{T, N}` subtype. In this case, the JSON array data is materialized as an\nn-dimensional array, where: the number of JSON array nestings must match the Julia array dimensionality (`N`),\nnested JSON arrays at matching depths are assumed to have equal lengths, and the length of\nthe innermost JSON array is the 1st dimension length and so on. For example, the JSON array `[[[1.0,2.0]]]`\nwould be materialized as a 3-dimensional array of `Float64` with sizes `(2, 1, 1)`, when called\nlike `JSON.parse(\"[[[1.0,2.0]]]\", Array{Float64, 3})`. Note that n-dimensional Julia\narrays are written to json as nested JSON arrays by default, to enable lossless re-parsing,\nthough the dimensionality must still be provided explicitly to the call to `parse` (i.e. default parsing via `JSON.parse(json)`\nwill result in plain nested `Vector{Any}`s returned).\n\nExamples:\n```julia\nusing Dates\n\nabstract type AbstractMonster end\n\nstruct Dracula <: AbstractMonster\n    num_victims::Int\nend\n\nstruct Werewolf <: AbstractMonster\n    witching_hour::DateTime\nend\n\nJSON.@choosetype AbstractMonster x -> x.monster_type[] == \"vampire\" ? Dracula : Werewolf\n\nstruct Percent <: Number\n    value::Float64\nend\n\nJSON.lift(::Type{Percent}, x) = Percent(Float64(x))\nStructUtils.liftkey(::Type{Percent}, x::String) = Percent(parse(Float64, x))\n\n@defaults struct FrankenStruct\n    id::Int = 0\n    name::String = \"Jim\"\n    address::Union{Nothing, String} = nothing\n    rate::Union{Missing, Float64} = missing\n    type::Symbol = :a &(json=(name=\"franken_type\",),)\n    notsure::Any = nothing\n    monster::AbstractMonster = Dracula(0)\n    percent::Percent = Percent(0.0)\n    birthdate::Date = Date(0) &(json=(dateformat=\"yyyy/mm/dd\",),)\n    percentages::Dict{Percent, Int} = Dict{Percent, Int}()\n    json_properties::JSONText = JSONText(\"\")\n    matrix::Matrix{Float64} = Matrix{Float64}(undef, 0, 0)\nend\n\njson = \\\"\\\"\\\"\n{\n    \"id\": 1,\n    \"address\": \"123 Main St\",\n    \"rate\": null,\n    \"franken_type\": \"b\",\n    \"notsure\": {\"key\": \"value\"},\n    \"monster\": {\n        \"monster_type\": \"vampire\",\n        \"num_victims\": 10\n    },\n    \"percent\": 0.1,\n    \"birthdate\": \"2023/10/01\",\n    \"percentages\": {\n        \"0.1\": 1,\n        \"0.2\": 2\n    },\n    \"json_properties\": {\"key\": \"value\"},\n    \"matrix\": [[1.0, 2.0], [3.0, 4.0]],\n    \"extra_key\": \"extra_value\"\n}\n\\\"\\\"\\\"\nJSON.parse(json, FrankenStruct)\n# FrankenStruct(1, \"Jim\", \"123 Main St\", missing, :b, JSON.Object{String, Any}(\"key\" => \"value\"), Dracula(10), Percent(0.1), Date(\"2023-10-01\"), Dict{Percent, Int64}(Percent(0.2) => 2, Percent(0.1) => 1), JSONText(\"{\\\"key\\\": \\\"value\\\"}\"), [1.0 3.0; 2.0 4.0])\n```\n\nLet's walk through some notable features of the example above:\n  * The `name` field isn't present in the JSON input, so the default value of `\"Jim\"` is used.\n  * The `address` field uses a default `@choosetype` to determine that the JSON value is not `null`, so a `String` should be parsed for the field value.\n  * The `rate` field has a `null` JSON value, so the default `@choosetype` recognizes it should be \"lifted\" to `Missing`, which then uses a predefined `lift` definition for `Missing`.\n  * The `type` field is a `Symbol`, and has a fieldtag `json=(name=\"franken_type\",)` which means the JSON key `franken_type` will be used to set the field value instead of the default `type` field name. A default `lift` definition for `Symbol` is used to convert the JSON string value to a `Symbol`.\n  * The `notsure` field is of type `Any`, so the default object type `JSON.Object{String, Any}` is used to materialize the JSON value.\n  * The `monster` field is a polymorphic type, and the JSON value has a `monster_type` key that determines which concrete type to use. The `@choosetype` macro is used to define the logic for choosing the concrete type based on the JSON input. Note that teh `x` in `@choosetype` is a `LazyValue`, so we materialize via `x.monster_type[]` in order to compare with the string `\"vampire\"`.\n  * The `percent` field is a custom type `Percent` and the `JSON.lift` defines how to construct a `Percent` from the JSON value, which is a `Float64` in this case.\n  * The `birthdate` field uses a custom date format for parsing, specified in the JSON input.\n  * The `percentages` field is a dictionary with keys of type `Percent`, which is a custom type. The `liftkey` function is defined to convert the JSON string keys to `Percent` types (parses the Float64 manually)\n  * The `json_properties` field has a type of `JSONText`, which means the raw JSON will be preserved as a String of the `JSONText` type.\n  * The `matrix` field is a `Matrix{Float64}`, so the JSON input array-of-arrays are materialized as such.\n  * The `extra_key` field is not defined in the `FrankenStruct` type, so it is ignored and skipped over.\n\nNOTE:\nWhy use `JSON.Object{String, Any}` as the default object type? It provides several benefits:\n  * Behaves as a drop-in replacement for `Dict{String, Any}`, so no loss of functionality\n  * Performance! It's internal representation means memory savings and faster construction for small objects typical in JSON (vs `Dict`)\n  * Insertion order is preserved, so the order of keys in the JSON input is preserved in `JSON.Object`\n  * Convenient `getproperty` (i.e. `obj.key`) syntax is supported, even for `Object{String,Any}` key types (again ideal/specialized for JSON usage)\n\n`JSON.Object` internal representation uses a linked list, thus key lookups are linear time (O(n)). For *large* JSON objects,\n(hundreds or thousands of keys), consider using a `Dict{String, Any}` instead, like `JSON.parse(json; dicttype=Dict{String, Any})`.\n\"\"\"\nfunction parse end\n\nimport StructUtils: StructStyle\n\nabstract type JSONStyle <: StructStyle end\n\n# defining a custom style allows us to pass a non-default dicttype `O` through JSON.parse\nstruct JSONReadStyle{O,T} <: JSONStyle\n    null::T\nend\n\nJSONReadStyle{O}(null::T) where {O,T} = JSONReadStyle{O,T}(null)\n\nobjecttype(::StructStyle) = DEFAULT_OBJECT_TYPE\nobjecttype(::JSONReadStyle{OT}) where {OT} = OT\nnullvalue(::StructStyle) = nothing\nnullvalue(st::JSONReadStyle) = st.null\n\n# this allows struct fields to specify tags under the json key specifically to override JSON behavior\nStructUtils.fieldtagkey(::JSONStyle) = :json\n\nfunction parsefile end\n@doc (@doc parse) parsefile\n\nfunction parsefile! end\n@doc (@doc parse) parsefile!\n\nparsefile(file; jsonlines::Union{Bool,Nothing}=nothing, kw...) = open(io -> parse(io; jsonlines=(jsonlines === nothing ? isjsonl(file) : jsonlines), kw...), file)\nparsefile(file, ::Type{T}; jsonlines::Union{Bool,Nothing}=nothing, kw...) where {T} = open(io -> parse(io, T; jsonlines=(jsonlines === nothing ? isjsonl(file) : jsonlines), kw...), file)\nparsefile!(file, x::T; jsonlines::Union{Bool,Nothing}=nothing, kw...) where {T} = open(io -> parse!(io, x; jsonlines=(jsonlines === nothing ? isjsonl(file) : jsonlines), kw...), file)\n\nparse(io::Union{IO,Base.AbstractCmd}, ::Type{T}=Any; kw...) where {T} = parse(Base.read(io), T; kw...)\n\nparse!(io::Union{IO,Base.AbstractCmd}, x::T; kw...) where {T} = parse!(Base.read(io), x; kw...)\n\nparse(buf::Union{AbstractVector{UInt8},AbstractString}, ::Type{T}=Any;\n    dicttype::Type{O}=DEFAULT_OBJECT_TYPE, null=nothing,\n    style::StructStyle=JSONReadStyle{dicttype}(null), kw...) where {T,O} =\n    @inline parse(lazy(buf; kw...), T; dicttype, null, style)\n\nparse!(buf::Union{AbstractVector{UInt8},AbstractString}, x::T; dicttype::Type{O}=DEFAULT_OBJECT_TYPE, null=nothing, style::StructStyle=JSONReadStyle{dicttype}(null), kw...) where {T,O} =\n    @inline parse!(lazy(buf; kw...), x; dicttype, null, style)\n\nparse(x::LazyValue, ::Type{T}=Any; dicttype::Type{O}=DEFAULT_OBJECT_TYPE, null=nothing, style::StructStyle=JSONReadStyle{dicttype}(null)) where {T,O} =\n    @inline _parse(x, T, dicttype, null, style)\n\nfunction _parse(x::LazyValue, ::Type{T}, dicttype::Type{O}, null, style::StructStyle) where {T,O}\n    y, pos = StructUtils.make(style, T, x)\n    getisroot(x) && checkendpos(x, T, pos)\n    return y\nend\n\nmutable struct ValueClosure\n    value::Any\n    ValueClosure() = new()\nend\n\n(f::ValueClosure)(v) = setfield!(f, :value, v)\n\nfunction _parse(x::LazyValue, ::Type{Any}, ::Type{DEFAULT_OBJECT_TYPE}, null, ::StructStyle)\n    out = ValueClosure()\n    pos = applyvalue(out, x, null)\n    getisroot(x) && checkendpos(x, Any, pos)\n    return out.value\nend\n\nparse!(x::LazyValue, obj::T; dicttype::Type{O}=DEFAULT_OBJECT_TYPE, null=nothing, style::StructStyle=JSONReadStyle{dicttype}(null)) where {T,O} = StructUtils.make!(style, obj, x)\n\n# for LazyValue, if x started at the beginning of the JSON input,\n# then we want to ensure that the entire input was consumed\n# and error if there are any trailing invalid JSON characters\nfunction checkendpos(x::LazyValue, ::Type{T}, pos::Int) where {T}\n    buf = getbuf(x)\n    len = getlength(buf)\n    if pos <= len\n        b = getbyte(buf, pos)\n        while b == UInt8('\\t') || b == UInt8(' ') || b == UInt8('\\n') || b == UInt8('\\r')\n            pos += 1\n            pos > len && break\n            b = getbyte(buf, pos)\n        end\n    end\n    if (pos - 1) != len\n        invalid(InvalidChar, buf, pos, T)\n    end\n    return nothing\nend\n\n# specialized closure to optimize Object{String, Any} insertions\n# to avoid doing a linear scan on each insertion, we use a Set\n# to track keys seen so far. In the common case of non-duplicated key,\n# we can insert the new key-val pair directly after the latest leaf node\nmutable struct ObjectClosure{T}\n    root::Object{String,Any}\n    obj::Object{String,Any}\n    keys::Set{String}\n    null::T\nend\n\nObjectClosure(obj, null) = ObjectClosure(obj, obj, sizehint!(Set{String}(), 16), null)\n\n@inline function insert_or_overwrite!(oc::ObjectClosure, key, val)\n    # in! does both a hash lookup and also sets the key if not present\n    if _in!(key, oc.keys)\n        # slow path for dups; does a linear scan from our root object\n        setindex!(oc.root, val, key)\n        return\n    end\n    # this uses an \"unsafe\" constructor that returns the new leaf node\n    # and sets the child of the previous node to the new node\n    oc.obj = Object{String,Any}(oc.obj, key, val) # fast append path\nend\n\n(oc::ObjectClosure)(k, v) = applyvalue(val -> insert_or_overwrite!(oc, convert(String, k), val), v, oc.null)\n\n# generic apply `f` to LazyValue, using default types to materialize, depending on type\nfunction applyvalue(f, x::LazyValues, null)\n    type = gettype(x)\n    if type == JSONTypes.OBJECT\n        obj = Object{String,Any}()\n        pos = applyobject(ObjectClosure(obj, null), x)\n        f(obj)\n        return pos\n    elseif type == JSONTypes.ARRAY\n        # basically free to allocate 16 instead of Julia-default 8 and avoids\n        # a reallocation in many cases\n        arr = Vector{Any}(undef, 16)\n        resize!(arr, 0)\n        pos = applyarray(x) do _, v\n            applyvalue(val -> push!(arr, val), v, null)\n        end\n        f(arr)\n        return pos\n    elseif type == JSONTypes.STRING\n        buf = getbuf(x)\n        GC.@preserve buf begin\n            str, pos = parsestring(x)\n            f(convert(String, str))\n        end\n        return pos\n    elseif type == JSONTypes.NUMBER\n        num, pos = parsenumber(x)\n        if isint(num)\n            f(num.int)\n        elseif isfloat(num)\n            f(num.float)\n        elseif isbigint(num)\n            f(num.bigint)\n        else\n            f(num.bigfloat)\n        end\n        return pos\n    elseif type == JSONTypes.NULL\n        f(null)\n        return getpos(x) + 4\n    elseif type == JSONTypes.TRUE\n        f(true)\n        return getpos(x) + 4\n    elseif type == JSONTypes.FALSE\n        f(false)\n        return getpos(x) + 5\n    else\n        throw(ArgumentError(\"cannot parse json\"))\n    end\nend\n\n# we overload make! for Any for LazyValues because we can dispatch to more specific\n# types base on the LazyValue type\nfunction StructUtils.make(st::StructStyle, ::Type{Any}, x::LazyValues)\n    type = gettype(x)\n    if type == JSONTypes.OBJECT\n        return StructUtils.make(st, objecttype(st), x)\n    elseif type == JSONTypes.ARRAY\n        return StructUtils.make(st, Vector{Any}, x)\n    elseif type == JSONTypes.STRING\n        return StructUtils.lift(st, String, x)\n    elseif type == JSONTypes.NUMBER\n        return StructUtils.lift(st, Number, x)\n    elseif type == JSONTypes.NULL\n        return StructUtils.lift(st, Nothing, x)\n    elseif type == JSONTypes.TRUE || type == JSONTypes.FALSE\n        return StructUtils.lift(st, Bool, x)\n    else\n        throw(ArgumentError(\"cannot parse $x\"))\n    end\nend\n\n# catch PtrString via lift or make! so we can ensure it never \"escapes\" to user-level\nStructUtils.liftkey(st::StructStyle, ::Type{T}, x::PtrString) where {T} =\n    StructUtils.liftkey(st, T, convert(String, x))\nStructUtils.lift(st::StructStyle, ::Type{T}, x::PtrString, tags) where {T} =\n    StructUtils.lift(st, T, convert(String, x), tags)\nStructUtils.lift(st::StructStyle, ::Type{T}, x::PtrString) where {T} =\n    StructUtils.lift(st, T, convert(String, x))\n\nfunction StructUtils.lift(style::StructStyle, ::Type{T}, x::LazyValues) where {T<:AbstractArray{E,0}} where {E}\n    m = T(undef)\n    m[1], pos = StructUtils.lift(style, E, x)\n    return m, pos\nend\n\nfunction StructUtils.lift(style::StructStyle, ::Type{T}, x::LazyValues, tags=(;)) where {T}\n    type = gettype(x)\n    buf = getbuf(x)\n    if type == JSONTypes.STRING\n        GC.@preserve buf begin\n            ptrstr, pos = parsestring(x)\n            str, _ = StructUtils.lift(style, T, ptrstr, tags)\n        end\n        return str, pos\n    elseif type == JSONTypes.NUMBER\n        num, pos = parsenumber(x)\n        if isint(num)\n            T === Int64 && return num.int, pos\n            int, _ = StructUtils.lift(style, T, num.int, tags)\n            return int, pos\n        elseif isfloat(num)\n            T === Float64 && return num.float, pos\n            float, _ = StructUtils.lift(style, T, num.float, tags)\n            return float, pos\n        elseif isbigint(num)\n            T === BigInt && return num.bigint, pos\n            bigint, _ = StructUtils.lift(style, T, num.bigint, tags)\n            return bigint, pos\n        else\n            T === BigFloat && return num.bigfloat, pos\n            bigfloat, _ = StructUtils.lift(style, T, num.bigfloat, tags)\n            return bigfloat, pos\n        end\n    elseif type == JSONTypes.NULL\n        null, _ = StructUtils.lift(style, T, nullvalue(style), tags)\n        return null, getpos(x) + 4\n    elseif type == JSONTypes.TRUE\n        tr, _ = StructUtils.lift(style, T, true, tags)\n        return tr, getpos(x) + 4\n    elseif type == JSONTypes.FALSE\n        fl, _ = StructUtils.lift(style, T, false, tags)\n        return fl, getpos(x) + 5\n    elseif Base.issingletontype(T)\n        sglt, _ = StructUtils.lift(style, T, T(), tags)\n        return sglt, skip(x)\n    else\n        out = ValueClosure()\n        pos = applyvalue(out, x, nothing)\n        val1 = out.value\n        # big switch here for --trim verify-ability\n        if val1 isa Object{String,Any}\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa Vector{Any}\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa String\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa Int64\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa Float64\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa BigInt\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa BigFloat\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa Bool\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa Nothing\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        else\n            throw(ArgumentError(\"cannot parse json\"))\n        end\n    end\nend\n\nfunction StructUtils.make(::StructStyle, ::Type{JSONText}, x::LazyValues)\n    buf = getbuf(x)\n    pos = getpos(x)\n    endpos = skip(x)\n    val = GC.@preserve buf JSONText(unsafe_string(pointer(buf, pos), endpos - pos))\n    return val, endpos\nend\n\n@generated function StructUtils.maketuple(st::StructStyle, ::Type{T}, x::LazyValues) where {T<:Tuple}\n    N = fieldcount(T)\n    ex = quote\n        pos::Int = getpos(x)\n        buf = getbuf(x)\n        len = getlength(buf)\n        opts = getopts(x)\n        b = getbyte(buf, pos)\n        typ = gettype(x)\n        if typ == JSONTypes.OBJECT && b != UInt8('{')\n            error = ExpectedOpeningObjectChar\n            @goto invalid\n        elseif typ == JSONTypes.ARRAY && b != UInt8('[')\n            error = ExpectedOpeningArrayChar\n            @goto invalid\n        elseif typ != JSONTypes.OBJECT && typ != JSONTypes.ARRAY\n            error = InvalidJSON\n            @goto invalid\n        end\n        pos += 1\n        @nextbyte\n        Base.@nexprs $N i -> begin\n            if typ == JSONTypes.OBJECT\n                # consume key\n                GC.@preserve buf begin\n                    _, pos = @inline parsestring(LazyValue(buf, pos, JSONTypes.STRING, opts, false))\n                end\n                @nextbyte\n                if b != UInt8(':')\n                    error = ExpectedColon\n                    @goto invalid\n                end\n                pos += 1\n                @nextbyte\n            end\n            x = _lazy(buf, pos, len, b, opts)\n            j_{i}, pos = StructUtils.make(st, fieldtype(T, i), x)\n            @nextbyte\n            if typ == JSONTypes.OBJECT && b == UInt8('}')\n                if Base.@nany($N, k->!@isdefined(j_{k}))\n                    error = InvalidJSON\n                    @goto invalid\n                end\n                return Base.@ntuple($N, j), pos + 1\n            elseif typ == JSONTypes.ARRAY && b == UInt8(']')\n                if Base.@nany($N, k->!@isdefined(j_{k}))\n                    error = InvalidJSON\n                    @goto invalid\n                end\n                return Base.@ntuple($N, j), pos + 1\n            elseif b != UInt8(',')\n                error = ExpectedComma\n                @goto invalid\n            end\n            pos += 1\n            @nextbyte\n        end\n        # skip extra fields not used by tuple\n        while true\n            if typ == JSONTypes.OBJECT\n                # consume key\n                GC.@preserve buf begin\n                    _, pos = @inline parsestring(LazyValue(buf, pos, JSONTypes.STRING, opts, false))\n                end\n                @nextbyte\n                if b != UInt8(':')\n                    error = ExpectedColon\n                    @goto invalid\n                end\n                pos += 1\n                @nextbyte\n            end\n            pos = skip(_lazy(buf, pos, len, b, opts))\n            @nextbyte\n            if typ == JSONTypes.OBJECT && b == UInt8('}')\n                return Base.@ntuple($N, j), pos + 1\n            elseif typ == JSONTypes.ARRAY && b == UInt8(']')\n                return Base.@ntuple($N, j), pos + 1\n            elseif b != UInt8(',')\n                error = ExpectedComma\n                @goto invalid\n            end\n            pos += 1\n            @nextbyte\n        end\n        @label invalid\n        invalid(error, buf, pos, \"tuple\")\n    end\n    return ex\nend"}, "files_after": {"src/parse.jl": "\"\"\"\n    JSON.parse(json)\n    JSON.parse(json, T)\n    JSON.parse!(json, x)\n    JSON.parsefile(filename)\n    JSON.parsefile(filename, T)\n    JSON.parsefile!(filename, x)\n\nParse a JSON input (string, vector, stream, LazyValue, etc.) into a Julia value. The `parsefile` variants\ntake a filename, open the file, and pass the `IOStream` to `parse`.\n\nCurrently supported keyword arguments include:\n  * `allownan`: allows parsing `NaN`, `Inf`, and `-Inf` since they are otherwise invalid JSON\n  * `ninf`: string to use for `-Inf` (default: `\"-Infinity\"`)\n  * `inf`: string to use for `Inf` (default: `\"Infinity\"`)\n  * `nan`: string to use for `NaN` (default: `\"NaN\"`)\n  * `jsonlines`: treat the `json` input as an implicit JSON array, delimited by newlines, each element being parsed from each row/line in the input\n  * `dicttype`: a custom `AbstractDict` type to use instead of `$DEFAULT_OBJECT_TYPE` as the default type for JSON object materialization\n  * `null`: a custom value to use for JSON null values (default: `nothing`)\n  * `style`: a custom `StructUtils.StructStyle` subtype instance to be used in calls to `StructUtils.make` and `StructUtils.lift`. This allows overriding\n    default behaviors for non-owned types.\n\nThe methods without a type specified (`JSON.parse(json)`, `JSON.parsefile(filename)`), do a generic materialization into\npredefined default types, including:\n  * JSON object => `$DEFAULT_OBJECT_TYPE` (**see note below**)\n  * JSON array => `Vector{Any}`\n  * JSON string => `String`\n  * JSON number => `Int64`, `BigInt`, `Float64`, or `BigFloat`\n  * JSON true => `true`\n  * JSON false => `false`\n  * JSON null => `nothing`\n\nWhen a type `T` is specified (`JSON.parse(json, T)`, `JSON.parsefile(filename, T)`), materialization to a value\nof type `T` will be attempted utilizing machinery and interfaces provided by the StructUtils.jl package, including:\n  * For JSON objects, JSON keys will be matched against field names of `T` with a value being constructed via `T(args...)`\n  * If `T` was defined with the `@noarg` macro, an empty instance will be constructed, and field values set as JSON keys match field names\n  * If `T` had default field values defined using the `@defaults` or `@kwarg` macros (from StructUtils.jl package), those will be set in the value of `T` unless different values are parsed from the JSON\n  * If `T` was defined with the `@nonstruct` macro, the struct will be treated as a primitive type and constructed using the `lift` function rather than from field values\n  * JSON keys that don't match field names in `T` will be ignored (skipped over)\n  * If a field in `T` has a `name` fieldtag, the `name` value will be used to match JSON keys instead\n  * If `T` or any recursive field type of `T` is abstract, an appropriate `JSON.@choosetype T x -> ...` definition should exist for \"choosing\" a concrete type at runtime; default type choosing exists for `Union{T, Missing}` and `Union{T, Nothing}` where the JSON value is checked if `null`. If the `Any` type is encountered, the default materialization types will be used (`JSON.Object`, `Vector{Any}`, etc.)\n  * For any non-JSON-standard non-aggregate (i.e. non-object, non-array) field type of `T`, a `JSON.lift(::Type{T}, x) = ...` definition can be defined for how to \"lift\" the default JSON value (String, Number, Bool, `nothing`) to the type `T`; a default lift definition exists, for example, for `JSON.lift(::Type{Missing}, x) = missing` where the standard JSON value for `null` is `nothing` and it can be \"lifted\" to `missing`\n  * For any `T` or recursive field type of `T` that is `AbstractDict`, non-string/symbol/integer keys will need to have a `StructUtils.liftkey(::Type{T}, x))` definition for how to \"lift\" the JSON string key to the key type of `T`\n\nFor any `T` or recursive field type of `T` that is `JSON.JSONText`, the next full raw JSON value will be preserved in the `JSONText` wrapper as-is.\n\nFor the unique case of nested JSON arrays and prior knowledge of the expected dimensionality,\na target type `T` can be given as an `AbstractArray{T, N}` subtype. In this case, the JSON array data is materialized as an\nn-dimensional array, where: the number of JSON array nestings must match the Julia array dimensionality (`N`),\nnested JSON arrays at matching depths are assumed to have equal lengths, and the length of\nthe innermost JSON array is the 1st dimension length and so on. For example, the JSON array `[[[1.0,2.0]]]`\nwould be materialized as a 3-dimensional array of `Float64` with sizes `(2, 1, 1)`, when called\nlike `JSON.parse(\"[[[1.0,2.0]]]\", Array{Float64, 3})`. Note that n-dimensional Julia\narrays are written to json as nested JSON arrays by default, to enable lossless re-parsing,\nthough the dimensionality must still be provided explicitly to the call to `parse` (i.e. default parsing via `JSON.parse(json)`\nwill result in plain nested `Vector{Any}`s returned).\n\nExamples:\n```julia\nusing Dates\n\nabstract type AbstractMonster end\n\nstruct Dracula <: AbstractMonster\n    num_victims::Int\nend\n\nstruct Werewolf <: AbstractMonster\n    witching_hour::DateTime\nend\n\nJSON.@choosetype AbstractMonster x -> x.monster_type[] == \"vampire\" ? Dracula : Werewolf\n\nstruct Percent <: Number\n    value::Float64\nend\n\nJSON.lift(::Type{Percent}, x) = Percent(Float64(x))\nStructUtils.liftkey(::Type{Percent}, x::String) = Percent(parse(Float64, x))\n\n@defaults struct FrankenStruct\n    id::Int = 0\n    name::String = \"Jim\"\n    address::Union{Nothing, String} = nothing\n    rate::Union{Missing, Float64} = missing\n    type::Symbol = :a &(json=(name=\"franken_type\",),)\n    notsure::Any = nothing\n    monster::AbstractMonster = Dracula(0)\n    percent::Percent = Percent(0.0)\n    birthdate::Date = Date(0) &(json=(dateformat=\"yyyy/mm/dd\",),)\n    percentages::Dict{Percent, Int} = Dict{Percent, Int}()\n    json_properties::JSONText = JSONText(\"\")\n    matrix::Matrix{Float64} = Matrix{Float64}(undef, 0, 0)\nend\n\njson = \\\"\\\"\\\"\n{\n    \"id\": 1,\n    \"address\": \"123 Main St\",\n    \"rate\": null,\n    \"franken_type\": \"b\",\n    \"notsure\": {\"key\": \"value\"},\n    \"monster\": {\n        \"monster_type\": \"vampire\",\n        \"num_victims\": 10\n    },\n    \"percent\": 0.1,\n    \"birthdate\": \"2023/10/01\",\n    \"percentages\": {\n        \"0.1\": 1,\n        \"0.2\": 2\n    },\n    \"json_properties\": {\"key\": \"value\"},\n    \"matrix\": [[1.0, 2.0], [3.0, 4.0]],\n    \"extra_key\": \"extra_value\"\n}\n\\\"\\\"\\\"\nJSON.parse(json, FrankenStruct)\n# FrankenStruct(1, \"Jim\", \"123 Main St\", missing, :b, JSON.Object{String, Any}(\"key\" => \"value\"), Dracula(10), Percent(0.1), Date(\"2023-10-01\"), Dict{Percent, Int64}(Percent(0.2) => 2, Percent(0.1) => 1), JSONText(\"{\\\"key\\\": \\\"value\\\"}\"), [1.0 3.0; 2.0 4.0])\n```\n\nLet's walk through some notable features of the example above:\n  * The `name` field isn't present in the JSON input, so the default value of `\"Jim\"` is used.\n  * The `address` field uses a default `@choosetype` to determine that the JSON value is not `null`, so a `String` should be parsed for the field value.\n  * The `rate` field has a `null` JSON value, so the default `@choosetype` recognizes it should be \"lifted\" to `Missing`, which then uses a predefined `lift` definition for `Missing`.\n  * The `type` field is a `Symbol`, and has a fieldtag `json=(name=\"franken_type\",)` which means the JSON key `franken_type` will be used to set the field value instead of the default `type` field name. A default `lift` definition for `Symbol` is used to convert the JSON string value to a `Symbol`.\n  * The `notsure` field is of type `Any`, so the default object type `JSON.Object{String, Any}` is used to materialize the JSON value.\n  * The `monster` field is a polymorphic type, and the JSON value has a `monster_type` key that determines which concrete type to use. The `@choosetype` macro is used to define the logic for choosing the concrete type based on the JSON input. Note that teh `x` in `@choosetype` is a `LazyValue`, so we materialize via `x.monster_type[]` in order to compare with the string `\"vampire\"`.\n  * The `percent` field is a custom type `Percent` and the `JSON.lift` defines how to construct a `Percent` from the JSON value, which is a `Float64` in this case.\n  * The `birthdate` field uses a custom date format for parsing, specified in the JSON input.\n  * The `percentages` field is a dictionary with keys of type `Percent`, which is a custom type. The `liftkey` function is defined to convert the JSON string keys to `Percent` types (parses the Float64 manually)\n  * The `json_properties` field has a type of `JSONText`, which means the raw JSON will be preserved as a String of the `JSONText` type.\n  * The `matrix` field is a `Matrix{Float64}`, so the JSON input array-of-arrays are materialized as such.\n  * The `extra_key` field is not defined in the `FrankenStruct` type, so it is ignored and skipped over.\n\nNOTE:\nWhy use `JSON.Object{String, Any}` as the default object type? It provides several benefits:\n  * Behaves as a drop-in replacement for `Dict{String, Any}`, so no loss of functionality\n  * Performance! It's internal representation means memory savings and faster construction for small objects typical in JSON (vs `Dict`)\n  * Insertion order is preserved, so the order of keys in the JSON input is preserved in `JSON.Object`\n  * Convenient `getproperty` (i.e. `obj.key`) syntax is supported, even for `Object{String,Any}` key types (again ideal/specialized for JSON usage)\n\n`JSON.Object` internal representation uses a linked list, thus key lookups are linear time (O(n)). For *large* JSON objects,\n(hundreds or thousands of keys), consider using a `Dict{String, Any}` instead, like `JSON.parse(json; dicttype=Dict{String, Any})`.\n\"\"\"\nfunction parse end\n\nimport StructUtils: StructStyle\n\nabstract type JSONStyle <: StructStyle end\n\n# defining a custom style allows us to pass a non-default dicttype `O` through JSON.parse\nstruct JSONReadStyle{O,T} <: JSONStyle\n    null::T\nend\n\nJSONReadStyle{O}(null::T) where {O,T} = JSONReadStyle{O,T}(null)\n\nobjecttype(::StructStyle) = DEFAULT_OBJECT_TYPE\nobjecttype(::JSONReadStyle{OT}) where {OT} = OT\nnullvalue(::StructStyle) = nothing\nnullvalue(st::JSONReadStyle) = st.null\n\n# this allows struct fields to specify tags under the json key specifically to override JSON behavior\nStructUtils.fieldtagkey(::JSONStyle) = :json\n\nfunction parsefile end\n@doc (@doc parse) parsefile\n\nfunction parsefile! end\n@doc (@doc parse) parsefile!\n\nparsefile(file; jsonlines::Union{Bool,Nothing}=nothing, kw...) = open(io -> parse(io; jsonlines=(jsonlines === nothing ? isjsonl(file) : jsonlines), kw...), file)\nparsefile(file, ::Type{T}; jsonlines::Union{Bool,Nothing}=nothing, kw...) where {T} = open(io -> parse(io, T; jsonlines=(jsonlines === nothing ? isjsonl(file) : jsonlines), kw...), file)\nparsefile!(file, x::T; jsonlines::Union{Bool,Nothing}=nothing, kw...) where {T} = open(io -> parse!(io, x; jsonlines=(jsonlines === nothing ? isjsonl(file) : jsonlines), kw...), file)\n\nparse(io::Union{IO,Base.AbstractCmd}, ::Type{T}=Any; kw...) where {T} = parse(Base.read(io), T; kw...)\n\nparse!(io::Union{IO,Base.AbstractCmd}, x::T; kw...) where {T} = parse!(Base.read(io), x; kw...)\n\nparse(buf::Union{AbstractVector{UInt8},AbstractString}, ::Type{T}=Any;\n    dicttype::Type{O}=DEFAULT_OBJECT_TYPE, null=nothing,\n    style::StructStyle=JSONReadStyle{dicttype}(null), kw...) where {T,O} =\n    @inline parse(lazy(buf; kw...), T; dicttype, null, style)\n\nparse!(buf::Union{AbstractVector{UInt8},AbstractString}, x::T; dicttype::Type{O}=DEFAULT_OBJECT_TYPE, null=nothing, style::StructStyle=JSONReadStyle{dicttype}(null), kw...) where {T,O} =\n    @inline parse!(lazy(buf; kw...), x; dicttype, null, style)\n\nparse(x::LazyValue, ::Type{T}=Any; dicttype::Type{O}=DEFAULT_OBJECT_TYPE, null=nothing, style::StructStyle=JSONReadStyle{dicttype}(null)) where {T,O} =\n    @inline _parse(x, T, dicttype, null, style)\n\nfunction _parse(x::LazyValue, ::Type{T}, dicttype::Type{O}, null, style::StructStyle) where {T,O}\n    y, pos = StructUtils.make(style, T, x)\n    getisroot(x) && checkendpos(x, T, pos)\n    return y\nend\n\nmutable struct ValueClosure\n    value::Any\n    ValueClosure() = new()\nend\n\n(f::ValueClosure)(v) = setfield!(f, :value, v)\n\nfunction _parse(x::LazyValue, ::Type{Any}, ::Type{DEFAULT_OBJECT_TYPE}, null, ::StructStyle)\n    out = ValueClosure()\n    pos = applyvalue(out, x, null)\n    getisroot(x) && checkendpos(x, Any, pos)\n    return out.value\nend\n\nparse!(x::LazyValue, obj::T; dicttype::Type{O}=DEFAULT_OBJECT_TYPE, null=nothing, style::StructStyle=JSONReadStyle{dicttype}(null)) where {T,O} = StructUtils.make!(style, obj, x)\n\n# for LazyValue, if x started at the beginning of the JSON input,\n# then we want to ensure that the entire input was consumed\n# and error if there are any trailing invalid JSON characters\nfunction checkendpos(x::LazyValue, ::Type{T}, pos::Int) where {T}\n    buf = getbuf(x)\n    len = getlength(buf)\n    if pos <= len\n        b = getbyte(buf, pos)\n        while b == UInt8('\\t') || b == UInt8(' ') || b == UInt8('\\n') || b == UInt8('\\r')\n            pos += 1\n            pos > len && break\n            b = getbyte(buf, pos)\n        end\n    end\n    if (pos - 1) != len\n        invalid(InvalidChar, buf, pos, T)\n    end\n    return nothing\nend\n\n# specialized closure to optimize Object{String, Any} insertions\n# to avoid doing a linear scan on each insertion, we use a Set\n# to track keys seen so far. In the common case of non-duplicated key,\n# we can insert the new key-val pair directly after the latest leaf node\nmutable struct ObjectClosure{T}\n    root::Object{String,Any}\n    obj::Object{String,Any}\n    keys::Set{String}\n    null::T\nend\n\nObjectClosure(obj, null) = ObjectClosure(obj, obj, sizehint!(Set{String}(), 16), null)\n\n@inline function insert_or_overwrite!(oc::ObjectClosure, key, val)\n    # in! does both a hash lookup and also sets the key if not present\n    if _in!(key, oc.keys)\n        # slow path for dups; does a linear scan from our root object\n        setindex!(oc.root, val, key)\n        return\n    end\n    # this uses an \"unsafe\" constructor that returns the new leaf node\n    # and sets the child of the previous node to the new node\n    oc.obj = Object{String,Any}(oc.obj, key, val) # fast append path\nend\n\n(oc::ObjectClosure)(k, v) = applyvalue(val -> insert_or_overwrite!(oc, convert(String, k), val), v, oc.null)\n\n# generic apply `f` to LazyValue, using default types to materialize, depending on type\nfunction applyvalue(f, x::LazyValues, null)\n    type = gettype(x)\n    if type == JSONTypes.OBJECT\n        obj = Object{String,Any}()\n        pos = applyobject(ObjectClosure(obj, null), x)\n        f(obj)\n        return pos\n    elseif type == JSONTypes.ARRAY\n        # basically free to allocate 16 instead of Julia-default 8 and avoids\n        # a reallocation in many cases\n        arr = Vector{Any}(undef, 16)\n        resize!(arr, 0)\n        pos = applyarray(x) do _, v\n            applyvalue(val -> push!(arr, val), v, null)\n        end\n        f(arr)\n        return pos\n    elseif type == JSONTypes.STRING\n        buf = getbuf(x)\n        GC.@preserve buf begin\n            str, pos = parsestring(x)\n            f(convert(String, str))\n        end\n        return pos\n    elseif type == JSONTypes.NUMBER\n        num, pos = parsenumber(x)\n        if isint(num)\n            f(num.int)\n        elseif isfloat(num)\n            f(num.float)\n        elseif isbigint(num)\n            f(num.bigint)\n        else\n            f(num.bigfloat)\n        end\n        return pos\n    elseif type == JSONTypes.NULL\n        f(null)\n        return getpos(x) + 4\n    elseif type == JSONTypes.TRUE\n        f(true)\n        return getpos(x) + 4\n    elseif type == JSONTypes.FALSE\n        f(false)\n        return getpos(x) + 5\n    else\n        throw(ArgumentError(\"cannot parse json\"))\n    end\nend\n\n# we overload make! for Any for LazyValues because we can dispatch to more specific\n# types base on the LazyValue type\nfunction StructUtils.make(st::StructStyle, ::Type{Any}, x::LazyValues)\n    type = gettype(x)\n    if type == JSONTypes.OBJECT\n        return StructUtils.make(st, objecttype(st), x)\n    elseif type == JSONTypes.ARRAY\n        return StructUtils.make(st, Vector{Any}, x)\n    elseif type == JSONTypes.STRING\n        return StructUtils.lift(st, String, x)\n    elseif type == JSONTypes.NUMBER\n        return StructUtils.lift(st, Number, x)\n    elseif type == JSONTypes.NULL\n        return StructUtils.lift(st, Nothing, x)\n    elseif type == JSONTypes.TRUE || type == JSONTypes.FALSE\n        return StructUtils.lift(st, Bool, x)\n    else\n        throw(ArgumentError(\"cannot parse $x\"))\n    end\nend\n\n# catch PtrString via lift or make! so we can ensure it never \"escapes\" to user-level\nStructUtils.liftkey(st::StructStyle, ::Type{T}, x::PtrString) where {T} =\n    StructUtils.liftkey(st, T, convert(String, x))\nStructUtils.lift(st::StructStyle, ::Type{T}, x::PtrString, tags) where {T} =\n    StructUtils.lift(st, T, convert(String, x), tags)\nStructUtils.lift(st::StructStyle, ::Type{T}, x::PtrString) where {T} =\n    StructUtils.lift(st, T, convert(String, x))\n\n# liftkey for numeric dict key types to enable round-tripping Dict{Int,V}, Dict{Float64,V}, etc.\n# these correspond to the lowerkey definitions in write.jl that convert numeric keys to strings\nStructUtils.liftkey(::JSONStyle, ::Type{T}, x::AbstractString) where {T<:Integer} = Base.parse(T, x)\nStructUtils.liftkey(::JSONStyle, ::Type{T}, x::AbstractString) where {T<:AbstractFloat} = Base.parse(T, x)\n\nfunction StructUtils.lift(style::StructStyle, ::Type{T}, x::LazyValues) where {T<:AbstractArray{E,0}} where {E}\n    m = T(undef)\n    m[1], pos = StructUtils.lift(style, E, x)\n    return m, pos\nend\n\nfunction StructUtils.lift(style::StructStyle, ::Type{T}, x::LazyValues, tags=(;)) where {T}\n    type = gettype(x)\n    buf = getbuf(x)\n    if type == JSONTypes.STRING\n        GC.@preserve buf begin\n            ptrstr, pos = parsestring(x)\n            str, _ = StructUtils.lift(style, T, ptrstr, tags)\n        end\n        return str, pos\n    elseif type == JSONTypes.NUMBER\n        num, pos = parsenumber(x)\n        if isint(num)\n            T === Int64 && return num.int, pos\n            int, _ = StructUtils.lift(style, T, num.int, tags)\n            return int, pos\n        elseif isfloat(num)\n            T === Float64 && return num.float, pos\n            float, _ = StructUtils.lift(style, T, num.float, tags)\n            return float, pos\n        elseif isbigint(num)\n            T === BigInt && return num.bigint, pos\n            bigint, _ = StructUtils.lift(style, T, num.bigint, tags)\n            return bigint, pos\n        else\n            T === BigFloat && return num.bigfloat, pos\n            bigfloat, _ = StructUtils.lift(style, T, num.bigfloat, tags)\n            return bigfloat, pos\n        end\n    elseif type == JSONTypes.NULL\n        null, _ = StructUtils.lift(style, T, nullvalue(style), tags)\n        return null, getpos(x) + 4\n    elseif type == JSONTypes.TRUE\n        tr, _ = StructUtils.lift(style, T, true, tags)\n        return tr, getpos(x) + 4\n    elseif type == JSONTypes.FALSE\n        fl, _ = StructUtils.lift(style, T, false, tags)\n        return fl, getpos(x) + 5\n    elseif Base.issingletontype(T)\n        sglt, _ = StructUtils.lift(style, T, T(), tags)\n        return sglt, skip(x)\n    else\n        out = ValueClosure()\n        pos = applyvalue(out, x, nothing)\n        val1 = out.value\n        # big switch here for --trim verify-ability\n        if val1 isa Object{String,Any}\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa Vector{Any}\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa String\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa Int64\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa Float64\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa BigInt\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa BigFloat\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa Bool\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        elseif val1 isa Nothing\n            val, _ = StructUtils.lift(style, T, val1)\n            return val, pos\n        else\n            throw(ArgumentError(\"cannot parse json\"))\n        end\n    end\nend\n\nfunction StructUtils.make(::StructStyle, ::Type{JSONText}, x::LazyValues)\n    buf = getbuf(x)\n    pos = getpos(x)\n    endpos = skip(x)\n    val = GC.@preserve buf JSONText(unsafe_string(pointer(buf, pos), endpos - pos))\n    return val, endpos\nend\n\n@generated function StructUtils.maketuple(st::StructStyle, ::Type{T}, x::LazyValues) where {T<:Tuple}\n    N = fieldcount(T)\n    ex = quote\n        pos::Int = getpos(x)\n        buf = getbuf(x)\n        len = getlength(buf)\n        opts = getopts(x)\n        b = getbyte(buf, pos)\n        typ = gettype(x)\n        if typ == JSONTypes.OBJECT && b != UInt8('{')\n            error = ExpectedOpeningObjectChar\n            @goto invalid\n        elseif typ == JSONTypes.ARRAY && b != UInt8('[')\n            error = ExpectedOpeningArrayChar\n            @goto invalid\n        elseif typ != JSONTypes.OBJECT && typ != JSONTypes.ARRAY\n            error = InvalidJSON\n            @goto invalid\n        end\n        pos += 1\n        @nextbyte\n        Base.@nexprs $N i -> begin\n            if typ == JSONTypes.OBJECT\n                # consume key\n                GC.@preserve buf begin\n                    _, pos = @inline parsestring(LazyValue(buf, pos, JSONTypes.STRING, opts, false))\n                end\n                @nextbyte\n                if b != UInt8(':')\n                    error = ExpectedColon\n                    @goto invalid\n                end\n                pos += 1\n                @nextbyte\n            end\n            x = _lazy(buf, pos, len, b, opts)\n            j_{i}, pos = StructUtils.make(st, fieldtype(T, i), x)\n            @nextbyte\n            if typ == JSONTypes.OBJECT && b == UInt8('}')\n                if Base.@nany($N, k->!@isdefined(j_{k}))\n                    error = InvalidJSON\n                    @goto invalid\n                end\n                return Base.@ntuple($N, j), pos + 1\n            elseif typ == JSONTypes.ARRAY && b == UInt8(']')\n                if Base.@nany($N, k->!@isdefined(j_{k}))\n                    error = InvalidJSON\n                    @goto invalid\n                end\n                return Base.@ntuple($N, j), pos + 1\n            elseif b != UInt8(',')\n                error = ExpectedComma\n                @goto invalid\n            end\n            pos += 1\n            @nextbyte\n        end\n        # skip extra fields not used by tuple\n        while true\n            if typ == JSONTypes.OBJECT\n                # consume key\n                GC.@preserve buf begin\n                    _, pos = @inline parsestring(LazyValue(buf, pos, JSONTypes.STRING, opts, false))\n                end\n                @nextbyte\n                if b != UInt8(':')\n                    error = ExpectedColon\n                    @goto invalid\n                end\n                pos += 1\n                @nextbyte\n            end\n            pos = skip(_lazy(buf, pos, len, b, opts))\n            @nextbyte\n            if typ == JSONTypes.OBJECT && b == UInt8('}')\n                return Base.@ntuple($N, j), pos + 1\n            elseif typ == JSONTypes.ARRAY && b == UInt8(']')\n                return Base.@ntuple($N, j), pos + 1\n            elseif b != UInt8(',')\n                error = ExpectedComma\n                @goto invalid\n            end\n            pos += 1\n            @nextbyte\n        end\n        @label invalid\n        invalid(error, buf, pos, \"tuple\")\n    end\n    return ex\nend"}, "source_files_changed": ["src/parse.jl"], "test_files_changed": ["test/parse.jl"], "lines_changed": 12, "is_valid": true, "validation_errors": []}
{"repo": "JSON.jl", "commit_sha": "928a3cc5b3433657a828b3b86c70aa569c668051", "parent_sha": "7ffcc9d8da567ccde8c2a1f2879ce78a8fbf36fd", "commit_message": "add getindex(::Object{String}, ::Symbol) and vice versa (#420)", "commit_date": "2025-12-18T19:17:23+01:00", "action": {"type": "ADD_METHOD", "target_file": "src/object.jl", "target_symbol": "Base.getindex", "signature": null, "confidence": 0.85}, "files_before": {"src/object.jl": "struct NotSet end\nconst notset = NotSet()\n\n\"\"\"\n    JSON.Object{K,V}\n\nA mutable `AbstractDict` type for JSON objects. Internally is a linked list of key-value pairs, where each pair is represented by an `Object` instance. The first instance is the root object.\nThe `Object` type is used to represent JSON objects in a mutable way, allowing for efficient insertion and deletion of key-value pairs. It is designed to be used with the `JSON` package for parsing and deserializing JSON data.\n\nBecause of the linked-list representation, key lookups are O(n), using a simple linear scan.\nFor small objects, this is very efficient, and worth the memory overhead vs. a full `Dict` or `OrderedDict`.\nFor Objects with many entries (hundreds or thousands), this is not as efficient. In that case, consider using a `Dict` or `OrderedDict` instead.\n\"\"\"\n# empty Object: key, value, child all notset\n# root Object: key, value are notset, child is defined\n# non-root Object: key, value are set, child is notset for last node\nmutable struct Object{K,V} <: AbstractDict{K,V}\n    key::Union{NotSet, K} # for root object, key/value are notset\n    value::Union{NotSet, V}\n    child::Union{NotSet, Object{K,V}} # possibly notset\n\n    # root constructor: key is const notset\n    function Object{K,V}() where {K,V}\n        x = new{K,V}(notset, notset, notset)\n        return x\n    end\n\n    # all non-root Objects *must* be set as the child of another Object\n    # WARNING: this constructor can allow duplicate `k` in a root Object as no check is done\n    function Object{K,V}(obj::Object{K,V}, k, v) where {K,V}\n        @assert _ch(obj) === notset \"Object child already defined\"\n        nobj = new{K,V}(k, v, notset)\n        setfield!(obj, :child, nobj)\n        return nobj\n    end\nend\n\nObject() = Object{Any, Any}() # default empty object\n\n_k(obj::Object) = getfield(obj, :key)\n_v(obj::Object) = getfield(obj, :value)\n_ch(obj::Object) = getfield(obj, :child)\n\nObject(d::AbstractDict{K,V}) where {K,V} = Object{K,V}(d)\n\nfunction Object{K,V}(d::AbstractDict{K,V}) where {K,V}\n    root = obj = Object{K,V}()\n    for (k, v) in d\n        obj = Object{K,V}(obj, k, v)\n    end\n    return root\nend\n\nObject(pairs::Pair{K,V}...) where {K,V} = Object{K,V}(pairs...)\nObject(pairs::Pair...) = Object{Any,Any}(pairs...)\n\nfunction Object{K,V}(pairs::Pair...) where {K,V}\n    root = obj = Object{K,V}()\n    for (k, v) in pairs\n        obj = Object{K,V}(obj, k, v)\n    end\n    return root\nend\n\n# generic iterator constructors\nfunction Object(itr)\n    root = obj = nothing\n    st = iterate(itr)\n    while st !== nothing\n        kv, state = st\n        if kv isa Pair || kv isa Tuple{Any,Any}\n            k, v = kv\n            if root === nothing\n                root = Object{typeof(k), typeof(v)}()\n                obj = root\n            end\n            obj = Object{typeof(k), typeof(v)}(obj, k, v)\n        else\n            throw(ArgumentError(\"Iterator must yield Pair or 2-tuple, got $(typeof(kv))\"))\n        end\n        st = iterate(itr, state)\n    end\n    return root === nothing ? Object{Any,Any}() : root\nend\n\nfunction Object{K,V}(itr) where {K,V}\n    root = obj = Object{K,V}()\n    st = iterate(itr)\n    while st !== nothing\n        kv, state = st\n        if kv isa Pair || kv isa Tuple{Any,Any}\n            k, v = kv\n            obj = Object{K, V}(obj, k, v)\n        else\n            throw(ArgumentError(\"Iterator must yield Pair or 2-tuple, got $(typeof(kv))\"))\n        end\n        st = iterate(itr, state)\n    end\n    return root\nend\n\nfunction Base.iterate(orig::Object{K,V}, obj=orig) where {K,V}\n    obj === nothing && return nothing\n    if _k(obj) === notset\n        # if key is notset, we either have to iterate from the child or we're done\n        return _ch(obj) === notset ? nothing : iterate(_ch(obj)::Object{K,V})\n    end\n    return (Pair{K,V}(_k(obj)::K, _v(obj)::V), _ch(obj) === notset ? nothing : _ch(obj)::Object{K,V})\nend\n\nfunction Base.length(obj::Object{K,V}) where {K,V}\n    count = 0\n    while true\n        _k(obj) !== notset && (count += 1)\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    return count\nend\nBase.isempty(obj::Object) = _k(obj) === notset && _ch(obj) === notset\nBase.empty(::Object{K,V}) where {K,V} = Object{K,V}() # empty object\n\n# linear node lookup\n@inline function find_node_by_key(obj::Object{K,V}, key::K) where {K,V}\n    while true\n        _k(obj) !== notset && isequal(_k(obj)::K, key) && return obj\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    return nothing\nend\n\n# get with fallback callable\nfunction Base.get(f::Base.Callable, obj::Object{K,V}, key) where {K,V}\n    node = find_node_by_key(obj, key)\n    node !== nothing && return _v(node)::V\n    return f()\nend\n\nBase.getindex(obj::Object, key) = get(() -> throw(KeyError(key)), obj, key)\nBase.get(obj::Object, key, default) = get(() -> default, obj, key)\n\n# support getproperty for dot access\nBase.getproperty(obj::Object{Symbol}, sym::Symbol) = getindex(obj, sym)\nBase.getproperty(obj::Object{String}, sym::Symbol) = getindex(obj, String(sym))\nBase.propertynames(obj::Object{K,V}) where {K,V} = _k(obj) === notset && _ch(obj) === notset ? () : _propertynames(_ch(obj)::Object{K,V}, ())\n\nfunction _propertynames(obj::Object{K,V}, acc) where {K,V}\n    new = (acc..., Symbol(_k(obj)::K))\n    return _ch(obj) === notset ? new : _propertynames(_ch(obj)::Object{K,V}, new)\nend\n\n# haskey\nBase.haskey(obj::Object, key) = find_node_by_key(obj, key) !== nothing\nBase.haskey(obj::Object{String}, key::Symbol) = haskey(obj, String(key))\n\n# setindex! finds node with key and sets value or inserts a new node\nfunction Base.setindex!(obj::Object{K,V}, value, key::K) where {K,V}\n    root = obj\n    while true\n        if _k(obj) !== notset && isequal(_k(obj)::K, key)\n            setfield!(obj, :value, convert(V, value))\n            return root\n        end\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    # if we reach here, we need to insert a new node\n    Object{K,V}(obj, key, value)\n    return value\nend\n\n# delete! removes node\nfunction Base.delete!(obj::Object{K,V}, key::K) where {K,V}\n    # check empty case\n    _ch(obj) === notset && return obj\n    root = parent = obj\n    obj = _ch(obj)::Object{K,V}\n    while true\n        if _k(obj) !== notset && isequal(_k(obj)::K, key)\n            # we found the node to remove\n            # if node is leaf, we need to set parent as leaf\n            # otherwise, we set child as child of parent\n            if _ch(obj) === notset\n                setfield!(parent, :child, notset)\n            else\n                setfield!(parent, :child, _ch(obj)::Object{K,V})\n            end\n        end\n        _ch(obj) === notset && break\n        parent = obj\n        obj = _ch(obj)::Object{K,V}\n    end\n    return root\nend\n\nfunction Base.empty!(obj::Object)\n    setfield!(obj, :child, notset)\n    return obj\nend\n\n# support setproperty for dot access\nBase.setproperty!(obj::Object, sym::Symbol, val) = setindex!(obj, val, sym)\nBase.setproperty!(obj::Object{String}, sym::Symbol, val) = setindex!(obj, val, String(sym))\n\nBase.merge(a::NamedTuple, b::Object{String,Any}) = merge(a, (Symbol(k) => v for (k, v) in b))"}, "files_after": {"src/object.jl": "struct NotSet end\nconst notset = NotSet()\n\n\"\"\"\n    JSON.Object{K,V}\n\nA mutable `AbstractDict` type for JSON objects. Internally is a linked list of key-value pairs, where each pair is represented by an `Object` instance. The first instance is the root object.\nThe `Object` type is used to represent JSON objects in a mutable way, allowing for efficient insertion and deletion of key-value pairs. It is designed to be used with the `JSON` package for parsing and deserializing JSON data.\n\nBecause of the linked-list representation, key lookups are O(n), using a simple linear scan.\nFor small objects, this is very efficient, and worth the memory overhead vs. a full `Dict` or `OrderedDict`.\nFor Objects with many entries (hundreds or thousands), this is not as efficient. In that case, consider using a `Dict` or `OrderedDict` instead.\n\"\"\"\n# empty Object: key, value, child all notset\n# root Object: key, value are notset, child is defined\n# non-root Object: key, value are set, child is notset for last node\nmutable struct Object{K,V} <: AbstractDict{K,V}\n    key::Union{NotSet, K} # for root object, key/value are notset\n    value::Union{NotSet, V}\n    child::Union{NotSet, Object{K,V}} # possibly notset\n\n    # root constructor: key is const notset\n    function Object{K,V}() where {K,V}\n        x = new{K,V}(notset, notset, notset)\n        return x\n    end\n\n    # all non-root Objects *must* be set as the child of another Object\n    # WARNING: this constructor can allow duplicate `k` in a root Object as no check is done\n    function Object{K,V}(obj::Object{K,V}, k, v) where {K,V}\n        @assert _ch(obj) === notset \"Object child already defined\"\n        nobj = new{K,V}(k, v, notset)\n        setfield!(obj, :child, nobj)\n        return nobj\n    end\nend\n\nObject() = Object{Any, Any}() # default empty object\n\n_k(obj::Object) = getfield(obj, :key)\n_v(obj::Object) = getfield(obj, :value)\n_ch(obj::Object) = getfield(obj, :child)\n\nObject(d::AbstractDict{K,V}) where {K,V} = Object{K,V}(d)\n\nfunction Object{K,V}(d::AbstractDict{K,V}) where {K,V}\n    root = obj = Object{K,V}()\n    for (k, v) in d\n        obj = Object{K,V}(obj, k, v)\n    end\n    return root\nend\n\nObject(pairs::Pair{K,V}...) where {K,V} = Object{K,V}(pairs...)\nObject(pairs::Pair...) = Object{Any,Any}(pairs...)\n\nfunction Object{K,V}(pairs::Pair...) where {K,V}\n    root = obj = Object{K,V}()\n    for (k, v) in pairs\n        obj = Object{K,V}(obj, k, v)\n    end\n    return root\nend\n\n# generic iterator constructors\nfunction Object(itr)\n    root = obj = nothing\n    st = iterate(itr)\n    while st !== nothing\n        kv, state = st\n        if kv isa Pair || kv isa Tuple{Any,Any}\n            k, v = kv\n            if root === nothing\n                root = Object{typeof(k), typeof(v)}()\n                obj = root\n            end\n            obj = Object{typeof(k), typeof(v)}(obj, k, v)\n        else\n            throw(ArgumentError(\"Iterator must yield Pair or 2-tuple, got $(typeof(kv))\"))\n        end\n        st = iterate(itr, state)\n    end\n    return root === nothing ? Object{Any,Any}() : root\nend\n\nfunction Object{K,V}(itr) where {K,V}\n    root = obj = Object{K,V}()\n    st = iterate(itr)\n    while st !== nothing\n        kv, state = st\n        if kv isa Pair || kv isa Tuple{Any,Any}\n            k, v = kv\n            obj = Object{K, V}(obj, k, v)\n        else\n            throw(ArgumentError(\"Iterator must yield Pair or 2-tuple, got $(typeof(kv))\"))\n        end\n        st = iterate(itr, state)\n    end\n    return root\nend\n\nfunction Base.iterate(orig::Object{K,V}, obj=orig) where {K,V}\n    obj === nothing && return nothing\n    if _k(obj) === notset\n        # if key is notset, we either have to iterate from the child or we're done\n        return _ch(obj) === notset ? nothing : iterate(_ch(obj)::Object{K,V})\n    end\n    return (Pair{K,V}(_k(obj)::K, _v(obj)::V), _ch(obj) === notset ? nothing : _ch(obj)::Object{K,V})\nend\n\nfunction Base.length(obj::Object{K,V}) where {K,V}\n    count = 0\n    while true\n        _k(obj) !== notset && (count += 1)\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    return count\nend\nBase.isempty(obj::Object) = _k(obj) === notset && _ch(obj) === notset\nBase.empty(::Object{K,V}) where {K,V} = Object{K,V}() # empty object\n\n# linear node lookup\n@inline function find_node_by_key(obj::Object{K,V}, key::K) where {K,V}\n    while true\n        _k(obj) !== notset && isequal(_k(obj)::K, key) && return obj\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    return nothing\nend\n\n# get with fallback callable\nfunction Base.get(f::Base.Callable, obj::Object{K,V}, key) where {K,V}\n    node = find_node_by_key(obj, key)\n    node !== nothing && return _v(node)::V\n    return f()\nend\n\nBase.getindex(obj::Object, key) = get(() -> throw(KeyError(key)), obj, key)\nBase.getindex(obj::Object{String}, key::Symbol) = get(() -> throw(KeyError(key)), obj, String(key))\nBase.getindex(obj::Object{Symbol}, key::String) = get(() -> throw(KeyError(key)), obj, Symbol(key))\nBase.get(obj::Object, key, default) = get(() -> default, obj, key)\n\n# support getproperty for dot access\nBase.getproperty(obj::Object{Symbol}, sym::Symbol) = getindex(obj, sym)\nBase.getproperty(obj::Object{String}, sym::Symbol) = getindex(obj, String(sym))\nBase.propertynames(obj::Object{K,V}) where {K,V} = _k(obj) === notset && _ch(obj) === notset ? () : _propertynames(_ch(obj)::Object{K,V}, ())\n\nfunction _propertynames(obj::Object{K,V}, acc) where {K,V}\n    new = (acc..., Symbol(_k(obj)::K))\n    return _ch(obj) === notset ? new : _propertynames(_ch(obj)::Object{K,V}, new)\nend\n\n# haskey\nBase.haskey(obj::Object, key) = find_node_by_key(obj, key) !== nothing\nBase.haskey(obj::Object{String}, key::Symbol) = haskey(obj, String(key))\n\n# setindex! finds node with key and sets value or inserts a new node\nfunction Base.setindex!(obj::Object{K,V}, value, key::K) where {K,V}\n    root = obj\n    while true\n        if _k(obj) !== notset && isequal(_k(obj)::K, key)\n            setfield!(obj, :value, convert(V, value))\n            return root\n        end\n        _ch(obj) === notset && break\n        obj = _ch(obj)::Object{K,V}\n    end\n    # if we reach here, we need to insert a new node\n    Object{K,V}(obj, key, value)\n    return value\nend\n\n# delete! removes node\nfunction Base.delete!(obj::Object{K,V}, key::K) where {K,V}\n    # check empty case\n    _ch(obj) === notset && return obj\n    root = parent = obj\n    obj = _ch(obj)::Object{K,V}\n    while true\n        if _k(obj) !== notset && isequal(_k(obj)::K, key)\n            # we found the node to remove\n            # if node is leaf, we need to set parent as leaf\n            # otherwise, we set child as child of parent\n            if _ch(obj) === notset\n                setfield!(parent, :child, notset)\n            else\n                setfield!(parent, :child, _ch(obj)::Object{K,V})\n            end\n        end\n        _ch(obj) === notset && break\n        parent = obj\n        obj = _ch(obj)::Object{K,V}\n    end\n    return root\nend\n\nfunction Base.empty!(obj::Object)\n    setfield!(obj, :child, notset)\n    return obj\nend\n\n# support setproperty for dot access\nBase.setproperty!(obj::Object, sym::Symbol, val) = setindex!(obj, val, sym)\nBase.setproperty!(obj::Object{String}, sym::Symbol, val) = setindex!(obj, val, String(sym))\n\nBase.merge(a::NamedTuple, b::Object{String,Any}) = merge(a, (Symbol(k) => v for (k, v) in b))"}, "source_files_changed": ["src/object.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": true, "validation_errors": []}
{"repo": "JSON.jl", "commit_sha": "7ffcc9d8da567ccde8c2a1f2879ce78a8fbf36fd", "parent_sha": "a19277cd0a01d72dbe76c891802bc6d4e6e64fa4", "commit_message": "export kwarg (#418)", "commit_date": "2025-12-10T22:13:57+09:00", "action": {"type": "ADD_IMPORT", "target_file": "src/JSON.jl", "target_symbol": null, "signature": null, "confidence": 0.6}, "files_before": {"src/JSON.jl": "module JSON\n\n# stdlibs\nusing Dates, UUIDs, Logging\n# external dependencies\nusing PrecompileTools, Parsers, StructUtils\n\n# reexport some StructUtils macros\nimport StructUtils: @noarg, @defaults, @tags, @choosetype, @nonstruct, lower, lift\nexport JSONText, StructUtils, @noarg, @defaults, @tags, @choosetype, @nonstruct, @omit_null, @omit_empty\n\n@enum Error InvalidJSON UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedClosingArrayChar ExpectedComma ExpectedColon ExpectedNewline InvalidChar InvalidNumber InvalidUTF16\n\n@noinline function invalid(error, buf, pos::Int, T)\n    # compute which line the error falls on by counting \u201c\\n\u201d bytes up to pos\n    cus = buf isa AbstractString ? codeunits(buf) : buf\n    line_no = count(b -> b == UInt8('\\n'), view(cus, 1:pos)) + 1\n\n    li = pos > 20 ? pos - 9 : 1\n    ri = min(sizeof(cus), pos + 20)\n    snippet_bytes = cus[li:ri]\n    snippet_pos = pos - li + 1\n    snippet = String(copy(snippet_bytes))\n    # find error position; if snippet has multi-codepoint chars,\n    # translate pos to char index, accounting for textwidth of char\n    erri = 1\n    st = iterate(snippet)\n    while st !== nothing\n        c, i = st\n        i > snippet_pos && break\n        erri += textwidth(c)\n        st = iterate(snippet, i)\n    end\n    snippet = replace(snippet, r\"[\\b\\f\\n\\r\\t]\" => \" \")\n    # we call @invoke here to avoid --trim verify errors\n    caret = @invoke(repeat(\" \"::String, (erri + 2)::Integer)) * \"^\"\n    msg = \"\"\"\n    invalid JSON at byte position $(pos) (line $line_no) parsing type $T: $error\n    $snippet$(error == UnexpectedEOF ? \" <EOF>\" : \"...\")\n    $caret\n    \"\"\"\n    throw(ArgumentError(msg))\nend\n\ninclude(\"utils.jl\")\ninclude(\"object.jl\")\n\n# default object type for parse\nconst DEFAULT_OBJECT_TYPE = Object{String, Any}\n\n\"\"\"\n    JSON.JSONText\n\nWrapper around a string containing JSON data.\nCan be used to insert raw JSON in JSON output, like:\n```julia\njson(JSONText(\"{\\\"key\\\": \\\"value\\\"}\"))\n```\nThis will output the JSON as-is, without escaping.\nNote that no check is done to ensure that the JSON is valid.\n\nCan also be used to read \"raw JSON\" when parsing, meaning\nno specialized structure (JSON.Object, Vector{Any}, etc.) is created.\nExample:\n```julia\nx = JSON.parse(\"[1,2,3]\", JSONText)\n# x.value == \"[1,2,3]\"\n```\n\"\"\"\nstruct JSONText\n    value::String\nend\n\ninclude(\"lazy.jl\")\ninclude(\"parse.jl\")\ninclude(\"write.jl\")\n\n\"\"\"\n    JSON.isvalidjson(json) -> Bool\n\nCheck if the given JSON is valid.\nThis function will return `true` if the JSON is valid, and `false` otherwise.\nInputs can be a string, a vector of bytes, or an IO stream, the same inputs\nas supported for `JSON.lazy` and `JSON.parse`.\n\"\"\"\nfunction isvalidjson end\n\nisvalidjson(io::Union{IO, Base.AbstractCmd}; kw...) = isvalidjson(Base.read(io); kw...)\n\nfunction isvalidjson(buf::Union{AbstractVector{UInt8}, AbstractString}; kw...)\n    try\n        return isvalidjson(lazy(buf; kw...))\n    catch\n        return false\n    end\nend\n\nfunction isvalidjson(x::LazyValue)\n    try\n        skip(x)\n        return true\n    catch\n        return false\n    end\nend\n\n# convenience aliases for pre-1.0 JSON compat\nprint(io::IO, obj, indent=nothing) = json(io, obj; pretty=something(indent, 0))\nprint(a, indent=nothing) = print(stdout, a, indent)\n@doc (@doc json) print\n\n@compile_workload begin\n    x = JSON.parse(\"{\\\"a\\\": 1, \\\"b\\\": null, \\\"c\\\": true, \\\"d\\\": false, \\\"e\\\": \\\"\\\", \\\"f\\\": [1,null,true], \\\"g\\\": {\\\"key\\\": \\\"value\\\"}}\")\n    json = JSON.json(x)\n    isvalidjson(json)\nend\n\n\nend # module\n"}, "files_after": {"src/JSON.jl": "module JSON\n\n# stdlibs\nusing Dates, UUIDs, Logging\n# external dependencies\nusing PrecompileTools, Parsers, StructUtils\n\n# reexport some StructUtils macros\nimport StructUtils: @noarg, @kwarg, @defaults, @tags, @choosetype, @nonstruct, lower, lift\nexport JSONText, StructUtils, @noarg, @kwarg, @defaults, @tags, @choosetype, @nonstruct, @omit_null, @omit_empty\n\n@enum Error InvalidJSON UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedClosingArrayChar ExpectedComma ExpectedColon ExpectedNewline InvalidChar InvalidNumber InvalidUTF16\n\n@noinline function invalid(error, buf, pos::Int, T)\n    # compute which line the error falls on by counting \u201c\\n\u201d bytes up to pos\n    cus = buf isa AbstractString ? codeunits(buf) : buf\n    line_no = count(b -> b == UInt8('\\n'), view(cus, 1:pos)) + 1\n\n    li = pos > 20 ? pos - 9 : 1\n    ri = min(sizeof(cus), pos + 20)\n    snippet_bytes = cus[li:ri]\n    snippet_pos = pos - li + 1\n    snippet = String(copy(snippet_bytes))\n    # find error position; if snippet has multi-codepoint chars,\n    # translate pos to char index, accounting for textwidth of char\n    erri = 1\n    st = iterate(snippet)\n    while st !== nothing\n        c, i = st\n        i > snippet_pos && break\n        erri += textwidth(c)\n        st = iterate(snippet, i)\n    end\n    snippet = replace(snippet, r\"[\\b\\f\\n\\r\\t]\" => \" \")\n    # we call @invoke here to avoid --trim verify errors\n    caret = @invoke(repeat(\" \"::String, (erri + 2)::Integer)) * \"^\"\n    msg = \"\"\"\n    invalid JSON at byte position $(pos) (line $line_no) parsing type $T: $error\n    $snippet$(error == UnexpectedEOF ? \" <EOF>\" : \"...\")\n    $caret\n    \"\"\"\n    throw(ArgumentError(msg))\nend\n\ninclude(\"utils.jl\")\ninclude(\"object.jl\")\n\n# default object type for parse\nconst DEFAULT_OBJECT_TYPE = Object{String, Any}\n\n\"\"\"\n    JSON.JSONText\n\nWrapper around a string containing JSON data.\nCan be used to insert raw JSON in JSON output, like:\n```julia\njson(JSONText(\"{\\\"key\\\": \\\"value\\\"}\"))\n```\nThis will output the JSON as-is, without escaping.\nNote that no check is done to ensure that the JSON is valid.\n\nCan also be used to read \"raw JSON\" when parsing, meaning\nno specialized structure (JSON.Object, Vector{Any}, etc.) is created.\nExample:\n```julia\nx = JSON.parse(\"[1,2,3]\", JSONText)\n# x.value == \"[1,2,3]\"\n```\n\"\"\"\nstruct JSONText\n    value::String\nend\n\ninclude(\"lazy.jl\")\ninclude(\"parse.jl\")\ninclude(\"write.jl\")\n\n\"\"\"\n    JSON.isvalidjson(json) -> Bool\n\nCheck if the given JSON is valid.\nThis function will return `true` if the JSON is valid, and `false` otherwise.\nInputs can be a string, a vector of bytes, or an IO stream, the same inputs\nas supported for `JSON.lazy` and `JSON.parse`.\n\"\"\"\nfunction isvalidjson end\n\nisvalidjson(io::Union{IO, Base.AbstractCmd}; kw...) = isvalidjson(Base.read(io); kw...)\n\nfunction isvalidjson(buf::Union{AbstractVector{UInt8}, AbstractString}; kw...)\n    try\n        return isvalidjson(lazy(buf; kw...))\n    catch\n        return false\n    end\nend\n\nfunction isvalidjson(x::LazyValue)\n    try\n        skip(x)\n        return true\n    catch\n        return false\n    end\nend\n\n# convenience aliases for pre-1.0 JSON compat\nprint(io::IO, obj, indent=nothing) = json(io, obj; pretty=something(indent, 0))\nprint(a, indent=nothing) = print(stdout, a, indent)\n@doc (@doc json) print\n\n@compile_workload begin\n    x = JSON.parse(\"{\\\"a\\\": 1, \\\"b\\\": null, \\\"c\\\": true, \\\"d\\\": false, \\\"e\\\": \\\"\\\", \\\"f\\\": [1,null,true], \\\"g\\\": {\\\"key\\\": \\\"value\\\"}}\")\n    json = JSON.json(x)\n    isvalidjson(json)\nend\n\n\nend # module\n"}, "source_files_changed": ["src/JSON.jl"], "test_files_changed": [], "lines_changed": 4, "is_valid": true, "validation_errors": []}
{"repo": "JSON.jl", "commit_sha": "c065fc68395f43edc89a6170d24e9cc4cfd19016", "parent_sha": "ac467437609fd0a0e482f56349b4c4f39148f301", "commit_message": "Add new Null/Omit sentinels for overriding omit_null behavior per-field (#408)", "commit_date": "2025-11-14T07:06:50-07:00", "action": {"type": "ADD_METHOD", "target_file": "src/write.jl", "target_symbol": "StructUtils.structlike", "signature": null, "confidence": 0.85}, "files_before": {"src/write.jl": "struct JSONWriteStyle <: JSONStyle end\n\nsizeguess(::Nothing) = 4\nsizeguess(x::Bool) = 5\nsizeguess(x::Integer) = 20\nsizeguess(x::AbstractFloat) = 20\nsizeguess(x::Union{Float16, Float32, Float64}) = Base.Ryu.neededdigits(typeof(x))\nsizeguess(x::AbstractString) = 2 + sizeof(x)\nsizeguess(_) = 512\n\nStructUtils.lower(::JSONStyle, ::Missing) = nothing\nStructUtils.lower(::JSONStyle, x::Symbol) = String(x)\nStructUtils.lower(::JSONStyle, x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType, Type, Logging.LogLevel}) = string(x)\nStructUtils.lower(::JSONStyle, x::Regex) = x.pattern\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any,0}) = x[1]\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any, N}) where {N} = (view(x, ntuple(_ -> :, N - 1)..., j) for j in axes(x, N))\nStructUtils.lower(::JSONStyle, x::AbstractVector) = x\nStructUtils.arraylike(::JSONStyle, x::AbstractVector{<:Pair}) = false\n\n# for pre-1.0 compat, which serialized Tuple object keys by default\nStructUtils.lowerkey(::JSONStyle, x::Tuple) = string(x)\n\n\"\"\"\n    JSON.omit_null(::Type{T})::Bool\n    JSON.omit_null(::JSONStyle, ::Type{T})::Bool\n    \nControls whether struct fields that are undefined or are `nothing` are included in the JSON output.\nReturns `false` by default, meaning all fields are included, regardless of undef or `nothing`. To instead\nensure only *non-null* fields are written, set this to `true`.\nThis can also be controlled via the `omit_null` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_null(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_null(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_null(::Type{T}) where {T} = false\nomit_null(::JSONStyle, ::Type{T}) where {T} = omit_null(T)\n\n\"\"\"\n    @omit_null struct T ...\n    @omit_null T\n\nConvenience macro to set `omit_null(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_null struct T ... end`\n2. Applied to an existing struct name: `@omit_null T`\n3. Chained with other macros: `@omit_null @defaults struct T ... end`\n\nThe macro automatically handles complex macro expansions by walking the expression\ntree to find struct definitions, making it compatible with macros like `StructUtils.@defaults`.\n\n# Examples\n```julia\n# Method 1: Struct annotation\n@omit_null struct Person\n    name::String\n    email::Union{Nothing, String}\nend\n\n# Method 2: Apply to existing struct\nstruct User\n    id::Int\n    profile::Union{Nothing, String}\nend\n@omit_null User\n\n# Method 3: Chain with @defaults\n@omit_null @defaults struct Employee\n    name::String = \"Anonymous\"\n    manager::Union{Nothing, String} = nothing\nend\n```\n\"\"\"\nmacro omit_null(expr)\n    return _omit_macro_impl(expr, :omit_null, __module__)\nend\n\n\"\"\"\n    JSON.omit_empty(::Type{T})::Bool\n    JSON.omit_empty(::JSONStyle, ::Type{T})::Bool\n\nControls whether struct fields that are empty are included in the JSON output.\nReturns `false` by default, meaning empty fields *are* included. To instead exclude empty fields,\nset this to `true`. A field is considered empty if it is `nothing`, an empty collection\n(empty array, dict, string, tuple, or named tuple), or `missing`.\nThis can also be controlled via the `omit_empty` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_empty(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_empty(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_empty(::Type{T}) where {T} = false\nomit_empty(::JSONStyle, ::Type{T}) where {T} = omit_empty(T)\n\nis_empty(x) = false\nis_empty(::Nothing) = true\nis_empty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = Base.isempty(x)\n\n\"\"\"\n    @omit_empty struct T ...\n    @omit_empty T\n\nConvenience macro to set `omit_empty(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_empty struct T ... end`\n2. Applied to an existing struct name: `@omit_empty T`\n3. Chained with other macros: `@omit_empty @other_macro struct T ... end`\n\"\"\"\nmacro omit_empty(expr)\n    return _omit_macro_impl(expr, :omit_empty, __module__)\nend\n\n# Helper function for both @omit_null and @omit_empty macros\nfunction _omit_macro_impl(expr, omit_func_name, module_context)\n    original_expr = expr\n    expr = macroexpand(module_context, expr)\n    # Case 1: Just a type name (Symbol or more complex type expression)\n    if isa(expr, Symbol) || (Meta.isexpr(expr, :curly) || Meta.isexpr(expr, :where))\n        # Extract the base type name\n        T = _extract_type_name(expr)\n        return esc(quote\n            JSON.$omit_func_name(::Type{$T}) = true\n        end)\n    end\n    # Case 2: Struct definition (possibly from macro expansion)\n    if Meta.isexpr(expr, :struct)\n        ismutable, T, fieldsblock = expr.args\n        T = _extract_type_name(T)\n        return esc(quote\n            # insert original expr as-is\n            $expr\n            # omit function overload\n            JSON.$omit_func_name(::Type{$T}) = true\n        end)\n    end\n    # Case 3: Block expression (from complex macros like @defaults)\n    if Meta.isexpr(expr, :block)\n        # Try to find a struct definition in the block\n        struct_expr = _find_struct_in_block(expr)\n        if struct_expr !== nothing\n            ismutable, T, fieldsblock = struct_expr.args\n            T = _extract_type_name(T)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$T}) = true\n            end)\n        end\n    end\n    # Case 4: Macro expression that we hope expands to a struct\n    if Meta.isexpr(original_expr, :macrocall)\n        # Try to see if the expanded form is a struct\n        if Meta.isexpr(expr, :struct)\n            ismutable, T, fieldsblock = expr.args\n            T = _extract_type_name(T)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$T}) = true\n            end)\n        else\n            throw(ArgumentError(\"Macro $(original_expr.args[1]) did not expand to a struct definition\"))\n        end\n    end\n    throw(ArgumentError(\"Invalid usage of @$omit_func_name macro. Expected: struct definition, type name, or macro that expands to struct definition\"))\nend\n\n# Helper function to recursively find a struct definition in a block expression\nfunction _find_struct_in_block(expr)\n    if Meta.isexpr(expr, :struct)\n        return expr\n    elseif Meta.isexpr(expr, :block)\n        for arg in expr.args\n            result = _find_struct_in_block(arg)\n            if result !== nothing\n                return result\n            end\n        end\n    end\n    return nothing\nend\n\n# Helper function to extract the base type name from various type expressions\nfunction _extract_type_name(T)\n    if isa(T, Symbol)\n        return T\n    elseif Meta.isexpr(T, :<:)\n        # Handle subtyping: struct Foo <: Bar\n        return _extract_type_name(T.args[1])\n    elseif Meta.isexpr(T, :curly)\n        # Handle parametric types: keep the full parametric type Foo{T}\n        return T\n    elseif Meta.isexpr(T, :where)\n        # Handle where clauses: struct Foo{T} where T\n        return _extract_type_name(T.args[1])\n    else\n        return T\n    end\nend\n\nStructUtils.lowerkey(::JSONStyle, s::AbstractString) = s\nStructUtils.lowerkey(::JSONStyle, sym::Symbol) = String(sym)\nStructUtils.lowerkey(::JSONStyle, n::Union{Integer, Union{Float16, Float32, Float64}}) = string(n)\nStructUtils.lowerkey(::JSONStyle, x) = throw(ArgumentError(\"No key representation for $(typeof(x)). Define StructUtils.lowerkey(::$(typeof(x)))\"))\n\n\"\"\"\n    JSON.json(x) -> String\n    JSON.json(io, x)\n    JSON.json(file_name, x)\n\nSerialize `x` to JSON format. The 1st method takes just the object and returns a `String`.\nIn the 2nd method, `io` is an `IO` object, and the JSON output will be written to it.\nFor the 3rd method, `file_name` is a `String`, a file will be opened and the JSON output will be written to it.\n\nAll methods accept the following keyword arguments:\n\n- `omit_null::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are undefined or are `nothing` are included in the JSON output.\n  If `true`, only non-null fields are written. If `false`, all fields are included regardless of being undefined or `nothing`.\n  If `nothing`, the behavior is determined by `JSON.omit_null(::Type{T})`, which is `false` by default.\n\n- `omit_empty::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are empty are included in the JSON output.\n  If `true`, empty fields are excluded. If `false`, empty fields are included.\n  If `nothing`, the behavior is determined by `JSON.omit_empty(::Type{T})`.\n\n- `allownan::Bool=false`: If `true`, allow `Inf`, `-Inf`, and `NaN` in the output.\n  If `false`, throw an error if `Inf`, `-Inf`, or `NaN` is encountered.\n\n- `jsonlines::Bool=false`: If `true`, input must be array-like and the output will be written in the JSON Lines format,\n  where each element of the array is written on a separate line (i.e. separated by a single newline character `\\n`).\n  If `false`, the output will be written in the standard JSON format.\n\n- `pretty::Union{Integer,Bool}=false`: Controls pretty printing of the JSON output.\n  If `true`, the output will be pretty-printed with 2 spaces of indentation.\n  If an integer, it will be used as the number of spaces of indentation.\n  If `false` or `0`, the output will be compact.\n  Note: Pretty printing is not supported when `jsonlines=true`.\n\n- `inline_limit::Int=0`: For arrays shorter than this limit, pretty printing will be disabled (indentation set to 0).\n\n- `ninf::String=\"-Infinity\"`: Custom string representation for negative infinity.\n\n- `inf::String=\"Infinity\"`: Custom string representation for positive infinity.\n\n- `nan::String=\"NaN\"`: Custom string representation for NaN.\n\n- `float_style::Symbol=:shortest`: Controls how floating-point numbers are formatted.\n  Options are:\n  - `:shortest`: Use the shortest representation that preserves the value\n  - `:fixed`: Use fixed-point notation\n  - `:exp`: Use exponential notation\n\n- `float_precision::Int=1`: Number of decimal places to use when `float_style` is `:fixed` or `:exp`.\n\n- `bufsize::Int=2^22`: Buffer size in bytes for IO operations. When writing to IO, the buffer will be flushed \n  to the IO stream once it reaches this size. This helps control memory usage during large write operations.\n  Default is 4MB (2^22 bytes). This parameter is ignored when returning a String.\n\n- `style::JSONStyle=JSONWriteStyle()`: Custom style object that controls serialization behavior. This allows customizing\n    certain aspects of serialization, like defining a custom `lower` method for a non-owned type. Like `struct MyStyle <: JSONStyle end`,\n    `JSON.lower(x::Rational) = (num=x.num, den=x.den)`, then calling `JSON.json(1//3; style=MyStyle())` will output\n    `{\"num\": 1, \"den\": 3}`.\n\nBy default, `x` must be a JSON-serializable object. Supported types include:\n  * `AbstractString` => JSON string: types must support the `AbstractString` interface, specifically with support for\n    `ncodeunits` and `codeunit(x, i)`.\n  * `Bool` => JSON boolean: must be `true` or `false`\n  * `Nothing` => JSON null: must be the `nothing` singleton value\n  * `Number` => JSON number: `Integer` subtypes or `Union{Float16, Float32, Float64}` have default implementations\n    for other `Number` types, [`JSON.tostring`](@ref) is first called to convert\n    the value to a `String` before being written directly to JSON output\n  * `AbstractArray`/`Tuple`/`AbstractSet` => JSON array: objects for which `JSON.arraylike` returns `true`\n     are output as JSON arrays. `arraylike` is defined by default for\n    `AbstractArray`, `AbstractSet`, `Tuple`, and `Base.Generator`. For other types that define,\n    they must also properly implement `StructUtils.applyeach` to iterate over the index => elements pairs.\n    Note that arrays with dimensionality > 1 are written as nested arrays, with `N` nestings for `N` dimensions,\n    and the 1st dimension is always the innermost nested JSON array (column-major order).\n  * `AbstractDict`/`NamedTuple`/structs => JSON object: if a value doesn't fall into any of the above categories,\n    it is output as a JSON object. `StructUtils.applyeach` is called, which has appropriate implementations\n    for `AbstractDict`, `NamedTuple`, and structs, where field names => values are iterated over. Field names can\n    be output with an alternative name via field tag overload, like `field::Type &(json=(name=\"alternative_name\",),)`\n\nIf an object is not JSON-serializable, an override for `JSON.lower` can\nbe defined to convert it to a JSON-serializable object. Some default `lower` defintions\nare defined in JSON itself, for example:\n  * `StructUtils.lower(::Missing) = nothing`\n  * `StructUtils.lower(x::Symbol) = String(x)`\n  * `StructUtils.lower(x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType}) = string(x)`\n  * `StructUtils.lower(x::Regex) = x.pattern`\n\nThese allow common Base/stdlib types to be serialized in an expected format.\n\nCircular references are tracked automatically and cycles are broken by writing `null` for any children references.\n\nFor pre-formatted JSON data as a String, use `JSONText(json)` to write the string out as-is.\n\nFor `AbstractDict` objects with non-string keys, `StructUtils.lowerkey` will be called before serializing. This allows aggregate\nor other types of dict keys to be converted to an appropriate string representation. See `StructUtils.liftkey`\nfor the reverse operation, which is called when parsing JSON data back into a dict type.\n\n*NOTE*: `JSON.json` should _not_ be overloaded directly by custom\ntypes as this isn't robust for various output options (IO, String, etc.)\nnor recursive situations. Types should define an appropriate\n`JSON.lower` definition instead.\n\n*NOTE*: `JSON.json(str, indent::Integer)` is special-cased for backwards compatibility with pre-1.0 JSON.jl,\nas this typically would mean \"write out the `indent` integer to file `str`\". As writing out a single integer to\na file is extremely rare, it was decided to keep the pre-1.0 behavior for compatibility reasons.\n\nExamples:\n```julia\nusing Dates\n\nabstract type AbstractMonster end\n\nstruct Dracula <: AbstractMonster\n    num_victims::Int\nend\n\nstruct Werewolf <: AbstractMonster\n    witching_hour::DateTime\nend\n\nstruct Percent <: Number\n    value::Float64\nend\n\nJSON.lower(x::Percent) = x.value\nStructUtils.lowerkey(x::Percent) = string(x.value)\n\n@noarg mutable struct FrankenStruct\n    id::Int\n    name::String # no default to show serialization of an undefined field\n    address::Union{Nothing, String} = nothing\n    rate::Union{Missing, Float64} = missing\n    type::Symbol = :a &(json=(name=\"franken_type\",),)\n    notsure::Any = JSON.Object(\"key\" => \"value\")\n    monster::AbstractMonster = Dracula(10) &(json=(lower=x -> x isa Dracula ? (monster_type=\"vampire\", num_victims=x.num_victims) : (monster_type=\"werewolf\", witching_hour=x.witching_hour),),)\n    percent::Percent = Percent(0.5)\n    birthdate::Date = Date(2025, 1, 1) &(json=(dateformat=\"yyyy/mm/dd\",),)\n    percentages::Dict{Percent, Int} = Dict{Percent, Int}(Percent(0.0) => 0, Percent(1.0) => 1)\n    json_properties::JSONText = JSONText(\"{\\\"key\\\": \\\"value\\\"}\")\n    matrix::Matrix{Float64} = [1.0 2.0; 3.0 4.0]\n    extra_field::Any = nothing &(json=(ignore=true,),)\nend\n\nfranken = FrankenStruct()\nfranken.id = 1\n\njson = JSON.json(franken; omit_null=false)\n# \"{\\\"id\\\":1,\\\"name\\\":null,\\\"address\\\":null,\\\"rate\\\":null,\\\"franken_type\\\":\\\"a\\\",\\\"notsure\\\":{\\\"key\\\":\\\"value\\\"},\\\"monster\\\":{\\\"monster_type\\\":\\\"vampire\\\",\\\"num_victims\\\":10},\\\"percent\\\":0.5,\\\"birthdate\\\":\\\"2025/01/01\\\",\\\"percentages\\\":{\\\"1.0\\\":1,\\\"0.0\\\":0},\\\"json_properties\\\":{\\\"key\\\": \\\"value\\\"},\\\"matrix\\\":[[1.0,3.0],[2.0,4.0]]}\"\n```\n\nA few comments on the JSON produced in the example above:\n  - The `name` field was `#undef`, and thus was serialized as `null`.\n  - The `address` and `rate` fields were `nothing` and `missing`, respectively, and thus were serialized as `null`.\n  - The `type` field has a `name` field tag, so the JSON key for this field is `franken_type` instead of `type`.\n  - The `notsure` field is a `JSON.Object`, so it is serialized as a JSON object.\n  - The `monster` field is a `AbstractMonster`, which is a custom type. It has a `lower` field tag that specifies how the value of this field specifically (not all AbstractMonster) should be serialized\n  - The `percent` field is a `Percent`, which is a custom type. It has a `lower` method that specifies how `Percent` values should be serialized\n  - The `birthdate` field has a `dateformat` field tag, so the value follows the format (`yyyy/mm/dd`) instead of the default date ISO format (`yyyy-mm-dd`)\n  - The `percentages` field is a `Dict{Percent, Int}`, which is a custom type. It has a `lowerkey` method that specifies how `Percent` keys should be serialized as strings\n  - The `json_properties` field is a `JSONText`, so the JSONText value is serialized as-is\n  - The `matrix` field is a `Matrix{Float64}`, which is a custom type. It is serialized as a JSON array, with the first dimension being the innermost nested JSON array (column-major order)\n  - The `extra_field` field has a `ignore` field tag, so it is skipped when serializing\n\n\"\"\"\nfunction json end\n\n@kwdef struct WriteOptions{S}\n    omit_null::Union{Bool, Nothing} = nothing\n    omit_empty::Union{Bool, Nothing} = nothing\n    allownan::Bool = false\n    jsonlines::Bool = false\n    pretty::Int = 0\n    ninf::String = \"-Infinity\"\n    inf::String = \"Infinity\"\n    nan::String = \"NaN\"\n    inline_limit::Int = 0\n    float_style::Symbol = :shortest # :shortest, :fixed, :exp\n    float_precision::Int = 1\n    bufsize::Int = 2^22 # 4MB default buffer size for IO flushing\n    style::S = JSONWriteStyle()\nend\n\n@noinline float_style_throw(fs) = throw(ArgumentError(\"Invalid float style: $fs\"))\nfloat_style_check(fs) = fs == :shortest || fs == :fixed || fs == :exp || float_style_throw(fs)\n\n@noinline float_precision_throw(fs, fp) = throw(ArgumentError(\"float_precision must be positive when float_style is $fs; got $fp\"))\nfloat_precision_check(fs, fp) = (fs == :shortest || fp > 0) || float_precision_throw(fs, fp)\n\n# if jsonlines and pretty is not 0 or false, throw an ArgumentError\n@noinline _jsonlines_pretty_throw() = throw(ArgumentError(\"pretty printing is not supported when writing jsonlines\"))\n_jsonlines_pretty_check(jsonlines, pretty) = jsonlines && pretty !== false && !iszero(pretty) && _jsonlines_pretty_throw()\n\nfunction json(io::IO, x::T; pretty::Union{Integer,Bool}=false, kw...) where {T}\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    # Use smaller initial buffer size, limited by bufsize\n    initial_size = min(sizeguess(y), opts.bufsize)\n    buf = Vector{UInt8}(undef, initial_size)\n    pos = json!(buf, 1, y, opts, Any[y], io)\n    # Write any remaining buffer contents to IO\n    if pos > 1\n        write(io, view(buf, 1:pos-1))\n    end\n    return nothing\nend\n\nif isdefined(Base, :StringVector)\n    stringvec(n) = Base.StringVector(n)\nelse\n    stringvec(n) = Vector{UInt8}(undef, n)\nend\n\nfunction json(x; pretty::Union{Integer,Bool}=false, kw...)\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    buf = stringvec(sizeguess(y))\n    pos = json!(buf, 1, y, opts, Any[y], nothing)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction json(fname, obj; kw...)\n    if obj isa Integer\n        # special-case for pre-1.0 JSON compat\n        return json(fname; pretty=obj)\n    else\n        @assert fname isa AbstractString \"filename must be a string\"\n    end\n    open(fname, \"w\") do io\n        json(io, obj; kw...)\n    end\n    return fname\nend\n\n# we use the same growth strategy as Base julia does for array growing\n# which starts with small N at ~5x and approaches 1.125x as N grows\n# ref: https://github.com/JuliaLang/julia/pull/40453\nnewlen(n\u2080) = ceil(Int, n\u2080 + 4*n\u2080^(7 / 8) + n\u2080 / 8)\n\nmacro checkn(n, force_resize=false)\n    esc(quote\n        if (pos + $n - 1) > length(buf)\n            # If we have an IO object and buffer would exceed bufsize, flush to IO first\n            # unless force_resize is true (used for comma writing to avoid flushing partial JSON)\n            if io !== nothing && length(buf) >= bufsize && pos > 1 && !$force_resize\n                write(io, view(buf, 1:pos-1))\n                pos = 1\n            end\n            # Resize buffer if still needed\n            if (pos + $n - 1) > length(buf)\n                resize!(buf, newlen(pos + $n))\n            end\n        end\n    end)\nend\n\nstruct WriteClosure{JS, arraylike, T, I} # T is the type of the parent object/array being written\n    buf::Vector{UInt8}\n    pos::Ptr{Int}\n    wroteany::Ptr{Bool} # to track if we wrote any data to the buffer\n    indent::Int\n    depth::Int\n    opts::JS\n    ancestor_stack::Vector{Any} # to track circular references\n    io::I\n    bufsize::Int\nend\n\nfunction indent(buf, pos, ind, depth, io, bufsize)\n    if ind > 0\n        n = ind * depth + 1\n        @checkn n\n        buf[pos] = UInt8('\\n')\n        for i = 1:(n - 1)\n            buf[pos + i] = UInt8(' ')\n        end\n        pos += n\n    end\n    return pos\nend\n\ncheckkey(s) = s isa AbstractString || throw(ArgumentError(\"Value returned from `StructUtils.lowerkey` must be a string: $(typeof(s))\"))\n\nfunction (f::WriteClosure{JS, arraylike, T, I})(key, val) where {JS, arraylike, T, I}\n    track_ref = ismutabletype(typeof(val))\n    is_circ_ref = track_ref && any(x -> x === val, f.ancestor_stack)\n    if !arraylike\n        # for objects, check omit_null/omit_empty\n        # and skip if the value is null or empty\n        if f.opts.omit_null === true || (f.opts.omit_null === nothing && omit_null(f.opts.style, T))\n            (is_circ_ref || val === nothing) && return\n        end\n        if f.opts.omit_empty === true || (f.opts.omit_empty === nothing && omit_empty(f.opts.style, T))\n            (is_circ_ref || is_empty(val)) && return\n        end\n    end\n    pos = unsafe_load(f.pos)\n    unsafe_store!(f.wroteany, true) # at this point, we know something will be written\n    buf = f.buf\n    ind = f.indent\n    io = f.io\n    bufsize = f.bufsize\n    pos = indent(buf, pos, ind, f.depth, io, bufsize)\n    # if not an array, we need to write the key + ':'\n    if !arraylike\n        # skey = StructUtils.lowerkey(f.opts, key)\n        # check if the key is a string\n        checkkey(key)\n        pos = _string(buf, pos, key, io, bufsize)\n        @checkn 1\n        buf[pos] = UInt8(':')\n        pos += 1\n        if ind > 0\n            @checkn 1\n            buf[pos] = UInt8(' ')\n            pos += 1\n        end\n    end\n    # check if the lowered value is in our ancestor stack\n    if is_circ_ref\n        # if so, it's a circular reference! so we just write `null`\n        pos = _null(buf, pos, io, bufsize)\n    else\n        track_ref && push!(f.ancestor_stack, val)\n        # if jsonlines, we need to recursively set to false\n        if f.opts.jsonlines\n            opts = WriteOptions(; omit_null=f.opts.omit_null, omit_empty=f.opts.omit_empty, allownan=f.opts.allownan, jsonlines=false, pretty=f.opts.pretty, ninf=f.opts.ninf, inf=f.opts.inf, nan=f.opts.nan, inline_limit=f.opts.inline_limit, float_style=f.opts.float_style, float_precision=f.opts.float_precision)\n        else\n            opts = f.opts\n        end\n        pos = json!(buf, pos, val, opts, f.ancestor_stack, io, ind, f.depth, bufsize)\n        track_ref && pop!(f.ancestor_stack)\n    end\n    @checkn 1 true\n    @inbounds buf[pos] = f.opts.jsonlines ? UInt8('\\n') : UInt8(',')\n    pos += 1\n    # store our updated pos\n    unsafe_store!(f.pos, pos)\n    return\nend\n\n@noinline throwjsonlines() = throw(ArgumentError(\"jsonlines only supported for arraylike\"))\n\n# assume x is lowered value\nfunction json!(buf, pos, x, opts::WriteOptions, ancestor_stack::Union{Nothing, Vector{Any}}=nothing, io::Union{Nothing, IO}=nothing, ind::Int=opts.pretty, depth::Int=0, bufsize::Int=opts.bufsize)\n    # string\n    if x isa AbstractString\n        return _string(buf, pos, x, io, bufsize)\n    # write JSONText out directly\n    elseif x isa JSONText\n        val = x.value\n        @checkn sizeof(val)\n        for i = 1:sizeof(val)\n            @inbounds buf[pos + i - 1] = codeunit(val, i)\n        end\n        return pos + sizeof(val)\n    # bool; check before Number since Bool <: Number\n    elseif x isa Bool\n        if x\n            @checkn 4\n            @inbounds buf[pos] = 't'\n            @inbounds buf[pos + 1] = 'r'\n            @inbounds buf[pos + 2] = 'u'\n            @inbounds buf[pos + 3] = 'e'\n            return pos + 4\n        else\n            @checkn 5\n            @inbounds buf[pos] = 'f'\n            @inbounds buf[pos + 1] = 'a'\n            @inbounds buf[pos + 2] = 'l'\n            @inbounds buf[pos + 3] = 's'\n            @inbounds buf[pos + 4] = 'e'\n            return pos + 5\n        end\n    # number\n    elseif x isa Number\n        return _number(buf, pos, x, opts, io, bufsize)\n    # null\n    elseif x === nothing\n        return _null(buf, pos, io, bufsize)\n    # object or array\n    elseif StructUtils.dictlike(opts.style, x) || StructUtils.arraylike(opts.style, x) || StructUtils.structlike(opts.style, x)\n        al = StructUtils.arraylike(opts.style, x)\n        # override pretty indent to 0 for arrays shorter than inline_limit\n        if al && opts.pretty > 0 && opts.inline_limit > 0 && length(x) < opts.inline_limit\n            local_ind = 0\n        else\n            local_ind = ind\n        end\n        if !opts.jsonlines\n            @checkn 1\n            @inbounds buf[pos] = al ? UInt8('[') : UInt8('{')\n            pos += 1\n        else\n            al || throwjsonlines()\n        end\n        ref = Ref(pos)\n        wroteany = false\n        wroteanyref = Ref(false)\n        GC.@preserve ref wroteanyref begin\n            c = WriteClosure{typeof(opts), al, typeof(x), typeof(io)}(buf, Base.unsafe_convert(Ptr{Int}, ref), Base.unsafe_convert(Ptr{Bool}, wroteanyref), local_ind, depth + 1, opts, ancestor_stack, io, bufsize)\n            StructUtils.applyeach(opts.style, c, x)\n            # get updated pos\n            pos = unsafe_load(c.pos)\n            wroteany = unsafe_load(c.wroteany)\n        end\n        # in WriteClosure, we eagerly write a comma after each element\n        # so for non-empty object/arrays, we can just overwrite the last comma with the closechar\n        if wroteany\n            pos -= 1\n            pos = indent(buf, pos, local_ind, depth, io, bufsize)\n        end\n        # even if the input is empty and we're jsonlines, the spec says it's ok to end w/ a newline\n        @checkn 1\n        @inbounds buf[pos] = opts.jsonlines ? UInt8('\\n') : al ? UInt8(']') : UInt8('}')\n        return pos + 1\n    else\n        return _string(buf, pos, x, io, bufsize)\n    end\nend\n\nfunction _null(buf, pos, io, bufsize)\n    @checkn 4\n    @inbounds buf[pos] = 'n'\n    @inbounds buf[pos + 1] = 'u'\n    @inbounds buf[pos + 2] = 'l'\n    @inbounds buf[pos + 3] = 'l'\n    return pos + 4\nend\n\n_string(buf, pos, x, io, bufsize) = _string(buf, pos, string(x), io, bufsize)\n_string(buf, pos, x::LazyValues, io, bufsize) = _string(buf, pos, getindex(x), io, bufsize)\n_string(buf, pos, x::PtrString, io, bufsize) = _string(buf, pos, convert(String, x), io, bufsize)\n\nfunction _string(buf, pos, x::AbstractString, io, bufsize)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @checkn (el + 2)\n    @inbounds buf[pos] = UInt8('\"')\n    pos += 1\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds buf[pos] = UInt8('\"')\n    return pos + 1\nend\n\n\"\"\"\n    JSON.tostring(x)\n\nOverloadable function that allows non-`Integer` `Number` types\nto convert themselves to a `String` that is then used\nwhen serializing `x` to JSON. Note that if the result of `tostring`\nis not a valid JSON number, it will be serialized as a JSON string,\nwith double quotes around it.\n\nAn example overload would look something like:\n```julia\nJSON.tostring(x::MyDecimal) = string(x)\n```\n\"\"\"\ntostring(x) = string(Float64(x))\n\nsplit_sign(n::Integer) = unsigned(abs(n)), n < 0\nsplit_sign(n::Unsigned) = n, false\nsplit_sign(x::BigInt) = (abs(x), x < 0)\n\n@noinline infcheck(x, allownan) = isfinite(x) || allownan || throw(ArgumentError(\"$x not allowed to be written in JSON spec; pass `allownan=true` to allow anyway\"))\n\nfunction _number(buf, pos, x::Number, opts::WriteOptions, io, bufsize)\n    if x isa Integer\n        y, neg = split_sign(x)\n        n = i = ndigits(y, base=10, pad=1)\n        @checkn (i + neg)\n        if neg\n            @inbounds buf[pos] = UInt8('-')\n            pos += 1\n        end\n        while i > 0\n            @inbounds buf[pos + i - 1] = 48 + rem(y, 10)\n            y = oftype(y, div(y, 10))\n            i -= 1\n        end\n        return pos + n\n    elseif x isa Union{Float16, Float32, Float64}\n        infcheck(x, opts.allownan)\n        if isnan(x)\n            nan = opts.nan\n            @checkn sizeof(nan)\n            for i = 1:sizeof(nan)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(nan, i))\n            end\n            return pos + sizeof(nan)\n        elseif isinf(x)\n            if x < 0\n                inf = opts.ninf\n            else\n                inf = opts.inf\n            end\n            @checkn sizeof(inf)\n            for i = 1:sizeof(inf)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(inf, i))\n            end\n            return pos + sizeof(inf)\n        end\n        if opts.float_style == :shortest\n            @checkn Base.Ryu.neededdigits(typeof(x))\n            return Base.Ryu.writeshortest(buf, pos, x)\n        elseif opts.float_style == :fixed\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writefixed(buf, pos, x, opts.float_precision, false, false, true)\n        elseif opts.float_style == :exp\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writeexp(buf, pos, x, opts.float_precision, false, false, true)\n        else\n            # unreachable as we validate float_style inputs\n            @assert false\n        end\n    else\n        str = tostring(x)\n        if anyinvalidnumberchars(str)\n            # serialize as string\n            return _string(buf, pos, str, io, bufsize)\n        end\n        bytes = codeunits(str)\n        sz = sizeof(bytes)\n        @checkn sz\n        for i = 1:sz\n            @inbounds buf[pos + i - 1] = bytes[i]\n        end\n        return pos + sz\n    end\nend\n\nfunction anyinvalidnumberchars(x)\n    for i = 1:sizeof(x)\n        b = codeunit(x, i)\n        if !(b == UInt8('-') || b == UInt8('.') || b == UInt8('e') || b == UInt8('E') ||\n            UInt8('0') <= b <= UInt8('9'))\n            return true\n        end\n    end\n    return false\nend\n"}, "files_after": {"src/write.jl": "struct JSONWriteStyle <: JSONStyle end\n\n\"\"\"\n    JSON.Null()\n\nSingleton sentinel that always serializes as the JSON literal `null`,\neven when `omit_null=true` at the struct or callsite level. Useful for\nper-field overrides (e.g. `Union{Nothing, JSON.Null}`) or custom field\nlowering that must force a `null` emission.\n\"\"\"\nstruct Null end\n\n\"\"\"\n    JSON.Omit()\n\nSingleton sentinel that removes the enclosing value from the JSON output,\nregardless of `omit_null` / `omit_empty` settings. Valid within objects\nand arrays; using it as the root value throws an error.\n\"\"\"\nstruct Omit end\n\nsizeguess(::Nothing) = 4\nsizeguess(x::Bool) = 5\nsizeguess(x::Integer) = 20\nsizeguess(x::AbstractFloat) = 20\nsizeguess(x::Union{Float16, Float32, Float64}) = Base.Ryu.neededdigits(typeof(x))\nsizeguess(x::AbstractString) = 2 + sizeof(x)\nsizeguess(::Null) = 4\nsizeguess(::Omit) = 0\nsizeguess(_) = 512\n\nStructUtils.lower(::JSONStyle, ::Missing) = nothing\nStructUtils.lower(::JSONStyle, x::Symbol) = String(x)\nStructUtils.lower(::JSONStyle, x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType, Type, Logging.LogLevel}) = string(x)\nStructUtils.lower(::JSONStyle, x::Regex) = x.pattern\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any,0}) = x[1]\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any, N}) where {N} = (view(x, ntuple(_ -> :, N - 1)..., j) for j in axes(x, N))\nStructUtils.lower(::JSONStyle, x::AbstractVector) = x\nStructUtils.arraylike(::JSONStyle, x::AbstractVector{<:Pair}) = false\nStructUtils.structlike(::JSONStyle, ::Type{<:NamedTuple}) = true\n\n# for pre-1.0 compat, which serialized Tuple object keys by default\nStructUtils.lowerkey(::JSONStyle, x::Tuple) = string(x)\n\n\"\"\"\n    JSON.omit_null(::Type{T})::Bool\n    JSON.omit_null(::JSONStyle, ::Type{T})::Bool\n    \nControls whether struct fields that are undefined or are `nothing` are included in the JSON output.\nReturns `false` by default, meaning all fields are included, regardless of undef or `nothing`. To instead\nensure only *non-null* fields are written, set this to `true`.\nThis can also be controlled via the `omit_null` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_null(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_null(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_null(::Type{T}) where {T} = false\nomit_null(::JSONStyle, ::Type{T}) where {T} = omit_null(T)\n\n\"\"\"\n    @omit_null struct T ...\n    @omit_null T\n\nConvenience macro to set `omit_null(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_null struct T ... end`\n2. Applied to an existing struct name: `@omit_null T`\n3. Chained with other macros: `@omit_null @defaults struct T ... end`\n\nThe macro automatically handles complex macro expansions by walking the expression\ntree to find struct definitions, making it compatible with macros like `StructUtils.@defaults`.\n\n# Examples\n```julia\n# Method 1: Struct annotation\n@omit_null struct Person\n    name::String\n    email::Union{Nothing, String}\nend\n\n# Method 2: Apply to existing struct\nstruct User\n    id::Int\n    profile::Union{Nothing, String}\nend\n@omit_null User\n\n# Method 3: Chain with @defaults\n@omit_null @defaults struct Employee\n    name::String = \"Anonymous\"\n    manager::Union{Nothing, String} = nothing\nend\n```\n\"\"\"\nmacro omit_null(expr)\n    return _omit_macro_impl(expr, :omit_null, __module__)\nend\n\n\"\"\"\n    JSON.omit_empty(::Type{T})::Bool\n    JSON.omit_empty(::JSONStyle, ::Type{T})::Bool\n\nControls whether struct fields that are empty are included in the JSON output.\nReturns `false` by default, meaning empty fields *are* included. To instead exclude empty fields,\nset this to `true`. A field is considered empty if it is `nothing`, an empty collection\n(empty array, dict, string, tuple, or named tuple), or `missing`.\nThis can also be controlled via the `omit_empty` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_empty(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_empty(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_empty(::Type{T}) where {T} = false\nomit_empty(::JSONStyle, ::Type{T}) where {T} = omit_empty(T)\n\nis_empty(x) = false\nis_empty(::Nothing) = true\nis_empty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = Base.isempty(x)\n\n\"\"\"\n    @omit_empty struct T ...\n    @omit_empty T\n\nConvenience macro to set `omit_empty(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_empty struct T ... end`\n2. Applied to an existing struct name: `@omit_empty T`\n3. Chained with other macros: `@omit_empty @other_macro struct T ... end`\n\"\"\"\nmacro omit_empty(expr)\n    return _omit_macro_impl(expr, :omit_empty, __module__)\nend\n\n# Helper function for both @omit_null and @omit_empty macros\nfunction _omit_macro_impl(expr, omit_func_name, module_context)\n    original_expr = expr\n    expr = macroexpand(module_context, expr)\n    # Case 1: Just a type name (Symbol or more complex type expression)\n    if isa(expr, Symbol) || (Meta.isexpr(expr, :curly) || Meta.isexpr(expr, :where))\n        # Extract the base type name\n        T = _extract_type_name(expr)\n        return esc(quote\n            JSON.$omit_func_name(::Type{$T}) = true\n        end)\n    end\n    # Case 2: Struct definition (possibly from macro expansion)\n    if Meta.isexpr(expr, :struct)\n        ismutable, T, fieldsblock = expr.args\n        T = _extract_type_name(T)\n        return esc(quote\n            # insert original expr as-is\n            $expr\n            # omit function overload\n            JSON.$omit_func_name(::Type{$T}) = true\n        end)\n    end\n    # Case 3: Block expression (from complex macros like @defaults)\n    if Meta.isexpr(expr, :block)\n        # Try to find a struct definition in the block\n        struct_expr = _find_struct_in_block(expr)\n        if struct_expr !== nothing\n            ismutable, T, fieldsblock = struct_expr.args\n            T = _extract_type_name(T)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$T}) = true\n            end)\n        end\n    end\n    # Case 4: Macro expression that we hope expands to a struct\n    if Meta.isexpr(original_expr, :macrocall)\n        # Try to see if the expanded form is a struct\n        if Meta.isexpr(expr, :struct)\n            ismutable, T, fieldsblock = expr.args\n            T = _extract_type_name(T)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$T}) = true\n            end)\n        else\n            throw(ArgumentError(\"Macro $(original_expr.args[1]) did not expand to a struct definition\"))\n        end\n    end\n    throw(ArgumentError(\"Invalid usage of @$omit_func_name macro. Expected: struct definition, type name, or macro that expands to struct definition\"))\nend\n\n# Helper function to recursively find a struct definition in a block expression\nfunction _find_struct_in_block(expr)\n    if Meta.isexpr(expr, :struct)\n        return expr\n    elseif Meta.isexpr(expr, :block)\n        for arg in expr.args\n            result = _find_struct_in_block(arg)\n            if result !== nothing\n                return result\n            end\n        end\n    end\n    return nothing\nend\n\n# Helper function to extract the base type name from various type expressions\nfunction _extract_type_name(T)\n    if isa(T, Symbol)\n        return T\n    elseif Meta.isexpr(T, :<:)\n        # Handle subtyping: struct Foo <: Bar\n        return _extract_type_name(T.args[1])\n    elseif Meta.isexpr(T, :curly)\n        # Handle parametric types: keep the full parametric type Foo{T}\n        return T\n    elseif Meta.isexpr(T, :where)\n        # Handle where clauses: struct Foo{T} where T\n        return _extract_type_name(T.args[1])\n    else\n        return T\n    end\nend\n\nStructUtils.lowerkey(::JSONStyle, s::AbstractString) = s\nStructUtils.lowerkey(::JSONStyle, sym::Symbol) = String(sym)\nStructUtils.lowerkey(::JSONStyle, n::Union{Integer, Union{Float16, Float32, Float64}}) = string(n)\nStructUtils.lowerkey(::JSONStyle, x) = throw(ArgumentError(\"No key representation for $(typeof(x)). Define StructUtils.lowerkey(::$(typeof(x)))\"))\n\n\"\"\"\n    JSON.json(x) -> String\n    JSON.json(io, x)\n    JSON.json(file_name, x)\n\nSerialize `x` to JSON format. The 1st method takes just the object and returns a `String`.\nIn the 2nd method, `io` is an `IO` object, and the JSON output will be written to it.\nFor the 3rd method, `file_name` is a `String`, a file will be opened and the JSON output will be written to it.\n\nAll methods accept the following keyword arguments:\n\n- `omit_null::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are undefined or are `nothing` are included in the JSON output.\n  If `true`, only non-null fields are written. If `false`, all fields are included regardless of being undefined or `nothing`.\n  If `nothing`, the behavior is determined by `JSON.omit_null(::Type{T})`, which is `false` by default.\n\n- `omit_empty::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are empty are included in the JSON output.\n  If `true`, empty fields are excluded. If `false`, empty fields are included.\n  If `nothing`, the behavior is determined by `JSON.omit_empty(::Type{T})`.\n\n- `JSON.Null()` / `JSON.Omit()` sentinels: `JSON.Null()` always emits a JSON `null`\n  literal even when `omit_null=true`, enabling per-field overrides (for example by\n  declaring a field as `Union{Nothing, JSON.Null}`) or defining a custom `lower` function for a field that returns `JSON.Null`.\n  `JSON.Omit()` removes the enclosing value from the output regardless of global omit settings, making it easy for field-level\n  lowering code to drop optional data entirely. For example, by defining a custom `lower` function for a field that returns `JSON.Omit`.\n    \n- `allownan::Bool=false`: If `true`, allow `Inf`, `-Inf`, and `NaN` in the output.\n  If `false`, throw an error if `Inf`, `-Inf`, or `NaN` is encountered.\n\n- `jsonlines::Bool=false`: If `true`, input must be array-like and the output will be written in the JSON Lines format,\n  where each element of the array is written on a separate line (i.e. separated by a single newline character `\\n`).\n  If `false`, the output will be written in the standard JSON format.\n\n- `pretty::Union{Integer,Bool}=false`: Controls pretty printing of the JSON output.\n  If `true`, the output will be pretty-printed with 2 spaces of indentation.\n  If an integer, it will be used as the number of spaces of indentation.\n  If `false` or `0`, the output will be compact.\n  Note: Pretty printing is not supported when `jsonlines=true`.\n\n- `inline_limit::Int=0`: For arrays shorter than this limit, pretty printing will be disabled (indentation set to 0).\n\n- `ninf::String=\"-Infinity\"`: Custom string representation for negative infinity.\n\n- `inf::String=\"Infinity\"`: Custom string representation for positive infinity.\n\n- `nan::String=\"NaN\"`: Custom string representation for NaN.\n\n- `float_style::Symbol=:shortest`: Controls how floating-point numbers are formatted.\n  Options are:\n  - `:shortest`: Use the shortest representation that preserves the value\n  - `:fixed`: Use fixed-point notation\n  - `:exp`: Use exponential notation\n\n- `float_precision::Int=1`: Number of decimal places to use when `float_style` is `:fixed` or `:exp`.\n\n- `bufsize::Int=2^22`: Buffer size in bytes for IO operations. When writing to IO, the buffer will be flushed \n  to the IO stream once it reaches this size. This helps control memory usage during large write operations.\n  Default is 4MB (2^22 bytes). This parameter is ignored when returning a String.\n\n- `style::JSONStyle=JSONWriteStyle()`: Custom style object that controls serialization behavior. This allows customizing\n    certain aspects of serialization, like defining a custom `lower` method for a non-owned type. Like `struct MyStyle <: JSONStyle end`,\n    `JSON.lower(x::Rational) = (num=x.num, den=x.den)`, then calling `JSON.json(1//3; style=MyStyle())` will output\n    `{\"num\": 1, \"den\": 3}`.\n\nBy default, `x` must be a JSON-serializable object. Supported types include:\n  * `AbstractString` => JSON string: types must support the `AbstractString` interface, specifically with support for\n    `ncodeunits` and `codeunit(x, i)`.\n  * `Bool` => JSON boolean: must be `true` or `false`\n  * `Nothing` => JSON null: must be the `nothing` singleton value\n  * `Number` => JSON number: `Integer` subtypes or `Union{Float16, Float32, Float64}` have default implementations\n    for other `Number` types, [`JSON.tostring`](@ref) is first called to convert\n    the value to a `String` before being written directly to JSON output\n  * `AbstractArray`/`Tuple`/`AbstractSet` => JSON array: objects for which `JSON.arraylike` returns `true`\n     are output as JSON arrays. `arraylike` is defined by default for\n    `AbstractArray`, `AbstractSet`, `Tuple`, and `Base.Generator`. For other types that define,\n    they must also properly implement `StructUtils.applyeach` to iterate over the index => elements pairs.\n    Note that arrays with dimensionality > 1 are written as nested arrays, with `N` nestings for `N` dimensions,\n    and the 1st dimension is always the innermost nested JSON array (column-major order).\n  * `AbstractDict`/`NamedTuple`/structs => JSON object: if a value doesn't fall into any of the above categories,\n    it is output as a JSON object. `StructUtils.applyeach` is called, which has appropriate implementations\n    for `AbstractDict`, `NamedTuple`, and structs, where field names => values are iterated over. Field names can\n    be output with an alternative name via field tag overload, like `field::Type &(json=(name=\"alternative_name\",),)`\n\nIf an object is not JSON-serializable, an override for `JSON.lower` can\nbe defined to convert it to a JSON-serializable object. Some default `lower` defintions\nare defined in JSON itself, for example:\n  * `StructUtils.lower(::Missing) = nothing`\n  * `StructUtils.lower(x::Symbol) = String(x)`\n  * `StructUtils.lower(x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType}) = string(x)`\n  * `StructUtils.lower(x::Regex) = x.pattern`\n\nThese allow common Base/stdlib types to be serialized in an expected format.\n\nCircular references are tracked automatically and cycles are broken by writing `null` for any children references.\n\nFor pre-formatted JSON data as a String, use `JSONText(json)` to write the string out as-is.\n\nFor `AbstractDict` objects with non-string keys, `StructUtils.lowerkey` will be called before serializing. This allows aggregate\nor other types of dict keys to be converted to an appropriate string representation. See `StructUtils.liftkey`\nfor the reverse operation, which is called when parsing JSON data back into a dict type.\n\n*NOTE*: `JSON.json` should _not_ be overloaded directly by custom\ntypes as this isn't robust for various output options (IO, String, etc.)\nnor recursive situations. Types should define an appropriate\n`JSON.lower` definition instead.\n\n*NOTE*: `JSON.json(str, indent::Integer)` is special-cased for backwards compatibility with pre-1.0 JSON.jl,\nas this typically would mean \"write out the `indent` integer to file `str`\". As writing out a single integer to\na file is extremely rare, it was decided to keep the pre-1.0 behavior for compatibility reasons.\n\nExamples:\n```julia\nusing Dates\n\nabstract type AbstractMonster end\n\nstruct Dracula <: AbstractMonster\n    num_victims::Int\nend\n\nstruct Werewolf <: AbstractMonster\n    witching_hour::DateTime\nend\n\nstruct Percent <: Number\n    value::Float64\nend\n\nJSON.lower(x::Percent) = x.value\nStructUtils.lowerkey(x::Percent) = string(x.value)\n\n@noarg mutable struct FrankenStruct\n    id::Int\n    name::String # no default to show serialization of an undefined field\n    address::Union{Nothing, String} = nothing\n    rate::Union{Missing, Float64} = missing\n    type::Symbol = :a &(json=(name=\"franken_type\",),)\n    notsure::Any = JSON.Object(\"key\" => \"value\")\n    monster::AbstractMonster = Dracula(10) &(json=(lower=x -> x isa Dracula ? (monster_type=\"vampire\", num_victims=x.num_victims) : (monster_type=\"werewolf\", witching_hour=x.witching_hour),),)\n    percent::Percent = Percent(0.5)\n    birthdate::Date = Date(2025, 1, 1) &(json=(dateformat=\"yyyy/mm/dd\",),)\n    percentages::Dict{Percent, Int} = Dict{Percent, Int}(Percent(0.0) => 0, Percent(1.0) => 1)\n    json_properties::JSONText = JSONText(\"{\\\"key\\\": \\\"value\\\"}\")\n    matrix::Matrix{Float64} = [1.0 2.0; 3.0 4.0]\n    extra_field::Any = nothing &(json=(ignore=true,),)\nend\n\nfranken = FrankenStruct()\nfranken.id = 1\n\njson = JSON.json(franken; omit_null=false)\n# \"{\\\"id\\\":1,\\\"name\\\":null,\\\"address\\\":null,\\\"rate\\\":null,\\\"franken_type\\\":\\\"a\\\",\\\"notsure\\\":{\\\"key\\\":\\\"value\\\"},\\\"monster\\\":{\\\"monster_type\\\":\\\"vampire\\\",\\\"num_victims\\\":10},\\\"percent\\\":0.5,\\\"birthdate\\\":\\\"2025/01/01\\\",\\\"percentages\\\":{\\\"1.0\\\":1,\\\"0.0\\\":0},\\\"json_properties\\\":{\\\"key\\\": \\\"value\\\"},\\\"matrix\\\":[[1.0,3.0],[2.0,4.0]]}\"\n```\n\nA few comments on the JSON produced in the example above:\n  - The `name` field was `#undef`, and thus was serialized as `null`.\n  - The `address` and `rate` fields were `nothing` and `missing`, respectively, and thus were serialized as `null`.\n  - The `type` field has a `name` field tag, so the JSON key for this field is `franken_type` instead of `type`.\n  - The `notsure` field is a `JSON.Object`, so it is serialized as a JSON object.\n  - The `monster` field is a `AbstractMonster`, which is a custom type. It has a `lower` field tag that specifies how the value of this field specifically (not all AbstractMonster) should be serialized\n  - The `percent` field is a `Percent`, which is a custom type. It has a `lower` method that specifies how `Percent` values should be serialized\n  - The `birthdate` field has a `dateformat` field tag, so the value follows the format (`yyyy/mm/dd`) instead of the default date ISO format (`yyyy-mm-dd`)\n  - The `percentages` field is a `Dict{Percent, Int}`, which is a custom type. It has a `lowerkey` method that specifies how `Percent` keys should be serialized as strings\n  - The `json_properties` field is a `JSONText`, so the JSONText value is serialized as-is\n  - The `matrix` field is a `Matrix{Float64}`, which is a custom type. It is serialized as a JSON array, with the first dimension being the innermost nested JSON array (column-major order)\n  - The `extra_field` field has a `ignore` field tag, so it is skipped when serializing\n\n\"\"\"\nfunction json end\n\n@kwdef struct WriteOptions{S}\n    omit_null::Union{Bool, Nothing} = nothing\n    omit_empty::Union{Bool, Nothing} = nothing\n    allownan::Bool = false\n    jsonlines::Bool = false\n    pretty::Int = 0\n    ninf::String = \"-Infinity\"\n    inf::String = \"Infinity\"\n    nan::String = \"NaN\"\n    inline_limit::Int = 0\n    float_style::Symbol = :shortest # :shortest, :fixed, :exp\n    float_precision::Int = 1\n    bufsize::Int = 2^22 # 4MB default buffer size for IO flushing\n    style::S = JSONWriteStyle()\nend\n\n@noinline float_style_throw(fs) = throw(ArgumentError(\"Invalid float style: $fs\"))\nfloat_style_check(fs) = fs == :shortest || fs == :fixed || fs == :exp || float_style_throw(fs)\n\n@noinline float_precision_throw(fs, fp) = throw(ArgumentError(\"float_precision must be positive when float_style is $fs; got $fp\"))\nfloat_precision_check(fs, fp) = (fs == :shortest || fp > 0) || float_precision_throw(fs, fp)\n\n# if jsonlines and pretty is not 0 or false, throw an ArgumentError\n@noinline _jsonlines_pretty_throw() = throw(ArgumentError(\"pretty printing is not supported when writing jsonlines\"))\n_jsonlines_pretty_check(jsonlines, pretty) = jsonlines && pretty !== false && !iszero(pretty) && _jsonlines_pretty_throw()\n@noinline _root_omit_throw() = throw(ArgumentError(\"JSON.Omit() is only valid inside arrays or objects\"))\n\nfunction json(io::IO, x::T; pretty::Union{Integer,Bool}=false, kw...) where {T}\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    # Use smaller initial buffer size, limited by bufsize\n    initial_size = min(sizeguess(y), opts.bufsize)\n    buf = Vector{UInt8}(undef, initial_size)\n    pos = json!(buf, 1, y, opts, Any[y], io)\n    # Write any remaining buffer contents to IO\n    if pos > 1\n        write(io, view(buf, 1:pos-1))\n    end\n    return nothing\nend\n\nif isdefined(Base, :StringVector)\n    stringvec(n) = Base.StringVector(n)\nelse\n    stringvec(n) = Vector{UInt8}(undef, n)\nend\n\nfunction json(x; pretty::Union{Integer,Bool}=false, kw...)\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    buf = stringvec(sizeguess(y))\n    pos = json!(buf, 1, y, opts, Any[y], nothing)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction json(fname, obj; kw...)\n    if obj isa Integer\n        # special-case for pre-1.0 JSON compat\n        return json(fname; pretty=obj)\n    else\n        @assert fname isa AbstractString \"filename must be a string\"\n    end\n    open(fname, \"w\") do io\n        json(io, obj; kw...)\n    end\n    return fname\nend\n\n# we use the same growth strategy as Base julia does for array growing\n# which starts with small N at ~5x and approaches 1.125x as N grows\n# ref: https://github.com/JuliaLang/julia/pull/40453\nnewlen(n\u2080) = ceil(Int, n\u2080 + 4*n\u2080^(7 / 8) + n\u2080 / 8)\n\nmacro checkn(n, force_resize=false)\n    esc(quote\n        if (pos + $n - 1) > length(buf)\n            # If we have an IO object and buffer would exceed bufsize, flush to IO first\n            # unless force_resize is true (used for comma writing to avoid flushing partial JSON)\n            if io !== nothing && length(buf) >= bufsize && pos > 1 && !$force_resize\n                write(io, view(buf, 1:pos-1))\n                pos = 1\n            end\n            # Resize buffer if still needed\n            if (pos + $n - 1) > length(buf)\n                resize!(buf, newlen(pos + $n))\n            end\n        end\n    end)\nend\n\nstruct WriteClosure{JS, arraylike, T, I} # T is the type of the parent object/array being written\n    buf::Vector{UInt8}\n    pos::Ptr{Int}\n    wroteany::Ptr{Bool} # to track if we wrote any data to the buffer\n    indent::Int\n    depth::Int\n    opts::JS\n    ancestor_stack::Vector{Any} # to track circular references\n    io::I\n    bufsize::Int\nend\n\nfunction indent(buf, pos, ind, depth, io, bufsize)\n    if ind > 0\n        n = ind * depth + 1\n        @checkn n\n        buf[pos] = UInt8('\\n')\n        for i = 1:(n - 1)\n            buf[pos + i] = UInt8(' ')\n        end\n        pos += n\n    end\n    return pos\nend\n\ncheckkey(s) = s isa AbstractString || throw(ArgumentError(\"Value returned from `StructUtils.lowerkey` must be a string: $(typeof(s))\"))\n\nfunction (f::WriteClosure{JS, arraylike, T, I})(key, val) where {JS, arraylike, T, I}\n    track_ref = ismutabletype(typeof(val))\n    is_circ_ref = track_ref && any(x -> x === val, f.ancestor_stack)\n    val isa Omit && return\n    if !arraylike\n        # for objects, check omit_null/omit_empty\n        # and skip if the value is null or empty\n        if f.opts.omit_null === true || (f.opts.omit_null === nothing && omit_null(f.opts.style, T))\n            (is_circ_ref || val === nothing) && return\n        end\n        if f.opts.omit_empty === true || (f.opts.omit_empty === nothing && omit_empty(f.opts.style, T))\n            (is_circ_ref || is_empty(val)) && return\n        end\n    end\n    pos = unsafe_load(f.pos)\n    unsafe_store!(f.wroteany, true) # at this point, we know something will be written\n    buf = f.buf\n    ind = f.indent\n    io = f.io\n    bufsize = f.bufsize\n    pos = indent(buf, pos, ind, f.depth, io, bufsize)\n    # if not an array, we need to write the key + ':'\n    if !arraylike\n        # skey = StructUtils.lowerkey(f.opts, key)\n        # check if the key is a string\n        checkkey(key)\n        pos = _string(buf, pos, key, io, bufsize)\n        @checkn 1\n        buf[pos] = UInt8(':')\n        pos += 1\n        if ind > 0\n            @checkn 1\n            buf[pos] = UInt8(' ')\n            pos += 1\n        end\n    end\n    # check if the lowered value is in our ancestor stack\n    if is_circ_ref\n        # if so, it's a circular reference! so we just write `null`\n        pos = _null(buf, pos, io, bufsize)\n    else\n        track_ref && push!(f.ancestor_stack, val)\n        # if jsonlines, we need to recursively set to false\n        if f.opts.jsonlines\n            opts = WriteOptions(; omit_null=f.opts.omit_null, omit_empty=f.opts.omit_empty, allownan=f.opts.allownan, jsonlines=false, pretty=f.opts.pretty, ninf=f.opts.ninf, inf=f.opts.inf, nan=f.opts.nan, inline_limit=f.opts.inline_limit, float_style=f.opts.float_style, float_precision=f.opts.float_precision)\n        else\n            opts = f.opts\n        end\n        pos = json!(buf, pos, val, opts, f.ancestor_stack, io, ind, f.depth, bufsize)\n        track_ref && pop!(f.ancestor_stack)\n    end\n    @checkn 1 true\n    @inbounds buf[pos] = f.opts.jsonlines ? UInt8('\\n') : UInt8(',')\n    pos += 1\n    # store our updated pos\n    unsafe_store!(f.pos, pos)\n    return\nend\n\n@noinline throwjsonlines() = throw(ArgumentError(\"jsonlines only supported for arraylike\"))\n\n# assume x is lowered value\nfunction json!(buf, pos, x, opts::WriteOptions, ancestor_stack::Union{Nothing, Vector{Any}}=nothing, io::Union{Nothing, IO}=nothing, ind::Int=opts.pretty, depth::Int=0, bufsize::Int=opts.bufsize)\n    # string\n    if x isa Omit\n        _root_omit_throw()\n    elseif x isa Null\n        return _null(buf, pos, io, bufsize)\n    elseif x isa AbstractString\n        return _string(buf, pos, x, io, bufsize)\n    # write JSONText out directly\n    elseif x isa JSONText\n        val = x.value\n        @checkn sizeof(val)\n        for i = 1:sizeof(val)\n            @inbounds buf[pos + i - 1] = codeunit(val, i)\n        end\n        return pos + sizeof(val)\n    # bool; check before Number since Bool <: Number\n    elseif x isa Bool\n        if x\n            @checkn 4\n            @inbounds buf[pos] = 't'\n            @inbounds buf[pos + 1] = 'r'\n            @inbounds buf[pos + 2] = 'u'\n            @inbounds buf[pos + 3] = 'e'\n            return pos + 4\n        else\n            @checkn 5\n            @inbounds buf[pos] = 'f'\n            @inbounds buf[pos + 1] = 'a'\n            @inbounds buf[pos + 2] = 'l'\n            @inbounds buf[pos + 3] = 's'\n            @inbounds buf[pos + 4] = 'e'\n            return pos + 5\n        end\n    # number\n    elseif x isa Number\n        return _number(buf, pos, x, opts, io, bufsize)\n    # null\n    elseif x === nothing\n        return _null(buf, pos, io, bufsize)\n    # object or array\n    elseif StructUtils.dictlike(opts.style, x) || StructUtils.arraylike(opts.style, x) || StructUtils.structlike(opts.style, x)\n        al = StructUtils.arraylike(opts.style, x)\n        # override pretty indent to 0 for arrays shorter than inline_limit\n        if al && opts.pretty > 0 && opts.inline_limit > 0 && length(x) < opts.inline_limit\n            local_ind = 0\n        else\n            local_ind = ind\n        end\n        if !opts.jsonlines\n            @checkn 1\n            @inbounds buf[pos] = al ? UInt8('[') : UInt8('{')\n            pos += 1\n        else\n            al || throwjsonlines()\n        end\n        ref = Ref(pos)\n        wroteany = false\n        wroteanyref = Ref(false)\n        GC.@preserve ref wroteanyref begin\n            c = WriteClosure{typeof(opts), al, typeof(x), typeof(io)}(buf, Base.unsafe_convert(Ptr{Int}, ref), Base.unsafe_convert(Ptr{Bool}, wroteanyref), local_ind, depth + 1, opts, ancestor_stack, io, bufsize)\n            StructUtils.applyeach(opts.style, c, x)\n            # get updated pos\n            pos = unsafe_load(c.pos)\n            wroteany = unsafe_load(c.wroteany)\n        end\n        # in WriteClosure, we eagerly write a comma after each element\n        # so for non-empty object/arrays, we can just overwrite the last comma with the closechar\n        if wroteany\n            pos -= 1\n            pos = indent(buf, pos, local_ind, depth, io, bufsize)\n        end\n        # even if the input is empty and we're jsonlines, the spec says it's ok to end w/ a newline\n        @checkn 1\n        @inbounds buf[pos] = opts.jsonlines ? UInt8('\\n') : al ? UInt8(']') : UInt8('}')\n        return pos + 1\n    else\n        return _string(buf, pos, x, io, bufsize)\n    end\nend\n\nfunction _null(buf, pos, io, bufsize)\n    @checkn 4\n    @inbounds buf[pos] = 'n'\n    @inbounds buf[pos + 1] = 'u'\n    @inbounds buf[pos + 2] = 'l'\n    @inbounds buf[pos + 3] = 'l'\n    return pos + 4\nend\n\n_string(buf, pos, x, io, bufsize) = _string(buf, pos, string(x), io, bufsize)\n_string(buf, pos, x::LazyValues, io, bufsize) = _string(buf, pos, getindex(x), io, bufsize)\n_string(buf, pos, x::PtrString, io, bufsize) = _string(buf, pos, convert(String, x), io, bufsize)\n\nfunction _string(buf, pos, x::AbstractString, io, bufsize)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @checkn (el + 2)\n    @inbounds buf[pos] = UInt8('\"')\n    pos += 1\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds buf[pos] = UInt8('\"')\n    return pos + 1\nend\n\n\"\"\"\n    JSON.tostring(x)\n\nOverloadable function that allows non-`Integer` `Number` types\nto convert themselves to a `String` that is then used\nwhen serializing `x` to JSON. Note that if the result of `tostring`\nis not a valid JSON number, it will be serialized as a JSON string,\nwith double quotes around it.\n\nAn example overload would look something like:\n```julia\nJSON.tostring(x::MyDecimal) = string(x)\n```\n\"\"\"\ntostring(x) = string(Float64(x))\n\nsplit_sign(n::Integer) = unsigned(abs(n)), n < 0\nsplit_sign(n::Unsigned) = n, false\nsplit_sign(x::BigInt) = (abs(x), x < 0)\n\n@noinline infcheck(x, allownan) = isfinite(x) || allownan || throw(ArgumentError(\"$x not allowed to be written in JSON spec; pass `allownan=true` to allow anyway\"))\n\nfunction _number(buf, pos, x::Number, opts::WriteOptions, io, bufsize)\n    if x isa Integer\n        y, neg = split_sign(x)\n        n = i = ndigits(y, base=10, pad=1)\n        @checkn (i + neg)\n        if neg\n            @inbounds buf[pos] = UInt8('-')\n            pos += 1\n        end\n        while i > 0\n            @inbounds buf[pos + i - 1] = 48 + rem(y, 10)\n            y = oftype(y, div(y, 10))\n            i -= 1\n        end\n        return pos + n\n    elseif x isa Union{Float16, Float32, Float64}\n        infcheck(x, opts.allownan)\n        if isnan(x)\n            nan = opts.nan\n            @checkn sizeof(nan)\n            for i = 1:sizeof(nan)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(nan, i))\n            end\n            return pos + sizeof(nan)\n        elseif isinf(x)\n            if x < 0\n                inf = opts.ninf\n            else\n                inf = opts.inf\n            end\n            @checkn sizeof(inf)\n            for i = 1:sizeof(inf)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(inf, i))\n            end\n            return pos + sizeof(inf)\n        end\n        if opts.float_style == :shortest\n            @checkn Base.Ryu.neededdigits(typeof(x))\n            return Base.Ryu.writeshortest(buf, pos, x)\n        elseif opts.float_style == :fixed\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writefixed(buf, pos, x, opts.float_precision, false, false, true)\n        elseif opts.float_style == :exp\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writeexp(buf, pos, x, opts.float_precision, false, false, true)\n        else\n            # unreachable as we validate float_style inputs\n            @assert false\n        end\n    else\n        str = tostring(x)\n        if anyinvalidnumberchars(str)\n            # serialize as string\n            return _string(buf, pos, str, io, bufsize)\n        end\n        bytes = codeunits(str)\n        sz = sizeof(bytes)\n        @checkn sz\n        for i = 1:sz\n            @inbounds buf[pos + i - 1] = bytes[i]\n        end\n        return pos + sz\n    end\nend\n\nfunction anyinvalidnumberchars(x)\n    for i = 1:sizeof(x)\n        b = codeunit(x, i)\n        if !(b == UInt8('-') || b == UInt8('.') || b == UInt8('e') || b == UInt8('E') ||\n            UInt8('0') <= b <= UInt8('9'))\n            return true\n        end\n    end\n    return false\nend\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": ["test/json.jl"], "lines_changed": 94, "is_valid": true, "validation_errors": []}
{"repo": "JSON.jl", "commit_sha": "d2f1c7b881ef65b346afff902beebbc91af7020e", "parent_sha": "dd7d48901bbfaba534210121603a79c32075a599", "commit_message": "Ensure isvalidjson doesn't throw during LazyValue initial creation; fixes #404 (#407)", "commit_date": "2025-11-07T23:53:14-07:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/JSON.jl", "target_symbol": "isvalidjson", "signature": null, "confidence": 0.75}, "files_before": {"src/JSON.jl": "module JSON\n\n# stdlibs\nusing Dates, UUIDs, Logging\n# external dependencies\nusing PrecompileTools, Parsers, StructUtils\n\n# reexport some StructUtils macros\nimport StructUtils: @noarg, @defaults, @tags, @choosetype, @nonstruct, lower, lift\nexport JSONText, StructUtils, @noarg, @defaults, @tags, @choosetype, @nonstruct, @omit_null, @omit_empty\n\n@enum Error InvalidJSON UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedClosingArrayChar ExpectedComma ExpectedColon ExpectedNewline InvalidChar InvalidNumber InvalidUTF16\n\n@noinline function invalid(error, buf, pos::Int, T)\n    # compute which line the error falls on by counting \u201c\\n\u201d bytes up to pos\n    cus = buf isa AbstractString ? codeunits(buf) : buf\n    line_no = count(b -> b == UInt8('\\n'), view(cus, 1:pos)) + 1\n\n    li = pos > 20 ? pos - 9 : 1\n    ri = min(sizeof(cus), pos + 20)\n    snippet_bytes = cus[li:ri]\n    snippet_pos = pos - li + 1\n    snippet = String(copy(snippet_bytes))\n    # find error position; if snippet has multi-codepoint chars,\n    # translate pos to char index, accounting for textwidth of char\n    erri = 1\n    st = iterate(snippet)\n    while st !== nothing\n        c, i = st\n        i > snippet_pos && break\n        erri += textwidth(c)\n        st = iterate(snippet, i)\n    end\n    snippet = replace(snippet, r\"[\\b\\f\\n\\r\\t]\" => \" \")\n    # we call @invoke here to avoid --trim verify errors\n    caret = @invoke(repeat(\" \"::String, (erri + 2)::Integer)) * \"^\"\n    msg = \"\"\"\n    invalid JSON at byte position $(pos) (line $line_no) parsing type $T: $error\n    $snippet$(error == UnexpectedEOF ? \" <EOF>\" : \"...\")\n    $caret\n    \"\"\"\n    throw(ArgumentError(msg))\nend\n\ninclude(\"utils.jl\")\ninclude(\"object.jl\")\n\n# default object type for parse\nconst DEFAULT_OBJECT_TYPE = Object{String, Any}\n\n\"\"\"\n    JSON.JSONText\n\nWrapper around a string containing JSON data.\nCan be used to insert raw JSON in JSON output, like:\n```julia\njson(JSONText(\"{\\\"key\\\": \\\"value\\\"}\"))\n```\nThis will output the JSON as-is, without escaping.\nNote that no check is done to ensure that the JSON is valid.\n\nCan also be used to read \"raw JSON\" when parsing, meaning\nno specialized structure (JSON.Object, Vector{Any}, etc.) is created.\nExample:\n```julia\nx = JSON.parse(\"[1,2,3]\", JSONText)\n# x.value == \"[1,2,3]\"\n```\n\"\"\"\nstruct JSONText\n    value::String\nend\n\ninclude(\"lazy.jl\")\ninclude(\"parse.jl\")\ninclude(\"write.jl\")\n\n\"\"\"\n    JSON.isvalidjson(json) -> Bool\n\nCheck if the given JSON is valid.\nThis function will return `true` if the JSON is valid, and `false` otherwise.\nInputs can be a string, a vector of bytes, or an IO stream, the same inputs\nas supported for `JSON.lazy` and `JSON.parse`.\n\"\"\"\nfunction isvalidjson end\n\nisvalidjson(io::Union{IO, Base.AbstractCmd}; kw...) = isvalidjson(Base.read(io); kw...)\n\nisvalidjson(buf::Union{AbstractVector{UInt8}, AbstractString}; kw...) =\n    isvalidjson(lazy(buf; kw...))\n\nfunction isvalidjson(x::LazyValue)\n    try\n        skip(x)\n        return true\n    catch\n        return false\n    end\nend\n\n# convenience aliases for pre-1.0 JSON compat\nprint(io::IO, obj, indent=nothing) = json(io, obj; pretty=something(indent, 0))\nprint(a, indent=nothing) = print(stdout, a, indent)\n@doc (@doc json) print\n\n@compile_workload begin\n    x = JSON.parse(\"{\\\"a\\\": 1, \\\"b\\\": null, \\\"c\\\": true, \\\"d\\\": false, \\\"e\\\": \\\"\\\", \\\"f\\\": [1,null,true], \\\"g\\\": {\\\"key\\\": \\\"value\\\"}}\")\n    json = JSON.json(x)\n    isvalidjson(json)\nend\n\n\nend # module\n"}, "files_after": {"src/JSON.jl": "module JSON\n\n# stdlibs\nusing Dates, UUIDs, Logging\n# external dependencies\nusing PrecompileTools, Parsers, StructUtils\n\n# reexport some StructUtils macros\nimport StructUtils: @noarg, @defaults, @tags, @choosetype, @nonstruct, lower, lift\nexport JSONText, StructUtils, @noarg, @defaults, @tags, @choosetype, @nonstruct, @omit_null, @omit_empty\n\n@enum Error InvalidJSON UnexpectedEOF ExpectedOpeningObjectChar ExpectedOpeningQuoteChar ExpectedOpeningArrayChar ExpectedClosingArrayChar ExpectedComma ExpectedColon ExpectedNewline InvalidChar InvalidNumber InvalidUTF16\n\n@noinline function invalid(error, buf, pos::Int, T)\n    # compute which line the error falls on by counting \u201c\\n\u201d bytes up to pos\n    cus = buf isa AbstractString ? codeunits(buf) : buf\n    line_no = count(b -> b == UInt8('\\n'), view(cus, 1:pos)) + 1\n\n    li = pos > 20 ? pos - 9 : 1\n    ri = min(sizeof(cus), pos + 20)\n    snippet_bytes = cus[li:ri]\n    snippet_pos = pos - li + 1\n    snippet = String(copy(snippet_bytes))\n    # find error position; if snippet has multi-codepoint chars,\n    # translate pos to char index, accounting for textwidth of char\n    erri = 1\n    st = iterate(snippet)\n    while st !== nothing\n        c, i = st\n        i > snippet_pos && break\n        erri += textwidth(c)\n        st = iterate(snippet, i)\n    end\n    snippet = replace(snippet, r\"[\\b\\f\\n\\r\\t]\" => \" \")\n    # we call @invoke here to avoid --trim verify errors\n    caret = @invoke(repeat(\" \"::String, (erri + 2)::Integer)) * \"^\"\n    msg = \"\"\"\n    invalid JSON at byte position $(pos) (line $line_no) parsing type $T: $error\n    $snippet$(error == UnexpectedEOF ? \" <EOF>\" : \"...\")\n    $caret\n    \"\"\"\n    throw(ArgumentError(msg))\nend\n\ninclude(\"utils.jl\")\ninclude(\"object.jl\")\n\n# default object type for parse\nconst DEFAULT_OBJECT_TYPE = Object{String, Any}\n\n\"\"\"\n    JSON.JSONText\n\nWrapper around a string containing JSON data.\nCan be used to insert raw JSON in JSON output, like:\n```julia\njson(JSONText(\"{\\\"key\\\": \\\"value\\\"}\"))\n```\nThis will output the JSON as-is, without escaping.\nNote that no check is done to ensure that the JSON is valid.\n\nCan also be used to read \"raw JSON\" when parsing, meaning\nno specialized structure (JSON.Object, Vector{Any}, etc.) is created.\nExample:\n```julia\nx = JSON.parse(\"[1,2,3]\", JSONText)\n# x.value == \"[1,2,3]\"\n```\n\"\"\"\nstruct JSONText\n    value::String\nend\n\ninclude(\"lazy.jl\")\ninclude(\"parse.jl\")\ninclude(\"write.jl\")\n\n\"\"\"\n    JSON.isvalidjson(json) -> Bool\n\nCheck if the given JSON is valid.\nThis function will return `true` if the JSON is valid, and `false` otherwise.\nInputs can be a string, a vector of bytes, or an IO stream, the same inputs\nas supported for `JSON.lazy` and `JSON.parse`.\n\"\"\"\nfunction isvalidjson end\n\nisvalidjson(io::Union{IO, Base.AbstractCmd}; kw...) = isvalidjson(Base.read(io); kw...)\n\nfunction isvalidjson(buf::Union{AbstractVector{UInt8}, AbstractString}; kw...)\n    try\n        return isvalidjson(lazy(buf; kw...))\n    catch\n        return false\n    end\nend\n\nfunction isvalidjson(x::LazyValue)\n    try\n        skip(x)\n        return true\n    catch\n        return false\n    end\nend\n\n# convenience aliases for pre-1.0 JSON compat\nprint(io::IO, obj, indent=nothing) = json(io, obj; pretty=something(indent, 0))\nprint(a, indent=nothing) = print(stdout, a, indent)\n@doc (@doc json) print\n\n@compile_workload begin\n    x = JSON.parse(\"{\\\"a\\\": 1, \\\"b\\\": null, \\\"c\\\": true, \\\"d\\\": false, \\\"e\\\": \\\"\\\", \\\"f\\\": [1,null,true], \\\"g\\\": {\\\"key\\\": \\\"value\\\"}}\")\n    json = JSON.json(x)\n    isvalidjson(json)\nend\n\n\nend # module\n"}, "source_files_changed": ["src/JSON.jl"], "test_files_changed": ["test/parse.jl"], "lines_changed": 12, "is_valid": true, "validation_errors": []}
{"repo": "JSON.jl", "commit_sha": "dd7d48901bbfaba534210121603a79c32075a599", "parent_sha": "2990e0369e3fddc6523f979845aee9dd960ba4e2", "commit_message": "Treat array of pairs as object when writing. Fixes #398 (#406)", "commit_date": "2025-11-07T23:11:12-07:00", "action": {"type": "ADD_METHOD", "target_file": "src/write.jl", "target_symbol": "StructUtils.arraylike", "signature": null, "confidence": 0.85}, "files_before": {"src/write.jl": "struct JSONWriteStyle <: JSONStyle end\n\nsizeguess(::Nothing) = 4\nsizeguess(x::Bool) = 5\nsizeguess(x::Integer) = 20\nsizeguess(x::AbstractFloat) = 20\nsizeguess(x::Union{Float16, Float32, Float64}) = Base.Ryu.neededdigits(typeof(x))\nsizeguess(x::AbstractString) = 2 + sizeof(x)\nsizeguess(_) = 512\n\nStructUtils.lower(::JSONStyle, ::Missing) = nothing\nStructUtils.lower(::JSONStyle, x::Symbol) = String(x)\nStructUtils.lower(::JSONStyle, x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType, Type, Logging.LogLevel}) = string(x)\nStructUtils.lower(::JSONStyle, x::Regex) = x.pattern\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any,0}) = x[1]\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any, N}) where {N} = (view(x, ntuple(_ -> :, N - 1)..., j) for j in axes(x, N))\nStructUtils.lower(::JSONStyle, x::AbstractVector) = x\n\n# for pre-1.0 compat, which serialized Tuple object keys by default\nStructUtils.lowerkey(::JSONStyle, x::Tuple) = string(x)\n\n\"\"\"\n    JSON.omit_null(::Type{T})::Bool\n    JSON.omit_null(::JSONStyle, ::Type{T})::Bool\n    \nControls whether struct fields that are undefined or are `nothing` are included in the JSON output.\nReturns `false` by default, meaning all fields are included, regardless of undef or `nothing`. To instead\nensure only *non-null* fields are written, set this to `true`.\nThis can also be controlled via the `omit_null` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_null(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_null(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_null(::Type{T}) where {T} = false\nomit_null(::JSONStyle, ::Type{T}) where {T} = omit_null(T)\n\n\"\"\"\n    @omit_null struct T ...\n    @omit_null T\n\nConvenience macro to set `omit_null(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_null struct T ... end`\n2. Applied to an existing struct name: `@omit_null T`\n3. Chained with other macros: `@omit_null @defaults struct T ... end`\n\nThe macro automatically handles complex macro expansions by walking the expression\ntree to find struct definitions, making it compatible with macros like `StructUtils.@defaults`.\n\n# Examples\n```julia\n# Method 1: Struct annotation\n@omit_null struct Person\n    name::String\n    email::Union{Nothing, String}\nend\n\n# Method 2: Apply to existing struct\nstruct User\n    id::Int\n    profile::Union{Nothing, String}\nend\n@omit_null User\n\n# Method 3: Chain with @defaults\n@omit_null @defaults struct Employee\n    name::String = \"Anonymous\"\n    manager::Union{Nothing, String} = nothing\nend\n```\n\"\"\"\nmacro omit_null(expr)\n    return _omit_macro_impl(expr, :omit_null, __module__)\nend\n\n\"\"\"\n    JSON.omit_empty(::Type{T})::Bool\n    JSON.omit_empty(::JSONStyle, ::Type{T})::Bool\n\nControls whether struct fields that are empty are included in the JSON output.\nReturns `false` by default, meaning empty fields *are* included. To instead exclude empty fields,\nset this to `true`. A field is considered empty if it is `nothing`, an empty collection\n(empty array, dict, string, tuple, or named tuple), or `missing`.\nThis can also be controlled via the `omit_empty` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_empty(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_empty(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_empty(::Type{T}) where {T} = false\nomit_empty(::JSONStyle, ::Type{T}) where {T} = omit_empty(T)\n\nis_empty(x) = false\nis_empty(::Nothing) = true\nis_empty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = Base.isempty(x)\n\n\"\"\"\n    @omit_empty struct T ...\n    @omit_empty T\n\nConvenience macro to set `omit_empty(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_empty struct T ... end`\n2. Applied to an existing struct name: `@omit_empty T`\n3. Chained with other macros: `@omit_empty @other_macro struct T ... end`\n\"\"\"\nmacro omit_empty(expr)\n    return _omit_macro_impl(expr, :omit_empty, __module__)\nend\n\n# Helper function for both @omit_null and @omit_empty macros\nfunction _omit_macro_impl(expr, omit_func_name, module_context)\n    original_expr = expr\n    expr = macroexpand(module_context, expr)\n    # Case 1: Just a type name (Symbol or more complex type expression)\n    if isa(expr, Symbol) || (Meta.isexpr(expr, :curly) || Meta.isexpr(expr, :where))\n        # Extract the base type name\n        T = _extract_type_name(expr)\n        return esc(quote\n            JSON.$omit_func_name(::Type{$T}) = true\n        end)\n    end\n    # Case 2: Struct definition (possibly from macro expansion)\n    if Meta.isexpr(expr, :struct)\n        ismutable, T, fieldsblock = expr.args\n        T = _extract_type_name(T)\n        return esc(quote\n            # insert original expr as-is\n            $expr\n            # omit function overload\n            JSON.$omit_func_name(::Type{$T}) = true\n        end)\n    end\n    # Case 3: Block expression (from complex macros like @defaults)\n    if Meta.isexpr(expr, :block)\n        # Try to find a struct definition in the block\n        struct_expr = _find_struct_in_block(expr)\n        if struct_expr !== nothing\n            ismutable, T, fieldsblock = struct_expr.args\n            T = _extract_type_name(T)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$T}) = true\n            end)\n        end\n    end\n    # Case 4: Macro expression that we hope expands to a struct\n    if Meta.isexpr(original_expr, :macrocall)\n        # Try to see if the expanded form is a struct\n        if Meta.isexpr(expr, :struct)\n            ismutable, T, fieldsblock = expr.args\n            T = _extract_type_name(T)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$T}) = true\n            end)\n        else\n            throw(ArgumentError(\"Macro $(original_expr.args[1]) did not expand to a struct definition\"))\n        end\n    end\n    throw(ArgumentError(\"Invalid usage of @$omit_func_name macro. Expected: struct definition, type name, or macro that expands to struct definition\"))\nend\n\n# Helper function to recursively find a struct definition in a block expression\nfunction _find_struct_in_block(expr)\n    if Meta.isexpr(expr, :struct)\n        return expr\n    elseif Meta.isexpr(expr, :block)\n        for arg in expr.args\n            result = _find_struct_in_block(arg)\n            if result !== nothing\n                return result\n            end\n        end\n    end\n    return nothing\nend\n\n# Helper function to extract the base type name from various type expressions\nfunction _extract_type_name(T)\n    if isa(T, Symbol)\n        return T\n    elseif Meta.isexpr(T, :<:)\n        # Handle subtyping: struct Foo <: Bar\n        return _extract_type_name(T.args[1])\n    elseif Meta.isexpr(T, :curly)\n        # Handle parametric types: keep the full parametric type Foo{T}\n        return T\n    elseif Meta.isexpr(T, :where)\n        # Handle where clauses: struct Foo{T} where T\n        return _extract_type_name(T.args[1])\n    else\n        return T\n    end\nend\n\nStructUtils.lowerkey(::JSONStyle, s::AbstractString) = s\nStructUtils.lowerkey(::JSONStyle, sym::Symbol) = String(sym)\nStructUtils.lowerkey(::JSONStyle, n::Union{Integer, Union{Float16, Float32, Float64}}) = string(n)\nStructUtils.lowerkey(::JSONStyle, x) = throw(ArgumentError(\"No key representation for $(typeof(x)). Define StructUtils.lowerkey(::$(typeof(x)))\"))\n\n\"\"\"\n    JSON.json(x) -> String\n    JSON.json(io, x)\n    JSON.json(file_name, x)\n\nSerialize `x` to JSON format. The 1st method takes just the object and returns a `String`.\nIn the 2nd method, `io` is an `IO` object, and the JSON output will be written to it.\nFor the 3rd method, `file_name` is a `String`, a file will be opened and the JSON output will be written to it.\n\nAll methods accept the following keyword arguments:\n\n- `omit_null::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are undefined or are `nothing` are included in the JSON output.\n  If `true`, only non-null fields are written. If `false`, all fields are included regardless of being undefined or `nothing`.\n  If `nothing`, the behavior is determined by `JSON.omit_null(::Type{T})`, which is `false` by default.\n\n- `omit_empty::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are empty are included in the JSON output.\n  If `true`, empty fields are excluded. If `false`, empty fields are included.\n  If `nothing`, the behavior is determined by `JSON.omit_empty(::Type{T})`.\n\n- `allownan::Bool=false`: If `true`, allow `Inf`, `-Inf`, and `NaN` in the output.\n  If `false`, throw an error if `Inf`, `-Inf`, or `NaN` is encountered.\n\n- `jsonlines::Bool=false`: If `true`, input must be array-like and the output will be written in the JSON Lines format,\n  where each element of the array is written on a separate line (i.e. separated by a single newline character `\\n`).\n  If `false`, the output will be written in the standard JSON format.\n\n- `pretty::Union{Integer,Bool}=false`: Controls pretty printing of the JSON output.\n  If `true`, the output will be pretty-printed with 2 spaces of indentation.\n  If an integer, it will be used as the number of spaces of indentation.\n  If `false` or `0`, the output will be compact.\n  Note: Pretty printing is not supported when `jsonlines=true`.\n\n- `inline_limit::Int=0`: For arrays shorter than this limit, pretty printing will be disabled (indentation set to 0).\n\n- `ninf::String=\"-Infinity\"`: Custom string representation for negative infinity.\n\n- `inf::String=\"Infinity\"`: Custom string representation for positive infinity.\n\n- `nan::String=\"NaN\"`: Custom string representation for NaN.\n\n- `float_style::Symbol=:shortest`: Controls how floating-point numbers are formatted.\n  Options are:\n  - `:shortest`: Use the shortest representation that preserves the value\n  - `:fixed`: Use fixed-point notation\n  - `:exp`: Use exponential notation\n\n- `float_precision::Int=1`: Number of decimal places to use when `float_style` is `:fixed` or `:exp`.\n\n- `bufsize::Int=2^22`: Buffer size in bytes for IO operations. When writing to IO, the buffer will be flushed \n  to the IO stream once it reaches this size. This helps control memory usage during large write operations.\n  Default is 4MB (2^22 bytes). This parameter is ignored when returning a String.\n\n- `style::JSONStyle=JSONWriteStyle()`: Custom style object that controls serialization behavior. This allows customizing\n    certain aspects of serialization, like defining a custom `lower` method for a non-owned type. Like `struct MyStyle <: JSONStyle end`,\n    `JSON.lower(x::Rational) = (num=x.num, den=x.den)`, then calling `JSON.json(1//3; style=MyStyle())` will output\n    `{\"num\": 1, \"den\": 3}`.\n\nBy default, `x` must be a JSON-serializable object. Supported types include:\n  * `AbstractString` => JSON string: types must support the `AbstractString` interface, specifically with support for\n    `ncodeunits` and `codeunit(x, i)`.\n  * `Bool` => JSON boolean: must be `true` or `false`\n  * `Nothing` => JSON null: must be the `nothing` singleton value\n  * `Number` => JSON number: `Integer` subtypes or `Union{Float16, Float32, Float64}` have default implementations\n    for other `Number` types, [`JSON.tostring`](@ref) is first called to convert\n    the value to a `String` before being written directly to JSON output\n  * `AbstractArray`/`Tuple`/`AbstractSet` => JSON array: objects for which `JSON.arraylike` returns `true`\n     are output as JSON arrays. `arraylike` is defined by default for\n    `AbstractArray`, `AbstractSet`, `Tuple`, and `Base.Generator`. For other types that define,\n    they must also properly implement `StructUtils.applyeach` to iterate over the index => elements pairs.\n    Note that arrays with dimensionality > 1 are written as nested arrays, with `N` nestings for `N` dimensions,\n    and the 1st dimension is always the innermost nested JSON array (column-major order).\n  * `AbstractDict`/`NamedTuple`/structs => JSON object: if a value doesn't fall into any of the above categories,\n    it is output as a JSON object. `StructUtils.applyeach` is called, which has appropriate implementations\n    for `AbstractDict`, `NamedTuple`, and structs, where field names => values are iterated over. Field names can\n    be output with an alternative name via field tag overload, like `field::Type &(json=(name=\"alternative_name\",),)`\n\nIf an object is not JSON-serializable, an override for `JSON.lower` can\nbe defined to convert it to a JSON-serializable object. Some default `lower` defintions\nare defined in JSON itself, for example:\n  * `StructUtils.lower(::Missing) = nothing`\n  * `StructUtils.lower(x::Symbol) = String(x)`\n  * `StructUtils.lower(x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType}) = string(x)`\n  * `StructUtils.lower(x::Regex) = x.pattern`\n\nThese allow common Base/stdlib types to be serialized in an expected format.\n\nCircular references are tracked automatically and cycles are broken by writing `null` for any children references.\n\nFor pre-formatted JSON data as a String, use `JSONText(json)` to write the string out as-is.\n\nFor `AbstractDict` objects with non-string keys, `StructUtils.lowerkey` will be called before serializing. This allows aggregate\nor other types of dict keys to be converted to an appropriate string representation. See `StructUtils.liftkey`\nfor the reverse operation, which is called when parsing JSON data back into a dict type.\n\n*NOTE*: `JSON.json` should _not_ be overloaded directly by custom\ntypes as this isn't robust for various output options (IO, String, etc.)\nnor recursive situations. Types should define an appropriate\n`JSON.lower` definition instead.\n\n*NOTE*: `JSON.json(str, indent::Integer)` is special-cased for backwards compatibility with pre-1.0 JSON.jl,\nas this typically would mean \"write out the `indent` integer to file `str`\". As writing out a single integer to\na file is extremely rare, it was decided to keep the pre-1.0 behavior for compatibility reasons.\n\nExamples:\n```julia\nusing Dates\n\nabstract type AbstractMonster end\n\nstruct Dracula <: AbstractMonster\n    num_victims::Int\nend\n\nstruct Werewolf <: AbstractMonster\n    witching_hour::DateTime\nend\n\nstruct Percent <: Number\n    value::Float64\nend\n\nJSON.lower(x::Percent) = x.value\nStructUtils.lowerkey(x::Percent) = string(x.value)\n\n@noarg mutable struct FrankenStruct\n    id::Int\n    name::String # no default to show serialization of an undefined field\n    address::Union{Nothing, String} = nothing\n    rate::Union{Missing, Float64} = missing\n    type::Symbol = :a &(json=(name=\"franken_type\",),)\n    notsure::Any = JSON.Object(\"key\" => \"value\")\n    monster::AbstractMonster = Dracula(10) &(json=(lower=x -> x isa Dracula ? (monster_type=\"vampire\", num_victims=x.num_victims) : (monster_type=\"werewolf\", witching_hour=x.witching_hour),),)\n    percent::Percent = Percent(0.5)\n    birthdate::Date = Date(2025, 1, 1) &(json=(dateformat=\"yyyy/mm/dd\",),)\n    percentages::Dict{Percent, Int} = Dict{Percent, Int}(Percent(0.0) => 0, Percent(1.0) => 1)\n    json_properties::JSONText = JSONText(\"{\\\"key\\\": \\\"value\\\"}\")\n    matrix::Matrix{Float64} = [1.0 2.0; 3.0 4.0]\n    extra_field::Any = nothing &(json=(ignore=true,),)\nend\n\nfranken = FrankenStruct()\nfranken.id = 1\n\njson = JSON.json(franken; omit_null=false)\n# \"{\\\"id\\\":1,\\\"name\\\":null,\\\"address\\\":null,\\\"rate\\\":null,\\\"franken_type\\\":\\\"a\\\",\\\"notsure\\\":{\\\"key\\\":\\\"value\\\"},\\\"monster\\\":{\\\"monster_type\\\":\\\"vampire\\\",\\\"num_victims\\\":10},\\\"percent\\\":0.5,\\\"birthdate\\\":\\\"2025/01/01\\\",\\\"percentages\\\":{\\\"1.0\\\":1,\\\"0.0\\\":0},\\\"json_properties\\\":{\\\"key\\\": \\\"value\\\"},\\\"matrix\\\":[[1.0,3.0],[2.0,4.0]]}\"\n```\n\nA few comments on the JSON produced in the example above:\n  - The `name` field was `#undef`, and thus was serialized as `null`.\n  - The `address` and `rate` fields were `nothing` and `missing`, respectively, and thus were serialized as `null`.\n  - The `type` field has a `name` field tag, so the JSON key for this field is `franken_type` instead of `type`.\n  - The `notsure` field is a `JSON.Object`, so it is serialized as a JSON object.\n  - The `monster` field is a `AbstractMonster`, which is a custom type. It has a `lower` field tag that specifies how the value of this field specifically (not all AbstractMonster) should be serialized\n  - The `percent` field is a `Percent`, which is a custom type. It has a `lower` method that specifies how `Percent` values should be serialized\n  - The `birthdate` field has a `dateformat` field tag, so the value follows the format (`yyyy/mm/dd`) instead of the default date ISO format (`yyyy-mm-dd`)\n  - The `percentages` field is a `Dict{Percent, Int}`, which is a custom type. It has a `lowerkey` method that specifies how `Percent` keys should be serialized as strings\n  - The `json_properties` field is a `JSONText`, so the JSONText value is serialized as-is\n  - The `matrix` field is a `Matrix{Float64}`, which is a custom type. It is serialized as a JSON array, with the first dimension being the innermost nested JSON array (column-major order)\n  - The `extra_field` field has a `ignore` field tag, so it is skipped when serializing\n\n\"\"\"\nfunction json end\n\n@kwdef struct WriteOptions{S}\n    omit_null::Union{Bool, Nothing} = nothing\n    omit_empty::Union{Bool, Nothing} = nothing\n    allownan::Bool = false\n    jsonlines::Bool = false\n    pretty::Int = 0\n    ninf::String = \"-Infinity\"\n    inf::String = \"Infinity\"\n    nan::String = \"NaN\"\n    inline_limit::Int = 0\n    float_style::Symbol = :shortest # :shortest, :fixed, :exp\n    float_precision::Int = 1\n    bufsize::Int = 2^22 # 4MB default buffer size for IO flushing\n    style::S = JSONWriteStyle()\nend\n\n@noinline float_style_throw(fs) = throw(ArgumentError(\"Invalid float style: $fs\"))\nfloat_style_check(fs) = fs == :shortest || fs == :fixed || fs == :exp || float_style_throw(fs)\n\n@noinline float_precision_throw(fs, fp) = throw(ArgumentError(\"float_precision must be positive when float_style is $fs; got $fp\"))\nfloat_precision_check(fs, fp) = (fs == :shortest || fp > 0) || float_precision_throw(fs, fp)\n\n# if jsonlines and pretty is not 0 or false, throw an ArgumentError\n@noinline _jsonlines_pretty_throw() = throw(ArgumentError(\"pretty printing is not supported when writing jsonlines\"))\n_jsonlines_pretty_check(jsonlines, pretty) = jsonlines && pretty !== false && !iszero(pretty) && _jsonlines_pretty_throw()\n\nfunction json(io::IO, x::T; pretty::Union{Integer,Bool}=false, kw...) where {T}\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    # Use smaller initial buffer size, limited by bufsize\n    initial_size = min(sizeguess(y), opts.bufsize)\n    buf = Vector{UInt8}(undef, initial_size)\n    pos = json!(buf, 1, y, opts, Any[y], io)\n    # Write any remaining buffer contents to IO\n    if pos > 1\n        write(io, view(buf, 1:pos-1))\n    end\n    return nothing\nend\n\nif isdefined(Base, :StringVector)\n    stringvec(n) = Base.StringVector(n)\nelse\n    stringvec(n) = Vector{UInt8}(undef, n)\nend\n\nfunction json(x; pretty::Union{Integer,Bool}=false, kw...)\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    buf = stringvec(sizeguess(y))\n    pos = json!(buf, 1, y, opts, Any[y], nothing)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction json(fname, obj; kw...)\n    if obj isa Integer\n        # special-case for pre-1.0 JSON compat\n        return json(fname; pretty=obj)\n    else\n        @assert fname isa AbstractString \"filename must be a string\"\n    end\n    open(fname, \"w\") do io\n        json(io, obj; kw...)\n    end\n    return fname\nend\n\n# we use the same growth strategy as Base julia does for array growing\n# which starts with small N at ~5x and approaches 1.125x as N grows\n# ref: https://github.com/JuliaLang/julia/pull/40453\nnewlen(n\u2080) = ceil(Int, n\u2080 + 4*n\u2080^(7 / 8) + n\u2080 / 8)\n\nmacro checkn(n, force_resize=false)\n    esc(quote\n        if (pos + $n - 1) > length(buf)\n            # If we have an IO object and buffer would exceed bufsize, flush to IO first\n            # unless force_resize is true (used for comma writing to avoid flushing partial JSON)\n            if io !== nothing && length(buf) >= bufsize && pos > 1 && !$force_resize\n                write(io, view(buf, 1:pos-1))\n                pos = 1\n            end\n            # Resize buffer if still needed\n            if (pos + $n - 1) > length(buf)\n                resize!(buf, newlen(pos + $n))\n            end\n        end\n    end)\nend\n\nstruct WriteClosure{JS, arraylike, T, I} # T is the type of the parent object/array being written\n    buf::Vector{UInt8}\n    pos::Ptr{Int}\n    wroteany::Ptr{Bool} # to track if we wrote any data to the buffer\n    indent::Int\n    depth::Int\n    opts::JS\n    ancestor_stack::Vector{Any} # to track circular references\n    io::I\n    bufsize::Int\nend\n\nfunction indent(buf, pos, ind, depth, io, bufsize)\n    if ind > 0\n        n = ind * depth + 1\n        @checkn n\n        buf[pos] = UInt8('\\n')\n        for i = 1:(n - 1)\n            buf[pos + i] = UInt8(' ')\n        end\n        pos += n\n    end\n    return pos\nend\n\ncheckkey(s) = s isa AbstractString || throw(ArgumentError(\"Value returned from `StructUtils.lowerkey` must be a string: $(typeof(s))\"))\n\nfunction (f::WriteClosure{JS, arraylike, T, I})(key, val) where {JS, arraylike, T, I}\n    track_ref = ismutabletype(typeof(val))\n    is_circ_ref = track_ref && any(x -> x === val, f.ancestor_stack)\n    if !arraylike\n        # for objects, check omit_null/omit_empty\n        # and skip if the value is null or empty\n        if f.opts.omit_null === true || (f.opts.omit_null === nothing && omit_null(f.opts.style, T))\n            (is_circ_ref || val === nothing) && return\n        end\n        if f.opts.omit_empty === true || (f.opts.omit_empty === nothing && omit_empty(f.opts.style, T))\n            (is_circ_ref || is_empty(val)) && return\n        end\n    end\n    pos = unsafe_load(f.pos)\n    unsafe_store!(f.wroteany, true) # at this point, we know something will be written\n    buf = f.buf\n    ind = f.indent\n    io = f.io\n    bufsize = f.bufsize\n    pos = indent(buf, pos, ind, f.depth, io, bufsize)\n    # if not an array, we need to write the key + ':'\n    if !arraylike\n        # skey = StructUtils.lowerkey(f.opts, key)\n        # check if the key is a string\n        checkkey(key)\n        pos = _string(buf, pos, key, io, bufsize)\n        @checkn 1\n        buf[pos] = UInt8(':')\n        pos += 1\n        if ind > 0\n            @checkn 1\n            buf[pos] = UInt8(' ')\n            pos += 1\n        end\n    end\n    # check if the lowered value is in our ancestor stack\n    if is_circ_ref\n        # if so, it's a circular reference! so we just write `null`\n        pos = _null(buf, pos, io, bufsize)\n    else\n        track_ref && push!(f.ancestor_stack, val)\n        # if jsonlines, we need to recursively set to false\n        if f.opts.jsonlines\n            opts = WriteOptions(; omit_null=f.opts.omit_null, omit_empty=f.opts.omit_empty, allownan=f.opts.allownan, jsonlines=false, pretty=f.opts.pretty, ninf=f.opts.ninf, inf=f.opts.inf, nan=f.opts.nan, inline_limit=f.opts.inline_limit, float_style=f.opts.float_style, float_precision=f.opts.float_precision)\n        else\n            opts = f.opts\n        end\n        pos = json!(buf, pos, val, opts, f.ancestor_stack, io, ind, f.depth, bufsize)\n        track_ref && pop!(f.ancestor_stack)\n    end\n    @checkn 1 true\n    @inbounds buf[pos] = f.opts.jsonlines ? UInt8('\\n') : UInt8(',')\n    pos += 1\n    # store our updated pos\n    unsafe_store!(f.pos, pos)\n    return\nend\n\n@noinline throwjsonlines() = throw(ArgumentError(\"jsonlines only supported for arraylike\"))\n\n# assume x is lowered value\nfunction json!(buf, pos, x, opts::WriteOptions, ancestor_stack::Union{Nothing, Vector{Any}}=nothing, io::Union{Nothing, IO}=nothing, ind::Int=opts.pretty, depth::Int=0, bufsize::Int=opts.bufsize)\n    # string\n    if x isa AbstractString\n        return _string(buf, pos, x, io, bufsize)\n    # write JSONText out directly\n    elseif x isa JSONText\n        val = x.value\n        @checkn sizeof(val)\n        for i = 1:sizeof(val)\n            @inbounds buf[pos + i - 1] = codeunit(val, i)\n        end\n        return pos + sizeof(val)\n    # bool; check before Number since Bool <: Number\n    elseif x isa Bool\n        if x\n            @checkn 4\n            @inbounds buf[pos] = 't'\n            @inbounds buf[pos + 1] = 'r'\n            @inbounds buf[pos + 2] = 'u'\n            @inbounds buf[pos + 3] = 'e'\n            return pos + 4\n        else\n            @checkn 5\n            @inbounds buf[pos] = 'f'\n            @inbounds buf[pos + 1] = 'a'\n            @inbounds buf[pos + 2] = 'l'\n            @inbounds buf[pos + 3] = 's'\n            @inbounds buf[pos + 4] = 'e'\n            return pos + 5\n        end\n    # number\n    elseif x isa Number\n        return _number(buf, pos, x, opts, io, bufsize)\n    # null\n    elseif x === nothing\n        return _null(buf, pos, io, bufsize)\n    # object or array\n    elseif StructUtils.dictlike(opts.style, x) || StructUtils.arraylike(opts.style, x) || StructUtils.structlike(opts.style, x)\n        al = StructUtils.arraylike(opts.style, x)\n        # override pretty indent to 0 for arrays shorter than inline_limit\n        if al && opts.pretty > 0 && opts.inline_limit > 0 && length(x) < opts.inline_limit\n            local_ind = 0\n        else\n            local_ind = ind\n        end\n        if !opts.jsonlines\n            @checkn 1\n            @inbounds buf[pos] = al ? UInt8('[') : UInt8('{')\n            pos += 1\n        else\n            al || throwjsonlines()\n        end\n        ref = Ref(pos)\n        wroteany = false\n        wroteanyref = Ref(false)\n        GC.@preserve ref wroteanyref begin\n            c = WriteClosure{typeof(opts), al, typeof(x), typeof(io)}(buf, Base.unsafe_convert(Ptr{Int}, ref), Base.unsafe_convert(Ptr{Bool}, wroteanyref), local_ind, depth + 1, opts, ancestor_stack, io, bufsize)\n            StructUtils.applyeach(opts.style, c, x)\n            # get updated pos\n            pos = unsafe_load(c.pos)\n            wroteany = unsafe_load(c.wroteany)\n        end\n        # in WriteClosure, we eagerly write a comma after each element\n        # so for non-empty object/arrays, we can just overwrite the last comma with the closechar\n        if wroteany\n            pos -= 1\n            pos = indent(buf, pos, local_ind, depth, io, bufsize)\n        end\n        # even if the input is empty and we're jsonlines, the spec says it's ok to end w/ a newline\n        @checkn 1\n        @inbounds buf[pos] = opts.jsonlines ? UInt8('\\n') : al ? UInt8(']') : UInt8('}')\n        return pos + 1\n    else\n        return _string(buf, pos, x, io, bufsize)\n    end\nend\n\nfunction _null(buf, pos, io, bufsize)\n    @checkn 4\n    @inbounds buf[pos] = 'n'\n    @inbounds buf[pos + 1] = 'u'\n    @inbounds buf[pos + 2] = 'l'\n    @inbounds buf[pos + 3] = 'l'\n    return pos + 4\nend\n\n_string(buf, pos, x, io, bufsize) = _string(buf, pos, string(x), io, bufsize)\n_string(buf, pos, x::LazyValues, io, bufsize) = _string(buf, pos, getindex(x), io, bufsize)\n_string(buf, pos, x::PtrString, io, bufsize) = _string(buf, pos, convert(String, x), io, bufsize)\n\nfunction _string(buf, pos, x::AbstractString, io, bufsize)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @checkn (el + 2)\n    @inbounds buf[pos] = UInt8('\"')\n    pos += 1\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds buf[pos] = UInt8('\"')\n    return pos + 1\nend\n\n\"\"\"\n    JSON.tostring(x)\n\nOverloadable function that allows non-`Integer` `Number` types\nto convert themselves to a `String` that is then used\nwhen serializing `x` to JSON. Note that if the result of `tostring`\nis not a valid JSON number, it will be serialized as a JSON string,\nwith double quotes around it.\n\nAn example overload would look something like:\n```julia\nJSON.tostring(x::MyDecimal) = string(x)\n```\n\"\"\"\ntostring(x) = string(Float64(x))\n\nsplit_sign(n::Integer) = unsigned(abs(n)), n < 0\nsplit_sign(n::Unsigned) = n, false\nsplit_sign(x::BigInt) = (abs(x), x < 0)\n\n@noinline infcheck(x, allownan) = isfinite(x) || allownan || throw(ArgumentError(\"$x not allowed to be written in JSON spec; pass `allownan=true` to allow anyway\"))\n\nfunction _number(buf, pos, x::Number, opts::WriteOptions, io, bufsize)\n    if x isa Integer\n        y, neg = split_sign(x)\n        n = i = ndigits(y, base=10, pad=1)\n        @checkn (i + neg)\n        if neg\n            @inbounds buf[pos] = UInt8('-')\n            pos += 1\n        end\n        while i > 0\n            @inbounds buf[pos + i - 1] = 48 + rem(y, 10)\n            y = oftype(y, div(y, 10))\n            i -= 1\n        end\n        return pos + n\n    elseif x isa Union{Float16, Float32, Float64}\n        infcheck(x, opts.allownan)\n        if isnan(x)\n            nan = opts.nan\n            @checkn sizeof(nan)\n            for i = 1:sizeof(nan)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(nan, i))\n            end\n            return pos + sizeof(nan)\n        elseif isinf(x)\n            if x < 0\n                inf = opts.ninf\n            else\n                inf = opts.inf\n            end\n            @checkn sizeof(inf)\n            for i = 1:sizeof(inf)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(inf, i))\n            end\n            return pos + sizeof(inf)\n        end\n        if opts.float_style == :shortest\n            @checkn Base.Ryu.neededdigits(typeof(x))\n            return Base.Ryu.writeshortest(buf, pos, x)\n        elseif opts.float_style == :fixed\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writefixed(buf, pos, x, opts.float_precision, false, false, true)\n        elseif opts.float_style == :exp\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writeexp(buf, pos, x, opts.float_precision, false, false, true)\n        else\n            # unreachable as we validate float_style inputs\n            @assert false\n        end\n    else\n        str = tostring(x)\n        if anyinvalidnumberchars(str)\n            # serialize as string\n            return _string(buf, pos, str, io, bufsize)\n        end\n        bytes = codeunits(str)\n        sz = sizeof(bytes)\n        @checkn sz\n        for i = 1:sz\n            @inbounds buf[pos + i - 1] = bytes[i]\n        end\n        return pos + sz\n    end\nend\n\nfunction anyinvalidnumberchars(x)\n    for i = 1:sizeof(x)\n        b = codeunit(x, i)\n        if !(b == UInt8('-') || b == UInt8('.') || b == UInt8('e') || b == UInt8('E') ||\n            UInt8('0') <= b <= UInt8('9'))\n            return true\n        end\n    end\n    return false\nend\n"}, "files_after": {"src/write.jl": "struct JSONWriteStyle <: JSONStyle end\n\nsizeguess(::Nothing) = 4\nsizeguess(x::Bool) = 5\nsizeguess(x::Integer) = 20\nsizeguess(x::AbstractFloat) = 20\nsizeguess(x::Union{Float16, Float32, Float64}) = Base.Ryu.neededdigits(typeof(x))\nsizeguess(x::AbstractString) = 2 + sizeof(x)\nsizeguess(_) = 512\n\nStructUtils.lower(::JSONStyle, ::Missing) = nothing\nStructUtils.lower(::JSONStyle, x::Symbol) = String(x)\nStructUtils.lower(::JSONStyle, x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType, Type, Logging.LogLevel}) = string(x)\nStructUtils.lower(::JSONStyle, x::Regex) = x.pattern\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any,0}) = x[1]\nStructUtils.lower(::JSONStyle, x::AbstractArray{<:Any, N}) where {N} = (view(x, ntuple(_ -> :, N - 1)..., j) for j in axes(x, N))\nStructUtils.lower(::JSONStyle, x::AbstractVector) = x\nStructUtils.arraylike(::JSONStyle, x::AbstractVector{<:Pair}) = false\n\n# for pre-1.0 compat, which serialized Tuple object keys by default\nStructUtils.lowerkey(::JSONStyle, x::Tuple) = string(x)\n\n\"\"\"\n    JSON.omit_null(::Type{T})::Bool\n    JSON.omit_null(::JSONStyle, ::Type{T})::Bool\n    \nControls whether struct fields that are undefined or are `nothing` are included in the JSON output.\nReturns `false` by default, meaning all fields are included, regardless of undef or `nothing`. To instead\nensure only *non-null* fields are written, set this to `true`.\nThis can also be controlled via the `omit_null` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_null(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_null(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_null(::Type{T}) where {T} = false\nomit_null(::JSONStyle, ::Type{T}) where {T} = omit_null(T)\n\n\"\"\"\n    @omit_null struct T ...\n    @omit_null T\n\nConvenience macro to set `omit_null(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_null struct T ... end`\n2. Applied to an existing struct name: `@omit_null T`\n3. Chained with other macros: `@omit_null @defaults struct T ... end`\n\nThe macro automatically handles complex macro expansions by walking the expression\ntree to find struct definitions, making it compatible with macros like `StructUtils.@defaults`.\n\n# Examples\n```julia\n# Method 1: Struct annotation\n@omit_null struct Person\n    name::String\n    email::Union{Nothing, String}\nend\n\n# Method 2: Apply to existing struct\nstruct User\n    id::Int\n    profile::Union{Nothing, String}\nend\n@omit_null User\n\n# Method 3: Chain with @defaults\n@omit_null @defaults struct Employee\n    name::String = \"Anonymous\"\n    manager::Union{Nothing, String} = nothing\nend\n```\n\"\"\"\nmacro omit_null(expr)\n    return _omit_macro_impl(expr, :omit_null, __module__)\nend\n\n\"\"\"\n    JSON.omit_empty(::Type{T})::Bool\n    JSON.omit_empty(::JSONStyle, ::Type{T})::Bool\n\nControls whether struct fields that are empty are included in the JSON output.\nReturns `false` by default, meaning empty fields *are* included. To instead exclude empty fields,\nset this to `true`. A field is considered empty if it is `nothing`, an empty collection\n(empty array, dict, string, tuple, or named tuple), or `missing`.\nThis can also be controlled via the `omit_empty` keyword argument in [`JSON.json`](@ref).\n\n```julia\n# Override for a specific type\nJSON.omit_empty(::Type{MyStruct}) = true\n\n# Override for a custom style\nstruct MyStyle <: JSON.JSONStyle end\nJSON.omit_empty(::MyStyle, ::Type{T}) where {T} = true\n```\n\"\"\"\nomit_empty(::Type{T}) where {T} = false\nomit_empty(::JSONStyle, ::Type{T}) where {T} = omit_empty(T)\n\nis_empty(x) = false\nis_empty(::Nothing) = true\nis_empty(x::Union{AbstractDict, AbstractArray, AbstractString, Tuple, NamedTuple}) = Base.isempty(x)\n\n\"\"\"\n    @omit_empty struct T ...\n    @omit_empty T\n\nConvenience macro to set `omit_empty(::Type{T})` to `true` for the struct `T`.\nCan be used in three ways:\n1. In front of a struct definition: `@omit_empty struct T ... end`\n2. Applied to an existing struct name: `@omit_empty T`\n3. Chained with other macros: `@omit_empty @other_macro struct T ... end`\n\"\"\"\nmacro omit_empty(expr)\n    return _omit_macro_impl(expr, :omit_empty, __module__)\nend\n\n# Helper function for both @omit_null and @omit_empty macros\nfunction _omit_macro_impl(expr, omit_func_name, module_context)\n    original_expr = expr\n    expr = macroexpand(module_context, expr)\n    # Case 1: Just a type name (Symbol or more complex type expression)\n    if isa(expr, Symbol) || (Meta.isexpr(expr, :curly) || Meta.isexpr(expr, :where))\n        # Extract the base type name\n        T = _extract_type_name(expr)\n        return esc(quote\n            JSON.$omit_func_name(::Type{$T}) = true\n        end)\n    end\n    # Case 2: Struct definition (possibly from macro expansion)\n    if Meta.isexpr(expr, :struct)\n        ismutable, T, fieldsblock = expr.args\n        T = _extract_type_name(T)\n        return esc(quote\n            # insert original expr as-is\n            $expr\n            # omit function overload\n            JSON.$omit_func_name(::Type{$T}) = true\n        end)\n    end\n    # Case 3: Block expression (from complex macros like @defaults)\n    if Meta.isexpr(expr, :block)\n        # Try to find a struct definition in the block\n        struct_expr = _find_struct_in_block(expr)\n        if struct_expr !== nothing\n            ismutable, T, fieldsblock = struct_expr.args\n            T = _extract_type_name(T)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$T}) = true\n            end)\n        end\n    end\n    # Case 4: Macro expression that we hope expands to a struct\n    if Meta.isexpr(original_expr, :macrocall)\n        # Try to see if the expanded form is a struct\n        if Meta.isexpr(expr, :struct)\n            ismutable, T, fieldsblock = expr.args\n            T = _extract_type_name(T)\n            return esc(quote\n                # insert original expr as-is\n                $original_expr\n                # omit function overload\n                JSON.$omit_func_name(::Type{$T}) = true\n            end)\n        else\n            throw(ArgumentError(\"Macro $(original_expr.args[1]) did not expand to a struct definition\"))\n        end\n    end\n    throw(ArgumentError(\"Invalid usage of @$omit_func_name macro. Expected: struct definition, type name, or macro that expands to struct definition\"))\nend\n\n# Helper function to recursively find a struct definition in a block expression\nfunction _find_struct_in_block(expr)\n    if Meta.isexpr(expr, :struct)\n        return expr\n    elseif Meta.isexpr(expr, :block)\n        for arg in expr.args\n            result = _find_struct_in_block(arg)\n            if result !== nothing\n                return result\n            end\n        end\n    end\n    return nothing\nend\n\n# Helper function to extract the base type name from various type expressions\nfunction _extract_type_name(T)\n    if isa(T, Symbol)\n        return T\n    elseif Meta.isexpr(T, :<:)\n        # Handle subtyping: struct Foo <: Bar\n        return _extract_type_name(T.args[1])\n    elseif Meta.isexpr(T, :curly)\n        # Handle parametric types: keep the full parametric type Foo{T}\n        return T\n    elseif Meta.isexpr(T, :where)\n        # Handle where clauses: struct Foo{T} where T\n        return _extract_type_name(T.args[1])\n    else\n        return T\n    end\nend\n\nStructUtils.lowerkey(::JSONStyle, s::AbstractString) = s\nStructUtils.lowerkey(::JSONStyle, sym::Symbol) = String(sym)\nStructUtils.lowerkey(::JSONStyle, n::Union{Integer, Union{Float16, Float32, Float64}}) = string(n)\nStructUtils.lowerkey(::JSONStyle, x) = throw(ArgumentError(\"No key representation for $(typeof(x)). Define StructUtils.lowerkey(::$(typeof(x)))\"))\n\n\"\"\"\n    JSON.json(x) -> String\n    JSON.json(io, x)\n    JSON.json(file_name, x)\n\nSerialize `x` to JSON format. The 1st method takes just the object and returns a `String`.\nIn the 2nd method, `io` is an `IO` object, and the JSON output will be written to it.\nFor the 3rd method, `file_name` is a `String`, a file will be opened and the JSON output will be written to it.\n\nAll methods accept the following keyword arguments:\n\n- `omit_null::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are undefined or are `nothing` are included in the JSON output.\n  If `true`, only non-null fields are written. If `false`, all fields are included regardless of being undefined or `nothing`.\n  If `nothing`, the behavior is determined by `JSON.omit_null(::Type{T})`, which is `false` by default.\n\n- `omit_empty::Union{Bool, Nothing}=nothing`: Controls whether struct fields that are empty are included in the JSON output.\n  If `true`, empty fields are excluded. If `false`, empty fields are included.\n  If `nothing`, the behavior is determined by `JSON.omit_empty(::Type{T})`.\n\n- `allownan::Bool=false`: If `true`, allow `Inf`, `-Inf`, and `NaN` in the output.\n  If `false`, throw an error if `Inf`, `-Inf`, or `NaN` is encountered.\n\n- `jsonlines::Bool=false`: If `true`, input must be array-like and the output will be written in the JSON Lines format,\n  where each element of the array is written on a separate line (i.e. separated by a single newline character `\\n`).\n  If `false`, the output will be written in the standard JSON format.\n\n- `pretty::Union{Integer,Bool}=false`: Controls pretty printing of the JSON output.\n  If `true`, the output will be pretty-printed with 2 spaces of indentation.\n  If an integer, it will be used as the number of spaces of indentation.\n  If `false` or `0`, the output will be compact.\n  Note: Pretty printing is not supported when `jsonlines=true`.\n\n- `inline_limit::Int=0`: For arrays shorter than this limit, pretty printing will be disabled (indentation set to 0).\n\n- `ninf::String=\"-Infinity\"`: Custom string representation for negative infinity.\n\n- `inf::String=\"Infinity\"`: Custom string representation for positive infinity.\n\n- `nan::String=\"NaN\"`: Custom string representation for NaN.\n\n- `float_style::Symbol=:shortest`: Controls how floating-point numbers are formatted.\n  Options are:\n  - `:shortest`: Use the shortest representation that preserves the value\n  - `:fixed`: Use fixed-point notation\n  - `:exp`: Use exponential notation\n\n- `float_precision::Int=1`: Number of decimal places to use when `float_style` is `:fixed` or `:exp`.\n\n- `bufsize::Int=2^22`: Buffer size in bytes for IO operations. When writing to IO, the buffer will be flushed \n  to the IO stream once it reaches this size. This helps control memory usage during large write operations.\n  Default is 4MB (2^22 bytes). This parameter is ignored when returning a String.\n\n- `style::JSONStyle=JSONWriteStyle()`: Custom style object that controls serialization behavior. This allows customizing\n    certain aspects of serialization, like defining a custom `lower` method for a non-owned type. Like `struct MyStyle <: JSONStyle end`,\n    `JSON.lower(x::Rational) = (num=x.num, den=x.den)`, then calling `JSON.json(1//3; style=MyStyle())` will output\n    `{\"num\": 1, \"den\": 3}`.\n\nBy default, `x` must be a JSON-serializable object. Supported types include:\n  * `AbstractString` => JSON string: types must support the `AbstractString` interface, specifically with support for\n    `ncodeunits` and `codeunit(x, i)`.\n  * `Bool` => JSON boolean: must be `true` or `false`\n  * `Nothing` => JSON null: must be the `nothing` singleton value\n  * `Number` => JSON number: `Integer` subtypes or `Union{Float16, Float32, Float64}` have default implementations\n    for other `Number` types, [`JSON.tostring`](@ref) is first called to convert\n    the value to a `String` before being written directly to JSON output\n  * `AbstractArray`/`Tuple`/`AbstractSet` => JSON array: objects for which `JSON.arraylike` returns `true`\n     are output as JSON arrays. `arraylike` is defined by default for\n    `AbstractArray`, `AbstractSet`, `Tuple`, and `Base.Generator`. For other types that define,\n    they must also properly implement `StructUtils.applyeach` to iterate over the index => elements pairs.\n    Note that arrays with dimensionality > 1 are written as nested arrays, with `N` nestings for `N` dimensions,\n    and the 1st dimension is always the innermost nested JSON array (column-major order).\n  * `AbstractDict`/`NamedTuple`/structs => JSON object: if a value doesn't fall into any of the above categories,\n    it is output as a JSON object. `StructUtils.applyeach` is called, which has appropriate implementations\n    for `AbstractDict`, `NamedTuple`, and structs, where field names => values are iterated over. Field names can\n    be output with an alternative name via field tag overload, like `field::Type &(json=(name=\"alternative_name\",),)`\n\nIf an object is not JSON-serializable, an override for `JSON.lower` can\nbe defined to convert it to a JSON-serializable object. Some default `lower` defintions\nare defined in JSON itself, for example:\n  * `StructUtils.lower(::Missing) = nothing`\n  * `StructUtils.lower(x::Symbol) = String(x)`\n  * `StructUtils.lower(x::Union{Enum, AbstractChar, VersionNumber, Cstring, Cwstring, UUID, Dates.TimeType}) = string(x)`\n  * `StructUtils.lower(x::Regex) = x.pattern`\n\nThese allow common Base/stdlib types to be serialized in an expected format.\n\nCircular references are tracked automatically and cycles are broken by writing `null` for any children references.\n\nFor pre-formatted JSON data as a String, use `JSONText(json)` to write the string out as-is.\n\nFor `AbstractDict` objects with non-string keys, `StructUtils.lowerkey` will be called before serializing. This allows aggregate\nor other types of dict keys to be converted to an appropriate string representation. See `StructUtils.liftkey`\nfor the reverse operation, which is called when parsing JSON data back into a dict type.\n\n*NOTE*: `JSON.json` should _not_ be overloaded directly by custom\ntypes as this isn't robust for various output options (IO, String, etc.)\nnor recursive situations. Types should define an appropriate\n`JSON.lower` definition instead.\n\n*NOTE*: `JSON.json(str, indent::Integer)` is special-cased for backwards compatibility with pre-1.0 JSON.jl,\nas this typically would mean \"write out the `indent` integer to file `str`\". As writing out a single integer to\na file is extremely rare, it was decided to keep the pre-1.0 behavior for compatibility reasons.\n\nExamples:\n```julia\nusing Dates\n\nabstract type AbstractMonster end\n\nstruct Dracula <: AbstractMonster\n    num_victims::Int\nend\n\nstruct Werewolf <: AbstractMonster\n    witching_hour::DateTime\nend\n\nstruct Percent <: Number\n    value::Float64\nend\n\nJSON.lower(x::Percent) = x.value\nStructUtils.lowerkey(x::Percent) = string(x.value)\n\n@noarg mutable struct FrankenStruct\n    id::Int\n    name::String # no default to show serialization of an undefined field\n    address::Union{Nothing, String} = nothing\n    rate::Union{Missing, Float64} = missing\n    type::Symbol = :a &(json=(name=\"franken_type\",),)\n    notsure::Any = JSON.Object(\"key\" => \"value\")\n    monster::AbstractMonster = Dracula(10) &(json=(lower=x -> x isa Dracula ? (monster_type=\"vampire\", num_victims=x.num_victims) : (monster_type=\"werewolf\", witching_hour=x.witching_hour),),)\n    percent::Percent = Percent(0.5)\n    birthdate::Date = Date(2025, 1, 1) &(json=(dateformat=\"yyyy/mm/dd\",),)\n    percentages::Dict{Percent, Int} = Dict{Percent, Int}(Percent(0.0) => 0, Percent(1.0) => 1)\n    json_properties::JSONText = JSONText(\"{\\\"key\\\": \\\"value\\\"}\")\n    matrix::Matrix{Float64} = [1.0 2.0; 3.0 4.0]\n    extra_field::Any = nothing &(json=(ignore=true,),)\nend\n\nfranken = FrankenStruct()\nfranken.id = 1\n\njson = JSON.json(franken; omit_null=false)\n# \"{\\\"id\\\":1,\\\"name\\\":null,\\\"address\\\":null,\\\"rate\\\":null,\\\"franken_type\\\":\\\"a\\\",\\\"notsure\\\":{\\\"key\\\":\\\"value\\\"},\\\"monster\\\":{\\\"monster_type\\\":\\\"vampire\\\",\\\"num_victims\\\":10},\\\"percent\\\":0.5,\\\"birthdate\\\":\\\"2025/01/01\\\",\\\"percentages\\\":{\\\"1.0\\\":1,\\\"0.0\\\":0},\\\"json_properties\\\":{\\\"key\\\": \\\"value\\\"},\\\"matrix\\\":[[1.0,3.0],[2.0,4.0]]}\"\n```\n\nA few comments on the JSON produced in the example above:\n  - The `name` field was `#undef`, and thus was serialized as `null`.\n  - The `address` and `rate` fields were `nothing` and `missing`, respectively, and thus were serialized as `null`.\n  - The `type` field has a `name` field tag, so the JSON key for this field is `franken_type` instead of `type`.\n  - The `notsure` field is a `JSON.Object`, so it is serialized as a JSON object.\n  - The `monster` field is a `AbstractMonster`, which is a custom type. It has a `lower` field tag that specifies how the value of this field specifically (not all AbstractMonster) should be serialized\n  - The `percent` field is a `Percent`, which is a custom type. It has a `lower` method that specifies how `Percent` values should be serialized\n  - The `birthdate` field has a `dateformat` field tag, so the value follows the format (`yyyy/mm/dd`) instead of the default date ISO format (`yyyy-mm-dd`)\n  - The `percentages` field is a `Dict{Percent, Int}`, which is a custom type. It has a `lowerkey` method that specifies how `Percent` keys should be serialized as strings\n  - The `json_properties` field is a `JSONText`, so the JSONText value is serialized as-is\n  - The `matrix` field is a `Matrix{Float64}`, which is a custom type. It is serialized as a JSON array, with the first dimension being the innermost nested JSON array (column-major order)\n  - The `extra_field` field has a `ignore` field tag, so it is skipped when serializing\n\n\"\"\"\nfunction json end\n\n@kwdef struct WriteOptions{S}\n    omit_null::Union{Bool, Nothing} = nothing\n    omit_empty::Union{Bool, Nothing} = nothing\n    allownan::Bool = false\n    jsonlines::Bool = false\n    pretty::Int = 0\n    ninf::String = \"-Infinity\"\n    inf::String = \"Infinity\"\n    nan::String = \"NaN\"\n    inline_limit::Int = 0\n    float_style::Symbol = :shortest # :shortest, :fixed, :exp\n    float_precision::Int = 1\n    bufsize::Int = 2^22 # 4MB default buffer size for IO flushing\n    style::S = JSONWriteStyle()\nend\n\n@noinline float_style_throw(fs) = throw(ArgumentError(\"Invalid float style: $fs\"))\nfloat_style_check(fs) = fs == :shortest || fs == :fixed || fs == :exp || float_style_throw(fs)\n\n@noinline float_precision_throw(fs, fp) = throw(ArgumentError(\"float_precision must be positive when float_style is $fs; got $fp\"))\nfloat_precision_check(fs, fp) = (fs == :shortest || fp > 0) || float_precision_throw(fs, fp)\n\n# if jsonlines and pretty is not 0 or false, throw an ArgumentError\n@noinline _jsonlines_pretty_throw() = throw(ArgumentError(\"pretty printing is not supported when writing jsonlines\"))\n_jsonlines_pretty_check(jsonlines, pretty) = jsonlines && pretty !== false && !iszero(pretty) && _jsonlines_pretty_throw()\n\nfunction json(io::IO, x::T; pretty::Union{Integer,Bool}=false, kw...) where {T}\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    # Use smaller initial buffer size, limited by bufsize\n    initial_size = min(sizeguess(y), opts.bufsize)\n    buf = Vector{UInt8}(undef, initial_size)\n    pos = json!(buf, 1, y, opts, Any[y], io)\n    # Write any remaining buffer contents to IO\n    if pos > 1\n        write(io, view(buf, 1:pos-1))\n    end\n    return nothing\nend\n\nif isdefined(Base, :StringVector)\n    stringvec(n) = Base.StringVector(n)\nelse\n    stringvec(n) = Vector{UInt8}(undef, n)\nend\n\nfunction json(x; pretty::Union{Integer,Bool}=false, kw...)\n    opts = WriteOptions(; pretty=pretty === true ? 2 : Int(pretty), kw...)\n    _jsonlines_pretty_check(opts.jsonlines, opts.pretty)\n    float_style_check(opts.float_style)\n    float_precision_check(opts.float_style, opts.float_precision)\n    y = StructUtils.lower(opts.style, x)\n    buf = stringvec(sizeguess(y))\n    pos = json!(buf, 1, y, opts, Any[y], nothing)\n    return String(resize!(buf, pos - 1))\nend\n\nfunction json(fname, obj; kw...)\n    if obj isa Integer\n        # special-case for pre-1.0 JSON compat\n        return json(fname; pretty=obj)\n    else\n        @assert fname isa AbstractString \"filename must be a string\"\n    end\n    open(fname, \"w\") do io\n        json(io, obj; kw...)\n    end\n    return fname\nend\n\n# we use the same growth strategy as Base julia does for array growing\n# which starts with small N at ~5x and approaches 1.125x as N grows\n# ref: https://github.com/JuliaLang/julia/pull/40453\nnewlen(n\u2080) = ceil(Int, n\u2080 + 4*n\u2080^(7 / 8) + n\u2080 / 8)\n\nmacro checkn(n, force_resize=false)\n    esc(quote\n        if (pos + $n - 1) > length(buf)\n            # If we have an IO object and buffer would exceed bufsize, flush to IO first\n            # unless force_resize is true (used for comma writing to avoid flushing partial JSON)\n            if io !== nothing && length(buf) >= bufsize && pos > 1 && !$force_resize\n                write(io, view(buf, 1:pos-1))\n                pos = 1\n            end\n            # Resize buffer if still needed\n            if (pos + $n - 1) > length(buf)\n                resize!(buf, newlen(pos + $n))\n            end\n        end\n    end)\nend\n\nstruct WriteClosure{JS, arraylike, T, I} # T is the type of the parent object/array being written\n    buf::Vector{UInt8}\n    pos::Ptr{Int}\n    wroteany::Ptr{Bool} # to track if we wrote any data to the buffer\n    indent::Int\n    depth::Int\n    opts::JS\n    ancestor_stack::Vector{Any} # to track circular references\n    io::I\n    bufsize::Int\nend\n\nfunction indent(buf, pos, ind, depth, io, bufsize)\n    if ind > 0\n        n = ind * depth + 1\n        @checkn n\n        buf[pos] = UInt8('\\n')\n        for i = 1:(n - 1)\n            buf[pos + i] = UInt8(' ')\n        end\n        pos += n\n    end\n    return pos\nend\n\ncheckkey(s) = s isa AbstractString || throw(ArgumentError(\"Value returned from `StructUtils.lowerkey` must be a string: $(typeof(s))\"))\n\nfunction (f::WriteClosure{JS, arraylike, T, I})(key, val) where {JS, arraylike, T, I}\n    track_ref = ismutabletype(typeof(val))\n    is_circ_ref = track_ref && any(x -> x === val, f.ancestor_stack)\n    if !arraylike\n        # for objects, check omit_null/omit_empty\n        # and skip if the value is null or empty\n        if f.opts.omit_null === true || (f.opts.omit_null === nothing && omit_null(f.opts.style, T))\n            (is_circ_ref || val === nothing) && return\n        end\n        if f.opts.omit_empty === true || (f.opts.omit_empty === nothing && omit_empty(f.opts.style, T))\n            (is_circ_ref || is_empty(val)) && return\n        end\n    end\n    pos = unsafe_load(f.pos)\n    unsafe_store!(f.wroteany, true) # at this point, we know something will be written\n    buf = f.buf\n    ind = f.indent\n    io = f.io\n    bufsize = f.bufsize\n    pos = indent(buf, pos, ind, f.depth, io, bufsize)\n    # if not an array, we need to write the key + ':'\n    if !arraylike\n        # skey = StructUtils.lowerkey(f.opts, key)\n        # check if the key is a string\n        checkkey(key)\n        pos = _string(buf, pos, key, io, bufsize)\n        @checkn 1\n        buf[pos] = UInt8(':')\n        pos += 1\n        if ind > 0\n            @checkn 1\n            buf[pos] = UInt8(' ')\n            pos += 1\n        end\n    end\n    # check if the lowered value is in our ancestor stack\n    if is_circ_ref\n        # if so, it's a circular reference! so we just write `null`\n        pos = _null(buf, pos, io, bufsize)\n    else\n        track_ref && push!(f.ancestor_stack, val)\n        # if jsonlines, we need to recursively set to false\n        if f.opts.jsonlines\n            opts = WriteOptions(; omit_null=f.opts.omit_null, omit_empty=f.opts.omit_empty, allownan=f.opts.allownan, jsonlines=false, pretty=f.opts.pretty, ninf=f.opts.ninf, inf=f.opts.inf, nan=f.opts.nan, inline_limit=f.opts.inline_limit, float_style=f.opts.float_style, float_precision=f.opts.float_precision)\n        else\n            opts = f.opts\n        end\n        pos = json!(buf, pos, val, opts, f.ancestor_stack, io, ind, f.depth, bufsize)\n        track_ref && pop!(f.ancestor_stack)\n    end\n    @checkn 1 true\n    @inbounds buf[pos] = f.opts.jsonlines ? UInt8('\\n') : UInt8(',')\n    pos += 1\n    # store our updated pos\n    unsafe_store!(f.pos, pos)\n    return\nend\n\n@noinline throwjsonlines() = throw(ArgumentError(\"jsonlines only supported for arraylike\"))\n\n# assume x is lowered value\nfunction json!(buf, pos, x, opts::WriteOptions, ancestor_stack::Union{Nothing, Vector{Any}}=nothing, io::Union{Nothing, IO}=nothing, ind::Int=opts.pretty, depth::Int=0, bufsize::Int=opts.bufsize)\n    # string\n    if x isa AbstractString\n        return _string(buf, pos, x, io, bufsize)\n    # write JSONText out directly\n    elseif x isa JSONText\n        val = x.value\n        @checkn sizeof(val)\n        for i = 1:sizeof(val)\n            @inbounds buf[pos + i - 1] = codeunit(val, i)\n        end\n        return pos + sizeof(val)\n    # bool; check before Number since Bool <: Number\n    elseif x isa Bool\n        if x\n            @checkn 4\n            @inbounds buf[pos] = 't'\n            @inbounds buf[pos + 1] = 'r'\n            @inbounds buf[pos + 2] = 'u'\n            @inbounds buf[pos + 3] = 'e'\n            return pos + 4\n        else\n            @checkn 5\n            @inbounds buf[pos] = 'f'\n            @inbounds buf[pos + 1] = 'a'\n            @inbounds buf[pos + 2] = 'l'\n            @inbounds buf[pos + 3] = 's'\n            @inbounds buf[pos + 4] = 'e'\n            return pos + 5\n        end\n    # number\n    elseif x isa Number\n        return _number(buf, pos, x, opts, io, bufsize)\n    # null\n    elseif x === nothing\n        return _null(buf, pos, io, bufsize)\n    # object or array\n    elseif StructUtils.dictlike(opts.style, x) || StructUtils.arraylike(opts.style, x) || StructUtils.structlike(opts.style, x)\n        al = StructUtils.arraylike(opts.style, x)\n        # override pretty indent to 0 for arrays shorter than inline_limit\n        if al && opts.pretty > 0 && opts.inline_limit > 0 && length(x) < opts.inline_limit\n            local_ind = 0\n        else\n            local_ind = ind\n        end\n        if !opts.jsonlines\n            @checkn 1\n            @inbounds buf[pos] = al ? UInt8('[') : UInt8('{')\n            pos += 1\n        else\n            al || throwjsonlines()\n        end\n        ref = Ref(pos)\n        wroteany = false\n        wroteanyref = Ref(false)\n        GC.@preserve ref wroteanyref begin\n            c = WriteClosure{typeof(opts), al, typeof(x), typeof(io)}(buf, Base.unsafe_convert(Ptr{Int}, ref), Base.unsafe_convert(Ptr{Bool}, wroteanyref), local_ind, depth + 1, opts, ancestor_stack, io, bufsize)\n            StructUtils.applyeach(opts.style, c, x)\n            # get updated pos\n            pos = unsafe_load(c.pos)\n            wroteany = unsafe_load(c.wroteany)\n        end\n        # in WriteClosure, we eagerly write a comma after each element\n        # so for non-empty object/arrays, we can just overwrite the last comma with the closechar\n        if wroteany\n            pos -= 1\n            pos = indent(buf, pos, local_ind, depth, io, bufsize)\n        end\n        # even if the input is empty and we're jsonlines, the spec says it's ok to end w/ a newline\n        @checkn 1\n        @inbounds buf[pos] = opts.jsonlines ? UInt8('\\n') : al ? UInt8(']') : UInt8('}')\n        return pos + 1\n    else\n        return _string(buf, pos, x, io, bufsize)\n    end\nend\n\nfunction _null(buf, pos, io, bufsize)\n    @checkn 4\n    @inbounds buf[pos] = 'n'\n    @inbounds buf[pos + 1] = 'u'\n    @inbounds buf[pos + 2] = 'l'\n    @inbounds buf[pos + 3] = 'l'\n    return pos + 4\nend\n\n_string(buf, pos, x, io, bufsize) = _string(buf, pos, string(x), io, bufsize)\n_string(buf, pos, x::LazyValues, io, bufsize) = _string(buf, pos, getindex(x), io, bufsize)\n_string(buf, pos, x::PtrString, io, bufsize) = _string(buf, pos, convert(String, x), io, bufsize)\n\nfunction _string(buf, pos, x::AbstractString, io, bufsize)\n    sz = ncodeunits(x)\n    el = escapelength(x)\n    @checkn (el + 2)\n    @inbounds buf[pos] = UInt8('\"')\n    pos += 1\n    if el > sz\n        for i = 1:sz\n            @inbounds escbytes = ESCAPECHARS[codeunit(x, i) + 1]\n            for j = 1:length(escbytes)\n                @inbounds buf[pos] = escbytes[j]\n                pos += 1\n            end\n        end\n    else\n        @simd for i = 1:sz\n            @inbounds buf[pos] = codeunit(x, i)\n            pos += 1\n        end\n    end\n    @inbounds buf[pos] = UInt8('\"')\n    return pos + 1\nend\n\n\"\"\"\n    JSON.tostring(x)\n\nOverloadable function that allows non-`Integer` `Number` types\nto convert themselves to a `String` that is then used\nwhen serializing `x` to JSON. Note that if the result of `tostring`\nis not a valid JSON number, it will be serialized as a JSON string,\nwith double quotes around it.\n\nAn example overload would look something like:\n```julia\nJSON.tostring(x::MyDecimal) = string(x)\n```\n\"\"\"\ntostring(x) = string(Float64(x))\n\nsplit_sign(n::Integer) = unsigned(abs(n)), n < 0\nsplit_sign(n::Unsigned) = n, false\nsplit_sign(x::BigInt) = (abs(x), x < 0)\n\n@noinline infcheck(x, allownan) = isfinite(x) || allownan || throw(ArgumentError(\"$x not allowed to be written in JSON spec; pass `allownan=true` to allow anyway\"))\n\nfunction _number(buf, pos, x::Number, opts::WriteOptions, io, bufsize)\n    if x isa Integer\n        y, neg = split_sign(x)\n        n = i = ndigits(y, base=10, pad=1)\n        @checkn (i + neg)\n        if neg\n            @inbounds buf[pos] = UInt8('-')\n            pos += 1\n        end\n        while i > 0\n            @inbounds buf[pos + i - 1] = 48 + rem(y, 10)\n            y = oftype(y, div(y, 10))\n            i -= 1\n        end\n        return pos + n\n    elseif x isa Union{Float16, Float32, Float64}\n        infcheck(x, opts.allownan)\n        if isnan(x)\n            nan = opts.nan\n            @checkn sizeof(nan)\n            for i = 1:sizeof(nan)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(nan, i))\n            end\n            return pos + sizeof(nan)\n        elseif isinf(x)\n            if x < 0\n                inf = opts.ninf\n            else\n                inf = opts.inf\n            end\n            @checkn sizeof(inf)\n            for i = 1:sizeof(inf)\n                @inbounds buf[pos + i - 1] = UInt8(codeunit(inf, i))\n            end\n            return pos + sizeof(inf)\n        end\n        if opts.float_style == :shortest\n            @checkn Base.Ryu.neededdigits(typeof(x))\n            return Base.Ryu.writeshortest(buf, pos, x)\n        elseif opts.float_style == :fixed\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writefixed(buf, pos, x, opts.float_precision, false, false, true)\n        elseif opts.float_style == :exp\n            @checkn (opts.float_precision + Base.Ryu.neededdigits(typeof(x)))\n            return Base.Ryu.writeexp(buf, pos, x, opts.float_precision, false, false, true)\n        else\n            # unreachable as we validate float_style inputs\n            @assert false\n        end\n    else\n        str = tostring(x)\n        if anyinvalidnumberchars(str)\n            # serialize as string\n            return _string(buf, pos, str, io, bufsize)\n        end\n        bytes = codeunits(str)\n        sz = sizeof(bytes)\n        @checkn sz\n        for i = 1:sz\n            @inbounds buf[pos + i - 1] = bytes[i]\n        end\n        return pos + sz\n    end\nend\n\nfunction anyinvalidnumberchars(x)\n    for i = 1:sizeof(x)\n        b = codeunit(x, i)\n        if !(b == UInt8('-') || b == UInt8('.') || b == UInt8('e') || b == UInt8('E') ||\n            UInt8('0') <= b <= UInt8('9'))\n            return true\n        end\n    end\n    return false\nend\n"}, "source_files_changed": ["src/write.jl"], "test_files_changed": ["test/json.jl"], "lines_changed": 8, "is_valid": true, "validation_errors": []}
