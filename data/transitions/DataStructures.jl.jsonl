{"repo": "DataStructures.jl", "commit_sha": "7fc3ca62e4cb3b52de4523f05b66dde5ce447c84", "parent_sha": "708eeae706f1f26b6f10a7590824166427802a82", "commit_message": "PR feedback", "commit_date": "2025-09-09T12:25:44+02:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/heaps.jl", "target_symbol": null, "signature": null, "confidence": 0.5}, "files_before": {"src/heaps.jl": "# Various heap implementation\n\n###########################################################\n#\n#   Heap interface specification\n#\n#   Each heap is associated with a handle type (H), and\n#   a value type v.\n#\n#   Here, the value type must be comparable, and a handle\n#   is an object through which one can refer to a specific\n#   node of the heap and thus update its value.\n#\n#   Each heap type must implement all of the following\n#   functions. Here, let h be a heap, i be a handle,\n#   v be a value and s be a size.\n#\n#   - length(h)           returns the number of elements\n#\n#   - isempty(h)          returns whether the heap is\n#                         empty\n#\n#   - empty!(h)           reset the heap\n#\n#   - push!(h, v)         add a value to the heap\n#\n#   - sizehint!(h, s)     set size hint to a heap\n#\n#   - first(h)            return the first (top) value of a heap\n#\n#   - pop!(h)             removes the first (top) value, and\n#                         returns it\n#\n#  For mutable heaps, it should also support\n#\n#   - push!(h, v)         adds a value to the heap and\n#                         returns a handle to v\n#\n#   - update!(h, i, v)    updates the value of an element\n#                         (referred to by the handle i)\n#\n#   - delete!(h, i)       deletes the node with\n#                         handle i from the heap\n#\n#   - top_with_handle(h)  return the top value of a heap\n#                         and its handle\n#\n#\n###########################################################\n\n# HT: handle type\n# VT: value type\n\nabstract type AbstractHeap{VT} end\n\nabstract type AbstractMutableHeap{VT,HT} <: AbstractHeap{VT} end\n\nabstract type AbstractMinMaxHeap{VT} <: AbstractHeap{VT} end\n\n# heap implementations\n\ninclude(\"heaps/binary_heap.jl\")\ninclude(\"heaps/mutable_binary_heap.jl\")\ninclude(\"heaps/minmax_heap.jl\")\n\n# generic functions\n\nBase.eltype(::Type{<:AbstractHeap{T}}) where T = T\n\n\"\"\"\n    extract_all!(h)\n\nReturn an array of heap elements in sorted order (heap head at first index).\n\nNote that for simple heaps (not mutable or minmax)\nsorting the internal array of elements in-place is faster.\n\"\"\"\nfunction extract_all!(h::AbstractHeap{VT}) where VT\n    n = length(h)\n    r = Vector{VT}(undef, n)\n    for i in 1 : n\n        r[i] = pop!(h)\n    end\n    return r\nend\n\n\"\"\"\n    extract_all_rev!(h)\n\nReturn an array of heap elements in reverse sorted order (heap head at last index).\n\nNote that for simple heaps (not mutable or minmax)\nsorting the internal array of elements in-place is faster.\n\"\"\"\nfunction extract_all_rev!(h::AbstractHeap{VT}) where VT\n    n = length(h)\n    r = Vector{VT}(undef, n)\n    for i in 1 : n\n        r[n + 1 - i] = pop!(h)\n    end\n    return r\nend\n\n# Array functions using heaps\n\n\"\"\"\n    nextreme(ord, n, arr)\n\nreturn an array of the first `n` values of `arr` sorted by `ord`.\n\"\"\"\nfunction nextreme(ord::Base.Ordering, n::Int, arr::AbstractVector{T}) where T\n    if n <= 0\n        return T[] # sort(arr)[1:n] returns [] for n <= 0\n    elseif n >= length(arr)\n        return sort(arr, order = ord)\n    end\n\n    rev = Base.ReverseOrdering(ord)\n\n    buffer = heapify!(arr[1:n], rev)\n\n    @inbounds for i = n + 1 : length(arr)\n        xi = arr[i]\n        if Base.lt(rev, buffer[1], xi)\n            buffer[1] = xi\n            percolate_down!(buffer, 1, rev)\n        end\n    end\n\n    return sort!(buffer, order = ord)\nend\n\n\"\"\"\n    nlargest(n, arr; kw...)\n\nReturn the `n` largest elements of the array `arr`.\n\nEquivalent to:\n    sort(arr, kw..., rev=true)[1:min(n, end)]\n\nNote that if `arr` contains floats and is free of NaN values,\nthen the following alternative may be used to achieve 2x performance:\n\n    DataStructures.nextreme(DataStructures.FasterReverse(), n, arr)\n\nThis faster version is equivalent to:\n\n    sort(arr, lt = >)[1:min(n, end)]\n\"\"\"\nfunction nlargest(n::Int, arr::AbstractVector; lt=isless, by=identity)\n    order = Base.ReverseOrdering(Base.ord(lt, by, nothing))\n    return nextreme(order, n, arr)\nend\n\n\"\"\"\n    nsmallest(n, arr; kw...)\n\nReturn the `n` smallest elements of the array `arr`.\n\nEquivalent to:\n    sort(arr; kw...)[1:min(n, end)]\n\nNote that if `arr` contains floats and is free of NaN values,\nthen the following alternative may be used to achieve 2x performance:\n\n    DataStructures.nextreme(DataStructures.FasterForward(), n, arr)\n\nThis faster version is equivalent to:\n\n    sort(arr, lt = <)[1:min(n, end)]\n\"\"\"\nfunction nsmallest(n::Int, arr::AbstractVector; lt=isless, by=identity)\n    order = Base.ord(lt, by, nothing)\n    return nextreme(order, n, arr)\nend\n"}, "files_after": {"src/heaps.jl": "# Various heap implementation\n\n###########################################################\n#\n#   Heap interface specification\n#\n#   Each heap is associated with a handle type (H), and\n#   a value type v.\n#\n#   Here, the value type must be comparable, and a handle\n#   is an object through which one can refer to a specific\n#   node of the heap and thus update its value.\n#\n#   Each heap type must implement all of the following\n#   functions. Here, let h be a heap, i be a handle,\n#   v be a value and s be a size.\n#\n#   - length(h)           returns the number of elements\n#\n#   - isempty(h)          returns whether the heap is\n#                         empty\n#\n#   - empty!(h)           reset the heap\n#\n#   - push!(h, v)         add a value to the heap\n#\n#   - sizehint!(h, s)     set size hint to a heap\n#\n#   - first(h)            return the first (top) value of a heap\n#\n#   - pop!(h)             removes the first (top) value, and\n#                         returns it\n#\n#  For mutable heaps, it should also support\n#\n#   - push!(h, v)         adds a value to the heap and\n#                         returns a handle to v\n#\n#   - update!(h, i, v)    updates the value of an element\n#                         (referred to by the handle i)\n#\n#   - delete!(h, i)       deletes the node with\n#                         handle i from the heap\n#\n#   - top_with_handle(h)  return the top value of a heap\n#                         and its handle\n#\n#\n###########################################################\n\n# HT: handle type\n# VT: value type\n\nabstract type AbstractHeap{VT} end\n\nabstract type AbstractMutableHeap{VT,HT} <: AbstractHeap{VT} end\n\nabstract type AbstractMinMaxHeap{VT} <: AbstractHeap{VT} end\n\n# heap implementations\n\ninclude(\"heaps/binary_heap.jl\")\ninclude(\"heaps/mutable_binary_heap.jl\")\ninclude(\"heaps/minmax_heap.jl\")\n\n# generic functions\n\nBase.eltype(::Type{<:AbstractHeap{T}}) where T = T\n\n\"\"\"\n    extract_all!(h)\n\nReturn an array of heap elements in sorted order (heap head at first index).\n\nNote that for simple heaps (not mutable or minmax)\nsorting the internal array of elements in-place is faster.\n\"\"\"\nfunction extract_all!(h::AbstractHeap{VT}) where VT\n    n = length(h)\n    r = Vector{VT}(undef, n)\n    for i in 1 : n\n        r[i] = pop!(h)\n    end\n    return r\nend\n\n\"\"\"\n    extract_all_rev!(h)\n\nReturn an array of heap elements in reverse sorted order (heap head at last index).\n\nNote that for simple heaps (not mutable or minmax)\nsorting the internal array of elements in-place is faster.\n\"\"\"\nfunction extract_all_rev!(h::AbstractHeap{VT}) where VT\n    n = length(h)\n    r = Vector{VT}(undef, n)\n    for i in 1 : n\n        r[n + 1 - i] = pop!(h)\n    end\n    return r\nend\n\n# Array functions using heaps\n\n\"\"\"\n    nextreme(ord, n, arr)\n\nreturn an array of the first `n` values of `arr` sorted by `ord`.\n\"\"\"\nfunction nextreme(ord::Base.Ordering, n::Int, arr::AbstractVector{T}) where T\n    Base.require_one_based_indexing(arr)\n    if n <= 0\n        return T[] # sort(arr)[1:n] returns [] for n <= 0\n    elseif n >= length(arr)\n        return sort(arr, order = ord)\n    end\n\n    rev = Base.ReverseOrdering(ord)\n\n    buffer = heapify!(arr[1:n], rev)\n\n    @inbounds for i = n + 1 : length(arr)\n        xi = arr[i]\n        if Base.lt(rev, buffer[1], xi)\n            buffer[1] = xi\n            percolate_down!(buffer, 1, rev)\n        end\n    end\n\n    return sort!(buffer, order = ord)\nend\n\n\"\"\"\n    nlargest(n, arr; kw...)\n\nReturn the `n` largest elements of the array `arr`.\n\nEquivalent to:\n    sort(arr, kw..., rev=true)[1:min(n, end)]\n\nNote that if `arr` contains floats and is free of NaN values,\nthen the following alternative may be used to achieve 2x performance:\n\n    DataStructures.nextreme(DataStructures.FasterReverse(), n, arr)\n\nThis faster version is equivalent to:\n\n    sort(arr, lt = >)[1:min(n, end)]\n\"\"\"\nfunction nlargest(n::Int, arr::AbstractVector; lt=isless, by=identity)\n    order = Base.ReverseOrdering(Base.ord(lt, by, nothing))\n    return nextreme(order, n, arr)\nend\n\n\"\"\"\n    nsmallest(n, arr; kw...)\n\nReturn the `n` smallest elements of the array `arr`.\n\nEquivalent to:\n    sort(arr; kw...)[1:min(n, end)]\n\nNote that if `arr` contains floats and is free of NaN values,\nthen the following alternative may be used to achieve 2x performance:\n\n    DataStructures.nextreme(DataStructures.FasterForward(), n, arr)\n\nThis faster version is equivalent to:\n\n    sort(arr, lt = <)[1:min(n, end)]\n\"\"\"\nfunction nsmallest(n::Int, arr::AbstractVector; lt=isless, by=identity)\n    order = Base.ord(lt, by, nothing)\n    return nextreme(order, n, arr)\nend\n"}, "source_files_changed": ["src/heaps.jl"], "test_files_changed": [], "lines_changed": 9, "is_valid": true, "validation_errors": []}
{"repo": "DataStructures.jl", "commit_sha": "708eeae706f1f26b6f10a7590824166427802a82", "parent_sha": "c86628e81eddcb849d4cf733c8e002101906e95e", "commit_message": "Improve bounds checks in heap operations", "commit_date": "2025-07-29T17:37:06+02:00", "action": {"type": "MODIFY_METHOD", "target_file": "src/heaps.jl", "target_symbol": "nextreme", "signature": null, "confidence": 0.6}, "files_before": {"src/heaps.jl": "# Various heap implementation\n\n###########################################################\n#\n#   Heap interface specification\n#\n#   Each heap is associated with a handle type (H), and\n#   a value type v.\n#\n#   Here, the value type must be comparable, and a handle\n#   is an object through which one can refer to a specific\n#   node of the heap and thus update its value.\n#\n#   Each heap type must implement all of the following\n#   functions. Here, let h be a heap, i be a handle,\n#   v be a value and s be a size.\n#\n#   - length(h)           returns the number of elements\n#\n#   - isempty(h)          returns whether the heap is\n#                         empty\n#\n#   - empty!(h)           reset the heap\n#\n#   - push!(h, v)         add a value to the heap\n#\n#   - sizehint!(h, s)     set size hint to a heap\n#\n#   - first(h)            return the first (top) value of a heap\n#\n#   - pop!(h)             removes the first (top) value, and\n#                         returns it\n#\n#  For mutable heaps, it should also support\n#\n#   - push!(h, v)         adds a value to the heap and\n#                         returns a handle to v\n#\n#   - update!(h, i, v)    updates the value of an element\n#                         (referred to by the handle i)\n#\n#   - delete!(h, i)       deletes the node with\n#                         handle i from the heap\n#\n#   - top_with_handle(h)  return the top value of a heap\n#                         and its handle\n#\n#\n###########################################################\n\n# HT: handle type\n# VT: value type\n\nabstract type AbstractHeap{VT} end\n\nabstract type AbstractMutableHeap{VT,HT} <: AbstractHeap{VT} end\n\nabstract type AbstractMinMaxHeap{VT} <: AbstractHeap{VT} end\n\n# heap implementations\n\ninclude(\"heaps/binary_heap.jl\")\ninclude(\"heaps/mutable_binary_heap.jl\")\ninclude(\"heaps/minmax_heap.jl\")\n\n# generic functions\n\nBase.eltype(::Type{<:AbstractHeap{T}}) where T = T\n\n\"\"\"\n    extract_all!(h)\n\nReturn an array of heap elements in sorted order (heap head at first index).\n\nNote that for simple heaps (not mutable or minmax)\nsorting the internal array of elements in-place is faster.\n\"\"\"\nfunction extract_all!(h::AbstractHeap{VT}) where VT\n    n = length(h)\n    r = Vector{VT}(undef, n)\n    for i in 1 : n\n        r[i] = pop!(h)\n    end\n    return r\nend\n\n\"\"\"\n    extract_all_rev!(h)\n\nReturn an array of heap elements in reverse sorted order (heap head at last index).\n\nNote that for simple heaps (not mutable or minmax)\nsorting the internal array of elements in-place is faster.\n\"\"\"\nfunction extract_all_rev!(h::AbstractHeap{VT}) where VT\n    n = length(h)\n    r = Vector{VT}(undef, n)\n    for i in 1 : n\n        r[n + 1 - i] = pop!(h)\n    end\n    return r\nend\n\n# Array functions using heaps\n\n\"\"\"\n    nextreme(ord, n, arr)\n\nreturn an array of the first `n` values of `arr` sorted by `ord`.\n\"\"\"\nfunction nextreme(ord::Base.Ordering, n::Int, arr::AbstractVector{T}) where T\n    if n <= 0\n        return T[] # sort(arr)[1:n] returns [] for n <= 0\n    elseif n >= length(arr)\n        return sort(arr, order = ord)\n    end\n\n    rev = Base.ReverseOrdering(ord)\n\n    buffer = heapify(arr[1:n], rev)\n\n    for i = n + 1 : length(arr)\n        @inbounds xi = arr[i]\n        if Base.lt(rev, buffer[1], xi)\n            buffer[1] = xi\n            percolate_down!(buffer, 1, rev)\n        end\n    end\n\n    return sort!(buffer, order = ord)\nend\n\n\"\"\"\n    nlargest(n, arr; kw...)\n\nReturn the `n` largest elements of the array `arr`.\n\nEquivalent to:\n    sort(arr, kw..., rev=true)[1:min(n, end)]\n\nNote that if `arr` contains floats and is free of NaN values,\nthen the following alternative may be used to achieve 2x performance:\n\n    DataStructures.nextreme(DataStructures.FasterReverse(), n, arr)\n\nThis faster version is equivalent to:\n\n    sort(arr, lt = >)[1:min(n, end)]\n\"\"\"\nfunction nlargest(n::Int, arr::AbstractVector; lt=isless, by=identity)\n    order = Base.ReverseOrdering(Base.ord(lt, by, nothing))\n    return nextreme(order, n, arr)\nend\n\n\"\"\"\n    nsmallest(n, arr; kw...)\n\nReturn the `n` smallest elements of the array `arr`.\n\nEquivalent to:\n    sort(arr; kw...)[1:min(n, end)]\n\nNote that if `arr` contains floats and is free of NaN values,\nthen the following alternative may be used to achieve 2x performance:\n\n    DataStructures.nextreme(DataStructures.FasterForward(), n, arr)\n\nThis faster version is equivalent to:\n\n    sort(arr, lt = <)[1:min(n, end)]\n\"\"\"\nfunction nsmallest(n::Int, arr::AbstractVector; lt=isless, by=identity)\n    order = Base.ord(lt, by, nothing)\n    return nextreme(order, n, arr)\nend\n", "src/heaps/arrays_as_heaps.jl": "# This contains code that was formerly a part of Julia. License is MIT: http://julialang.org/license\n\nusing Base.Order: Forward, Ordering, lt\n\nconst DefaultReverseOrdering = Base.ReverseOrdering{Base.ForwardOrdering}\n\n# Heap operations on flat arrays\n# ------------------------------\n\n\n# Binary heap indexing\nheapleft(i::Integer) = 2i\nheapright(i::Integer) = 2i + 1\nheapparent(i::Integer) = div(i, 2)\n\n\n# Binary min-heap percolate down.\nfunction percolate_down!(xs::AbstractArray, i::Integer, x=xs[i], o::Ordering=Forward, len::Integer=length(xs))\n    @inbounds while (l = heapleft(i)) <= len\n        r = heapright(i)\n        j = r > len || lt(o, xs[l], xs[r]) ? l : r\n        lt(o, xs[j], x) || break\n        xs[i] = xs[j]\n        i = j\n    end\n    xs[i] = x\nend\n\npercolate_down!(xs::AbstractArray, i::Integer, o::Ordering, len::Integer=length(xs)) = percolate_down!(xs, i, xs[i], o, len)\n\n\n# Binary min-heap percolate up.\nfunction percolate_up!(xs::AbstractArray, i::Integer, x=xs[i], o::Ordering=Forward)\n    @inbounds while (j = heapparent(i)) >= 1\n        lt(o, x, xs[j]) || break\n        xs[i] = xs[j]\n        i = j\n    end\n    xs[i] = x\nend\n\n@inline percolate_up!(xs::AbstractArray, i::Integer, o::Ordering) = percolate_up!(xs, i, xs[i], o)\n\n\"\"\"\n    heappop!(v, [ord])\n\nGiven a binary heap-ordered array, remove and return the lowest ordered element.\nFor efficiency, this function does not check that the array is indeed heap-ordered.\n\"\"\"\nfunction heappop!(xs::AbstractArray, o::Ordering=Forward)\n    x = xs[1]\n    y = pop!(xs)\n    if !isempty(xs)\n        percolate_down!(xs, 1, y, o)\n    end\n    return x\nend\n\n\"\"\"\n    heappush!(v, x, [ord])\n\nGiven a binary heap-ordered array, push a new element `x`, preserving the heap property.\nFor efficiency, this function does not check that the array is indeed heap-ordered.\n\"\"\"\n@inline function heappush!(xs::AbstractArray, x, o::Ordering=Forward)\n    push!(xs, x)\n    percolate_up!(xs, length(xs), o)\n    return xs\nend\n\n\n# Turn an arbitrary array into a binary min-heap (by default) in linear time.\n\"\"\"\n    heapify!(v, ord::Ordering=Forward)\n\nIn-place [`heapify`](@ref).\n\"\"\"\n@inline function heapify!(xs::AbstractArray, o::Ordering=Forward)\n    for i in heapparent(length(xs)):-1:1\n        percolate_down!(xs, i, o)\n    end\n    return xs\nend\n\n\"\"\"\n    heapify(v, ord::Ordering=Forward)\n\nReturns a new vector in binary heap order, optionally using the given ordering.\n```jldoctest\njulia> a = [1,3,4,5,2];\n\njulia> heapify(a)\n5-element Array{Int64,1}:\n 1\n 2\n 4\n 5\n 3\n\njulia> heapify(a, Base.Order.Reverse)\n5-element Array{Int64,1}:\n 5\n 3\n 4\n 1\n 2\n```\n\"\"\"\n# Todo, benchmarking shows copy(xs) outperforms copyto!(similar(xs), xs) for 10^6 Float64\nheapify(xs::AbstractArray, o::Ordering=Forward) = heapify!(copyto!(similar(xs), xs), o)\n\n\"\"\"\n    isheap(v, ord::Ordering=Forward)\n\nReturn `true` if an array is heap-ordered according to the given order.\n\n```jldoctest\njulia> a = [1,2,3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> isheap(a,Base.Order.Forward)\ntrue\n\njulia> isheap(a,Base.Order.Reverse)\nfalse\n```\n\"\"\"\nfunction isheap(xs::AbstractArray, o::Ordering=Forward)\n    for i in 1:div(length(xs), 2)\n        if lt(o, xs[heapleft(i)], xs[i]) ||\n           (heapright(i) <= length(xs) && lt(o, xs[heapright(i)], xs[i]))\n            return false\n        end\n    end\n    return true\nend\n", "src/priorityqueue.jl": "# This file contains code that was formerly a part of Julia. License is MIT: http://julialang.org/license\n\n# PriorityQueue\n# -------------\n\n\"\"\"\n    PriorityQueue{K, V}([ord])\n\nConstruct a new `PriorityQueue`, with keys of type `K` and values/priorities\nof type `V`. If an order is not given, the priority queue is min-ordered using\nthe default comparison for `V`.\n\nA `PriorityQueue` acts like a `Dict`, mapping values to their\npriorities. New elements are added using `push!` and retrieved\nusing `popfirst!` or `popat!` based on their priority.\n\nParameters\n---------\n\n`K::Type` Data type for the keys\n\n`V::Type` Data type for the values/priorities\n\n`ord::Base.Ordering` Priority queue ordering\n\n# Examples\n```jldoctest\njulia> PriorityQueue(Base.Order.Forward, \"a\" => 2, \"b\" => 3, \"c\" => 1)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 3 entries:\n  \"c\" => 1\n  \"a\" => 2\n  \"b\" => 3\n```\n\"\"\"\nstruct PriorityQueue{K,V,O<:Ordering} <: AbstractDict{K,V}\n    # Binary heap of (element, priority) pairs.\n    xs::Vector{Pair{K,V}}\n    o::O\n\n    # Map elements to their index in xs\n    index::Dict{K, Int}\n\n    function PriorityQueue{K,V,O}(o::O) where {K,V,O<:Ordering}\n        new{K,V,O}(Vector{Pair{K,V}}(), o, Dict{K, Int}())\n    end\n\n    PriorityQueue{K, V, O}(xs::Vector{Pair{K,V}}, o::O, index::Dict{K, Int}) where {K,V,O<:Ordering} = new(xs, o, index)\n\n    function PriorityQueue{K,V,O}(o::O, itr) where {K,V,O<:Ordering}\n        xs = Vector{Pair{K,V}}(undef, length(itr))\n        index = Dict{K, Int}()\n        for (i, (k, v)) in enumerate(itr)\n            xs[i] = Pair{K,V}(k, v)\n            if haskey(index, k)\n                throw(ArgumentError(\"PriorityQueue keys must be unique\"))\n            end\n            index[k] = i\n        end\n        pq = new{K,V,O}(xs, o, index)\n\n        # heapify\n        for i in heapparent(length(pq.xs)):-1:1\n            percolate_down!(pq, i)\n        end\n\n        return pq\n    end\nend\n\n# A copy constructor\nPriorityQueue(xs::Vector{Pair{K,V}}, o::O, index::Dict{K, Int}) where {K,V,O<:Ordering} =\n    PriorityQueue{K,V,O}(xs, o, index)\n\n# Any-Any constructors\nPriorityQueue(o::Ordering=Forward) = PriorityQueue{Any,Any,typeof(o)}(o)\n\n# Construction from Pairs\nPriorityQueue(ps::Pair...) = PriorityQueue(Forward, ps)\nPriorityQueue(o::Ordering, ps::Pair...) = PriorityQueue(o, ps)\nPriorityQueue{K,V}(ps::Pair...) where {K,V} = PriorityQueue{K,V,ForwardOrdering}(Forward, ps)\nPriorityQueue{K,V}(o::Ord, ps::Pair...) where {K,V,Ord<:Ordering} = PriorityQueue{K,V,Ord}(o, ps)\n\n# Construction specifying Key/Value types\n# e.g., PriorityQueue{Int,Float64}([1=>1, 2=>2.0])\nPriorityQueue{K,V}(kv) where {K,V} = PriorityQueue{K,V}(Forward, kv)\nfunction PriorityQueue{K,V}(o::Ord, kv) where {K,V,Ord<:Ordering}\n    try\n        PriorityQueue{K,V,Ord}(o, kv)\n    catch e\n        if not_iterator_of_pairs(kv)\n            throw(ArgumentError(\"PriorityQueue(kv): kv needs to be an iterator of tuples or pairs\"))\n        else\n            rethrow(e)\n        end\n    end\nend\n\n# Construction inferring Key/Value types from input\n# e.g. PriorityQueue{}\n\nPriorityQueue(o1::Ordering, o2::Ordering) = throw(ArgumentError(\"PriorityQueue with two parameters must be called with an Ordering and an iterable of pairs\"))\nPriorityQueue(kv, o::Ordering=Forward) = PriorityQueue(o, kv)\nfunction PriorityQueue(o::Ordering, kv)\n    try\n        _priority_queue_with_eltype(o, kv, eltype(kv))\n    catch e\n        if not_iterator_of_pairs(kv)\n            throw(ArgumentError(\"PriorityQueue(kv): kv needs to be an iterator of tuples or pairs\"))\n        else\n            rethrow(e)\n        end\n    end\nend\n\n_priority_queue_with_eltype(o::Ord, ps, ::Type{Pair{K,V}} ) where {K,V,Ord} = PriorityQueue{  K,  V,Ord}(o, ps)\n_priority_queue_with_eltype(o::Ord, kv, ::Type{Tuple{K,V}}) where {K,V,Ord} = PriorityQueue{  K,  V,Ord}(o, kv)\n_priority_queue_with_eltype(o::Ord, ps, ::Type{Pair{K}}   ) where {K,  Ord} = PriorityQueue{  K,Any,Ord}(o, ps)\n_priority_queue_with_eltype(o::Ord, kv, ::Type            ) where {    Ord} = PriorityQueue{Any,Any,Ord}(o, kv)\n\n## TODO: It seems impossible (or at least very challenging) to create the eltype below.\n##       If deemed possible, please create a test and uncomment this definition.\n# _priority_queue_with_eltype{  D,Ord}(o::Ord, ps, ::Type{Pair{K,V} where K}) = PriorityQueue{Any,  D,Ord}(o, ps)\n\n\n\"\"\"\n    length(pq::PriorityQueue)\n\nReturn the number of pairs (`k`, `v`) in the priority queue `pq`.\n\"\"\"\nBase.length(pq::PriorityQueue) = length(pq.xs)\n\n\"\"\"\n    isempty(pq::PriorityQueue)\n\nVerify if priority queue `pq` is empty.\n\"\"\"\nBase.isempty(pq::PriorityQueue) = isempty(pq.xs)\n\n\"\"\"\n    haskey(pq::PriorityQueue, key)\n\nVerify if priority queue `pq` has `key` in its keys.\n\n# Example\n\n```jldoctest\njulia> pq = PriorityQueue(\"a\" => 1, \"b\" => 2, \"c\" => 3)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 3 entries:\n  \"a\" => 1\n  \"b\" => 2\n  \"c\" => 3\n\njulia> haskey(pq, \"a\")\ntrue\n\njulia> haskey(pq, \"e\")\nfalse\n```\n\"\"\"\nBase.haskey(pq::PriorityQueue, key) = haskey(pq.index, key)\n\n\"\"\"\n    first(pq::PriorityQueue)\n\nReturn the lowest priority pair (`k`, `v`) from `pq` without removing it from the\npriority queue.\n\"\"\"\nBase.first(pq::PriorityQueue) = first(pq.xs)\n\nfunction percolate_down!(pq::PriorityQueue, i::Integer)\n    x = pq.xs[i]\n    @inbounds while (l = heapleft(i)) <= length(pq)\n        r = heapright(i)\n        j = r > length(pq) || lt(pq.o, pq.xs[l].second, pq.xs[r].second) ? l : r\n        xj = pq.xs[j]\n        if lt(pq.o, xj.second, x.second)\n            pq.index[xj.first] = i\n            pq.xs[i] = xj\n            i = j\n        else\n            break\n        end\n    end\n    pq.index[x.first] = i\n    pq.xs[i] = x\nend\n\n\nfunction percolate_up!(pq::PriorityQueue, i::Integer)\n    x = pq.xs[i]\n    @inbounds while i > 1\n        j = heapparent(i)\n        xj = pq.xs[j]\n        if lt(pq.o, x.second, xj.second)\n            pq.index[xj.first] = i\n            pq.xs[i] = xj\n            i = j\n        else\n            break\n        end\n    end\n    pq.index[x.first] = i\n    pq.xs[i] = x\nend\n\n# Equivalent to percolate_up! with an element having lower priority than any other\nfunction force_up!(pq::PriorityQueue, i::Integer)\n    x = pq.xs[i]\n    @inbounds while i > 1\n        j = heapparent(i)\n        pq.index[pq.xs[j].first] = i\n        pq.xs[i] = pq.xs[j]\n        i = j\n    end\n    pq.index[x.first] = i\n    pq.xs[i] = x\nend\n\nBase.getindex(pq::PriorityQueue, key) = pq.xs[pq.index[key]].second\n\nfunction Base.get(pq::PriorityQueue, key, default)\n    i = get(pq.index, key, 0)\n    i == 0 ? default : pq.xs[i].second\nend\n\nfunction Base.get!(pq::PriorityQueue, key, default)\n    i = get(pq.index, key, 0)\n    if i == 0\n        push!(pq, key=>default)\n        return default\n    else\n        return pq.xs[i].second\n    end\nend\n\n# Change the priority of an existing element, or enqueue it if it isn't present.\nfunction Base.setindex!(pq::PriorityQueue{K, V}, value, key) where {K,V}\n    i = get(pq.index, key, 0)\n    if i != 0\n        @inbounds oldvalue = pq.xs[i].second\n        pq.xs[i] = Pair{K,V}(key, value)\n        if lt(pq.o, oldvalue, value)\n            percolate_down!(pq, i)\n        else\n            percolate_up!(pq, i)\n        end\n    else\n        push!(pq, key=>value)\n    end\n    return value\nend\n\n\"\"\"\n    push!(pq::PriorityQueue{K,V}, pair::Pair{K,V}) where {K,V}\n\nInsert the a key `k` into a priority queue `pq` with priority `v`.\n\n# Examples \n\n```jldoctest\njulia> a = PriorityQueue(\"a\" => 1, \"b\" => 2, \"c\" => 3, \"e\" => 5)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 4 entries:\n  \"a\" => 1\n  \"b\" => 2\n  \"c\" => 3\n  \"e\" => 5\n\njulia> push!(a, \"d\" => 4)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 5 entries:\n  \"a\" => 1\n  \"b\" => 2\n  \"c\" => 3\n  \"d\" => 4\n  \"e\" => 5\n```\n\"\"\"\nfunction Base.push!(pq::PriorityQueue{K,V}, pair::Pair{K,V}) where {K,V}\n    key = pair.first\n    if haskey(pq, key)\n        throw(ArgumentError(\"PriorityQueue keys must be unique\"))\n    end\n    push!(pq.xs, pair)\n    pq.index[key] = length(pq)\n    percolate_up!(pq, length(pq))\n\n    return pq\nend\n\nBase.push!(pq::PriorityQueue{K,V}, kv::Pair) where {K,V} = push!(pq, Pair{K,V}(kv.first, kv.second))\n\n\"\"\"\n    popfirst!(pq::PriorityQueue)\n\nRemove and return the lowest priority key and value from a priority queue `pq` as a pair.\n\n# Examples\n\n```jldoctest\njulia> a = PriorityQueue(Base.Order.Forward, \"a\" => 2, \"b\" => 3, \"c\" => 1)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 3 entries:\n  \"c\" => 1\n  \"a\" => 2\n  \"b\" => 3\n\njulia> popfirst!(a)\n\"c\" => 1\n\njulia> a\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 2 entries:\n  \"a\" => 2\n  \"b\" => 3\n```\n\"\"\"\nfunction Base.popfirst!(pq::PriorityQueue)\n    x = pq.xs[1]\n    y = pop!(pq.xs)\n    if !isempty(pq)\n        @inbounds pq.xs[1] = y\n        pq.index[y.first] = 1\n        percolate_down!(pq, 1)\n    end\n    delete!(pq.index, x.first)\n    return x\nend\n\nfunction Base.popat!(pq::PriorityQueue, key)\n    idx = pq.index[key]\n    force_up!(pq, idx)\n    popfirst!(pq)\nend\n\n\"\"\"\n    delete!(pq::PriorityQueue, key)\n\nDelete the mapping for the given `key` in a priority queue `pq` and return the priority queue.\n\n# Examples\n\n```jldoctest\njulia> q = PriorityQueue(Base.Order.Forward, \"a\" => 2, \"b\" => 3, \"c\" => 1)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 3 entries:\n  \"c\" => 1\n  \"a\" => 2\n  \"b\" => 3\njulia> delete!(q, \"b\")\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 2 entries:\n  \"c\" => 1\n  \"a\" => 2\n```\n\"\"\"\nfunction Base.delete!(pq::PriorityQueue, key)\n    popat!(pq, key)\n    return pq\nend\n\n\"\"\"\n    empty!(pq::PriorityQueue)  \n\nReset priority queue `pq`.\n\"\"\"\nfunction Base.empty!(pq::PriorityQueue)\n    empty!(pq.xs)\n    empty!(pq.index)\n    return pq\nend\n\nBase.empty(pq::PriorityQueue) = PriorityQueue(empty(pq.xs), pq.o, empty(pq.index))\n\nBase.merge!(d::SortedDict, other::PriorityQueue) = invoke(merge!, Tuple{AbstractDict, PriorityQueue}, d, other)\n\nfunction Base.merge!(d::AbstractDict, other::PriorityQueue)\n    next = iterate(other, false)\n    while next !== nothing\n        (k, v), state = next\n        d[k] = v\n        next = iterate(other, state)\n    end\n    return d\nend\n\nfunction Base.merge!(combine::Function, d::AbstractDict, other::PriorityQueue)\n    next = iterate(other, false)\n    while next !== nothing\n        (k, v), state = next\n        d[k] = haskey(d, k) ? combine(d[k], v) : v\n        next = iterate(other, state)\n    end\n    return d\nend\n\n# Opaque not to be exported.\nmutable struct _PQIteratorState{K, V, O <: Ordering}\n    pq::PriorityQueue{K, V, O}\n    _PQIteratorState{K, V, O}(pq::PriorityQueue{K, V, O}) where {K, V, O <: Ordering} = new(pq)\nend\n\n_PQIteratorState(pq::PriorityQueue{K, V, O}) where {K, V, O <: Ordering} = _PQIteratorState{K, V, O}(pq)\n\n# Unordered iteration through key value pairs in a PriorityQueue\n# O(n) iteration.\nfunction _iterate(pq::PriorityQueue, state)\n    (k, idx), i = state\n    return (pq.xs[idx], i)\nend\n_iterate(pq::PriorityQueue, ::Nothing) = nothing\n\nBase.iterate(pq::PriorityQueue, ::Nothing) = nothing\n\nfunction Base.iterate(pq::PriorityQueue, ordered::Bool=true)\n    if ordered\n        isempty(pq) && return nothing\n        state = _PQIteratorState(PriorityQueue(copy(pq.xs), pq.o, copy(pq.index)))\n        return popfirst!(state.pq), state\n    else\n        _iterate(pq, iterate(pq.index))\n    end\nend\n\nfunction Base.iterate(pq::PriorityQueue, state::_PQIteratorState)\n    isempty(state.pq) && return nothing\n    return popfirst!(state.pq), state\nend\n\nBase.iterate(pq::PriorityQueue, i) = _iterate(pq, iterate(pq.index, i))\n"}, "files_after": {"src/heaps.jl": "# Various heap implementation\n\n###########################################################\n#\n#   Heap interface specification\n#\n#   Each heap is associated with a handle type (H), and\n#   a value type v.\n#\n#   Here, the value type must be comparable, and a handle\n#   is an object through which one can refer to a specific\n#   node of the heap and thus update its value.\n#\n#   Each heap type must implement all of the following\n#   functions. Here, let h be a heap, i be a handle,\n#   v be a value and s be a size.\n#\n#   - length(h)           returns the number of elements\n#\n#   - isempty(h)          returns whether the heap is\n#                         empty\n#\n#   - empty!(h)           reset the heap\n#\n#   - push!(h, v)         add a value to the heap\n#\n#   - sizehint!(h, s)     set size hint to a heap\n#\n#   - first(h)            return the first (top) value of a heap\n#\n#   - pop!(h)             removes the first (top) value, and\n#                         returns it\n#\n#  For mutable heaps, it should also support\n#\n#   - push!(h, v)         adds a value to the heap and\n#                         returns a handle to v\n#\n#   - update!(h, i, v)    updates the value of an element\n#                         (referred to by the handle i)\n#\n#   - delete!(h, i)       deletes the node with\n#                         handle i from the heap\n#\n#   - top_with_handle(h)  return the top value of a heap\n#                         and its handle\n#\n#\n###########################################################\n\n# HT: handle type\n# VT: value type\n\nabstract type AbstractHeap{VT} end\n\nabstract type AbstractMutableHeap{VT,HT} <: AbstractHeap{VT} end\n\nabstract type AbstractMinMaxHeap{VT} <: AbstractHeap{VT} end\n\n# heap implementations\n\ninclude(\"heaps/binary_heap.jl\")\ninclude(\"heaps/mutable_binary_heap.jl\")\ninclude(\"heaps/minmax_heap.jl\")\n\n# generic functions\n\nBase.eltype(::Type{<:AbstractHeap{T}}) where T = T\n\n\"\"\"\n    extract_all!(h)\n\nReturn an array of heap elements in sorted order (heap head at first index).\n\nNote that for simple heaps (not mutable or minmax)\nsorting the internal array of elements in-place is faster.\n\"\"\"\nfunction extract_all!(h::AbstractHeap{VT}) where VT\n    n = length(h)\n    r = Vector{VT}(undef, n)\n    for i in 1 : n\n        r[i] = pop!(h)\n    end\n    return r\nend\n\n\"\"\"\n    extract_all_rev!(h)\n\nReturn an array of heap elements in reverse sorted order (heap head at last index).\n\nNote that for simple heaps (not mutable or minmax)\nsorting the internal array of elements in-place is faster.\n\"\"\"\nfunction extract_all_rev!(h::AbstractHeap{VT}) where VT\n    n = length(h)\n    r = Vector{VT}(undef, n)\n    for i in 1 : n\n        r[n + 1 - i] = pop!(h)\n    end\n    return r\nend\n\n# Array functions using heaps\n\n\"\"\"\n    nextreme(ord, n, arr)\n\nreturn an array of the first `n` values of `arr` sorted by `ord`.\n\"\"\"\nfunction nextreme(ord::Base.Ordering, n::Int, arr::AbstractVector{T}) where T\n    if n <= 0\n        return T[] # sort(arr)[1:n] returns [] for n <= 0\n    elseif n >= length(arr)\n        return sort(arr, order = ord)\n    end\n\n    rev = Base.ReverseOrdering(ord)\n\n    buffer = heapify!(arr[1:n], rev)\n\n    @inbounds for i = n + 1 : length(arr)\n        xi = arr[i]\n        if Base.lt(rev, buffer[1], xi)\n            buffer[1] = xi\n            percolate_down!(buffer, 1, rev)\n        end\n    end\n\n    return sort!(buffer, order = ord)\nend\n\n\"\"\"\n    nlargest(n, arr; kw...)\n\nReturn the `n` largest elements of the array `arr`.\n\nEquivalent to:\n    sort(arr, kw..., rev=true)[1:min(n, end)]\n\nNote that if `arr` contains floats and is free of NaN values,\nthen the following alternative may be used to achieve 2x performance:\n\n    DataStructures.nextreme(DataStructures.FasterReverse(), n, arr)\n\nThis faster version is equivalent to:\n\n    sort(arr, lt = >)[1:min(n, end)]\n\"\"\"\nfunction nlargest(n::Int, arr::AbstractVector; lt=isless, by=identity)\n    order = Base.ReverseOrdering(Base.ord(lt, by, nothing))\n    return nextreme(order, n, arr)\nend\n\n\"\"\"\n    nsmallest(n, arr; kw...)\n\nReturn the `n` smallest elements of the array `arr`.\n\nEquivalent to:\n    sort(arr; kw...)[1:min(n, end)]\n\nNote that if `arr` contains floats and is free of NaN values,\nthen the following alternative may be used to achieve 2x performance:\n\n    DataStructures.nextreme(DataStructures.FasterForward(), n, arr)\n\nThis faster version is equivalent to:\n\n    sort(arr, lt = <)[1:min(n, end)]\n\"\"\"\nfunction nsmallest(n::Int, arr::AbstractVector; lt=isless, by=identity)\n    order = Base.ord(lt, by, nothing)\n    return nextreme(order, n, arr)\nend\n", "src/heaps/arrays_as_heaps.jl": "# This contains code that was formerly a part of Julia. License is MIT: http://julialang.org/license\n\nusing Base.Order: Forward, Ordering, lt\n\nconst DefaultReverseOrdering = Base.ReverseOrdering{Base.ForwardOrdering}\n\n# Heap operations on flat arrays\n# ------------------------------\n\n\n# Binary heap indexing\nheapleft(i::Integer) = 2i\nheapright(i::Integer) = 2i + 1\nheapparent(i::Integer) = div(i, 2)\n\n# Binary min-heap percolate down.\nBase.@propagate_inbounds function percolate_down!(xs::AbstractArray, i::Integer, x, o::Ordering=Forward, len::Integer=length(xs))\n    @boundscheck checkbounds(xs, i)\n    @boundscheck checkbounds(xs, len)\n\n    @inbounds while (l = heapleft(i)) <= len\n        r = heapright(i)\n        j = r > len || lt(o, xs[l], xs[r]) ? l : r\n        lt(o, xs[j], x) || break\n        xs[i] = xs[j]\n        i = j\n    end\n    @inbounds xs[i] = x\nend\nBase.@propagate_inbounds percolate_down!(xs::AbstractArray, i::Integer, o::Ordering, len::Integer=length(xs)) = percolate_down!(xs, i, xs[i], o, len)\n\n\n# Binary min-heap percolate up.\nBase.@propagate_inbounds function percolate_up!(xs::AbstractArray, i::Integer, x, o::Ordering=Forward)\n    @boundscheck checkbounds(xs, i)\n\n    @inbounds while (j = heapparent(i)) >= 1\n        lt(o, x, xs[j]) || break\n        xs[i] = xs[j]\n        i = j\n    end\n    @inbounds xs[i] = x\nend\nBase.@propagate_inbounds percolate_up!(xs::AbstractArray, i::Integer, o::Ordering) = percolate_up!(xs, i, xs[i], o)\n\n\"\"\"\n    heappop!(v, [ord])\n\nGiven a binary heap-ordered array, remove and return the lowest ordered element.\nFor efficiency, this function does not check that the array is indeed heap-ordered.\n\"\"\"\nfunction heappop!(xs::AbstractArray, o::Ordering=Forward)\n    Base.require_one_based_indexing(xs)\n    x = xs[1]\n    y = pop!(xs)\n    if !isempty(xs)\n        @inbounds percolate_down!(xs, 1, y, o)\n    end\n    return x\nend\n\n\"\"\"\n    heappush!(v, x, [ord])\n\nGiven a binary heap-ordered array, push a new element `x`, preserving the heap property.\nFor efficiency, this function does not check that the array is indeed heap-ordered.\n\"\"\"\n@inline function heappush!(xs::AbstractArray, x, o::Ordering=Forward)\n    Base.require_one_based_indexing(xs)\n    push!(xs, x)\n    @inbounds percolate_up!(xs, length(xs), o)\n    return xs\nend\n\n\n# Turn an arbitrary array into a binary min-heap (by default) in linear time.\n\"\"\"\n    heapify!(v, ord::Ordering=Forward)\n\nIn-place [`heapify`](@ref).\n\"\"\"\n@inline function heapify!(xs::AbstractArray, o::Ordering=Forward)\n    Base.require_one_based_indexing(xs)\n    for i in heapparent(length(xs)):-1:1\n        @inbounds percolate_down!(xs, i, o)\n    end\n    return xs\nend\n\n\"\"\"\n    heapify(v, ord::Ordering=Forward)\n\nReturns a new vector in binary heap order, optionally using the given ordering.\n```jldoctest\njulia> a = [1,3,4,5,2];\n\njulia> heapify(a)\n5-element Array{Int64,1}:\n 1\n 2\n 4\n 5\n 3\n\njulia> heapify(a, Base.Order.Reverse)\n5-element Array{Int64,1}:\n 5\n 3\n 4\n 1\n 2\n```\n\"\"\"\n# Todo, benchmarking shows copy(xs) outperforms copyto!(similar(xs), xs) for 10^6 Float64\nheapify(xs::AbstractArray, o::Ordering=Forward) = heapify!(copyto!(similar(xs), xs), o)\n\n\"\"\"\n    isheap(v, ord::Ordering=Forward)\n\nReturn `true` if an array is heap-ordered according to the given order.\n\n```jldoctest\njulia> a = [1,2,3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> isheap(a,Base.Order.Forward)\ntrue\n\njulia> isheap(a,Base.Order.Reverse)\nfalse\n```\n\"\"\"\nfunction isheap(xs::AbstractArray, o::Ordering=Forward)\n    Base.require_one_based_indexing(xs)\n    for i in 1:div(length(xs), 2)\n        if lt(o, xs[heapleft(i)], xs[i]) ||\n           (heapright(i) <= length(xs) && lt(o, xs[heapright(i)], xs[i]))\n            return false\n        end\n    end\n    return true\nend\n", "src/priorityqueue.jl": "# This file contains code that was formerly a part of Julia. License is MIT: http://julialang.org/license\n\n# PriorityQueue\n# -------------\n\n\"\"\"\n    PriorityQueue{K, V}([ord])\n\nConstruct a new `PriorityQueue`, with keys of type `K` and values/priorities\nof type `V`. If an order is not given, the priority queue is min-ordered using\nthe default comparison for `V`.\n\nA `PriorityQueue` acts like a `Dict`, mapping values to their\npriorities. New elements are added using `push!` and retrieved\nusing `popfirst!` or `popat!` based on their priority.\n\nParameters\n---------\n\n`K::Type` Data type for the keys\n\n`V::Type` Data type for the values/priorities\n\n`ord::Base.Ordering` Priority queue ordering\n\n# Examples\n```jldoctest\njulia> PriorityQueue(Base.Order.Forward, \"a\" => 2, \"b\" => 3, \"c\" => 1)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 3 entries:\n  \"c\" => 1\n  \"a\" => 2\n  \"b\" => 3\n```\n\"\"\"\nstruct PriorityQueue{K,V,O<:Ordering} <: AbstractDict{K,V}\n    # Binary heap of (element, priority) pairs.\n    xs::Vector{Pair{K,V}}\n    o::O\n\n    # Map elements to their index in xs\n    index::Dict{K, Int}\n\n    function PriorityQueue{K,V,O}(o::O) where {K,V,O<:Ordering}\n        new{K,V,O}(Vector{Pair{K,V}}(), o, Dict{K, Int}())\n    end\n\n    PriorityQueue{K, V, O}(xs::Vector{Pair{K,V}}, o::O, index::Dict{K, Int}) where {K,V,O<:Ordering} = new(xs, o, index)\n\n    function PriorityQueue{K,V,O}(o::O, itr) where {K,V,O<:Ordering}\n        xs = Vector{Pair{K,V}}(undef, length(itr))\n        index = Dict{K, Int}()\n        @inbounds for (i, (k, v)) in enumerate(itr)\n            xs[i] = Pair{K,V}(k, v)\n            if haskey(index, k)\n                throw(ArgumentError(\"PriorityQueue keys must be unique\"))\n            end\n            index[k] = i\n        end\n        pq = new{K,V,O}(xs, o, index)\n\n        # heapify\n        for i in heapparent(length(pq.xs)):-1:1\n            @inbounds percolate_down!(pq, i)\n        end\n\n        return pq\n    end\nend\n\n# A copy constructor\nPriorityQueue(xs::Vector{Pair{K,V}}, o::O, index::Dict{K, Int}) where {K,V,O<:Ordering} =\n    PriorityQueue{K,V,O}(xs, o, index)\n\n# Any-Any constructors\nPriorityQueue(o::Ordering=Forward) = PriorityQueue{Any,Any,typeof(o)}(o)\n\n# Construction from Pairs\nPriorityQueue(ps::Pair...) = PriorityQueue(Forward, ps)\nPriorityQueue(o::Ordering, ps::Pair...) = PriorityQueue(o, ps)\nPriorityQueue{K,V}(ps::Pair...) where {K,V} = PriorityQueue{K,V,ForwardOrdering}(Forward, ps)\nPriorityQueue{K,V}(o::Ord, ps::Pair...) where {K,V,Ord<:Ordering} = PriorityQueue{K,V,Ord}(o, ps)\n\n# Construction specifying Key/Value types\n# e.g., PriorityQueue{Int,Float64}([1=>1, 2=>2.0])\nPriorityQueue{K,V}(kv) where {K,V} = PriorityQueue{K,V}(Forward, kv)\nfunction PriorityQueue{K,V}(o::Ord, kv) where {K,V,Ord<:Ordering}\n    try\n        PriorityQueue{K,V,Ord}(o, kv)\n    catch e\n        if not_iterator_of_pairs(kv)\n            throw(ArgumentError(\"PriorityQueue(kv): kv needs to be an iterator of tuples or pairs\"))\n        else\n            rethrow(e)\n        end\n    end\nend\n\n# Construction inferring Key/Value types from input\n# e.g. PriorityQueue{}\n\nPriorityQueue(o1::Ordering, o2::Ordering) = throw(ArgumentError(\"PriorityQueue with two parameters must be called with an Ordering and an iterable of pairs\"))\nPriorityQueue(kv, o::Ordering=Forward) = PriorityQueue(o, kv)\nfunction PriorityQueue(o::Ordering, kv)\n    try\n        _priority_queue_with_eltype(o, kv, eltype(kv))\n    catch e\n        if not_iterator_of_pairs(kv)\n            throw(ArgumentError(\"PriorityQueue(kv): kv needs to be an iterator of tuples or pairs\"))\n        else\n            rethrow(e)\n        end\n    end\nend\n\n_priority_queue_with_eltype(o::Ord, ps, ::Type{Pair{K,V}} ) where {K,V,Ord} = PriorityQueue{  K,  V,Ord}(o, ps)\n_priority_queue_with_eltype(o::Ord, kv, ::Type{Tuple{K,V}}) where {K,V,Ord} = PriorityQueue{  K,  V,Ord}(o, kv)\n_priority_queue_with_eltype(o::Ord, ps, ::Type{Pair{K}}   ) where {K,  Ord} = PriorityQueue{  K,Any,Ord}(o, ps)\n_priority_queue_with_eltype(o::Ord, kv, ::Type            ) where {    Ord} = PriorityQueue{Any,Any,Ord}(o, kv)\n\n## TODO: It seems impossible (or at least very challenging) to create the eltype below.\n##       If deemed possible, please create a test and uncomment this definition.\n# _priority_queue_with_eltype{  D,Ord}(o::Ord, ps, ::Type{Pair{K,V} where K}) = PriorityQueue{Any,  D,Ord}(o, ps)\n\n\n\"\"\"\n    length(pq::PriorityQueue)\n\nReturn the number of pairs (`k`, `v`) in the priority queue `pq`.\n\"\"\"\nBase.length(pq::PriorityQueue) = length(pq.xs)\n\n\"\"\"\n    isempty(pq::PriorityQueue)\n\nVerify if priority queue `pq` is empty.\n\"\"\"\nBase.isempty(pq::PriorityQueue) = isempty(pq.xs)\n\n\"\"\"\n    haskey(pq::PriorityQueue, key)\n\nVerify if priority queue `pq` has `key` in its keys.\n\n# Example\n\n```jldoctest\njulia> pq = PriorityQueue(\"a\" => 1, \"b\" => 2, \"c\" => 3)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 3 entries:\n  \"a\" => 1\n  \"b\" => 2\n  \"c\" => 3\n\njulia> haskey(pq, \"a\")\ntrue\n\njulia> haskey(pq, \"e\")\nfalse\n```\n\"\"\"\nBase.haskey(pq::PriorityQueue, key) = haskey(pq.index, key)\n\n\"\"\"\n    first(pq::PriorityQueue)\n\nReturn the lowest priority pair (`k`, `v`) from `pq` without removing it from the\npriority queue.\n\"\"\"\nBase.first(pq::PriorityQueue) = first(pq.xs)\n\nBase.@propagate_inbounds function percolate_down!(pq::PriorityQueue, i::Integer)\n    @boundscheck checkbounds(pq.xs, i)\n\n    @inbounds x = pq.xs[i]\n    @inbounds while (l = heapleft(i)) <= length(pq)\n        r = heapright(i)\n        j = r > length(pq) || lt(pq.o, pq.xs[l].second, pq.xs[r].second) ? l : r\n        xj = pq.xs[j]\n        if lt(pq.o, xj.second, x.second)\n            pq.index[xj.first] = i\n            pq.xs[i] = xj\n            i = j\n        else\n            break\n        end\n    end\n    pq.index[x.first] = i\n    @inbounds pq.xs[i] = x\nend\n\n\nBase.@propagate_inbounds function percolate_up!(pq::PriorityQueue, i::Integer)\n    @boundscheck checkbounds(pq.xs, i)\n\n    @inbounds x = pq.xs[i]\n    @inbounds while i > 1\n        j = heapparent(i)\n        xj = pq.xs[j]\n        if lt(pq.o, x.second, xj.second)\n            pq.index[xj.first] = i\n            pq.xs[i] = xj\n            i = j\n        else\n            break\n        end\n    end\n    pq.index[x.first] = i\n    @inbounds pq.xs[i] = x\nend\n\n# Equivalent to percolate_up! with an element having lower priority than any other\nfunction force_up!(pq::PriorityQueue, i::Integer)\n    x = pq.xs[i]\n    @inbounds while i > 1\n        j = heapparent(i)\n        pq.index[pq.xs[j].first] = i\n        pq.xs[i] = pq.xs[j]\n        i = j\n    end\n    pq.index[x.first] = i\n    pq.xs[i] = x\nend\n\nBase.getindex(pq::PriorityQueue, key) = pq.xs[pq.index[key]].second\n\nfunction Base.get(pq::PriorityQueue, key, default)\n    i = get(pq.index, key, 0)\n    i == 0 ? default : pq.xs[i].second\nend\n\nfunction Base.get!(pq::PriorityQueue, key, default)\n    i = get(pq.index, key, 0)\n    if i == 0\n        push!(pq, key=>default)\n        return default\n    else\n        return pq.xs[i].second\n    end\nend\n\n# Change the priority of an existing element, or enqueue it if it isn't present.\nfunction Base.setindex!(pq::PriorityQueue{K, V}, value, key) where {K,V}\n    i = get(pq.index, key, 0)\n    @inbounds if i != 0\n        oldvalue = pq.xs[i].second\n        pq.xs[i] = Pair{K,V}(key, value)\n        if lt(pq.o, oldvalue, value)\n            percolate_down!(pq, i)\n        else\n            percolate_up!(pq, i)\n        end\n    else\n        push!(pq, key=>value)\n    end\n    return value\nend\n\n\"\"\"\n    push!(pq::PriorityQueue{K,V}, pair::Pair{K,V}) where {K,V}\n\nInsert the a key `k` into a priority queue `pq` with priority `v`.\n\n# Examples\n\n```jldoctest\njulia> a = PriorityQueue(\"a\" => 1, \"b\" => 2, \"c\" => 3, \"e\" => 5)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 4 entries:\n  \"a\" => 1\n  \"b\" => 2\n  \"c\" => 3\n  \"e\" => 5\n\njulia> push!(a, \"d\" => 4)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 5 entries:\n  \"a\" => 1\n  \"b\" => 2\n  \"c\" => 3\n  \"d\" => 4\n  \"e\" => 5\n```\n\"\"\"\nfunction Base.push!(pq::PriorityQueue{K,V}, pair::Pair{K,V}) where {K,V}\n    key = pair.first\n    if haskey(pq, key)\n        throw(ArgumentError(\"PriorityQueue keys must be unique\"))\n    end\n    push!(pq.xs, pair)\n    pq.index[key] = length(pq)\n    percolate_up!(pq, length(pq))\n\n    return pq\nend\n\nBase.push!(pq::PriorityQueue{K,V}, kv::Pair) where {K,V} = push!(pq, Pair{K,V}(kv.first, kv.second))\n\n\"\"\"\n    popfirst!(pq::PriorityQueue)\n\nRemove and return the lowest priority key and value from a priority queue `pq` as a pair.\n\n# Examples\n\n```jldoctest\njulia> a = PriorityQueue(Base.Order.Forward, \"a\" => 2, \"b\" => 3, \"c\" => 1)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 3 entries:\n  \"c\" => 1\n  \"a\" => 2\n  \"b\" => 3\n\njulia> popfirst!(a)\n\"c\" => 1\n\njulia> a\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 2 entries:\n  \"a\" => 2\n  \"b\" => 3\n```\n\"\"\"\nfunction Base.popfirst!(pq::PriorityQueue)\n    x = pq.xs[1]\n    y = pop!(pq.xs)\n    if !isempty(pq)\n        @inbounds pq.xs[1] = y\n        pq.index[y.first] = 1\n        @inbounds percolate_down!(pq, 1)\n    end\n    delete!(pq.index, x.first)\n    return x\nend\n\nfunction Base.popat!(pq::PriorityQueue, key)\n    idx = pq.index[key]\n    force_up!(pq, idx)\n    popfirst!(pq)\nend\n\n\"\"\"\n    delete!(pq::PriorityQueue, key)\n\nDelete the mapping for the given `key` in a priority queue `pq` and return the priority queue.\n\n# Examples\n\n```jldoctest\njulia> q = PriorityQueue(Base.Order.Forward, \"a\" => 2, \"b\" => 3, \"c\" => 1)\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 3 entries:\n  \"c\" => 1\n  \"a\" => 2\n  \"b\" => 3\njulia> delete!(q, \"b\")\nPriorityQueue{String, Int64, Base.Order.ForwardOrdering} with 2 entries:\n  \"c\" => 1\n  \"a\" => 2\n```\n\"\"\"\nfunction Base.delete!(pq::PriorityQueue, key)\n    popat!(pq, key)\n    return pq\nend\n\n\"\"\"\n    empty!(pq::PriorityQueue)\n\nReset priority queue `pq`.\n\"\"\"\nfunction Base.empty!(pq::PriorityQueue)\n    empty!(pq.xs)\n    empty!(pq.index)\n    return pq\nend\n\nBase.empty(pq::PriorityQueue) = PriorityQueue(empty(pq.xs), pq.o, empty(pq.index))\n\nBase.merge!(d::SortedDict, other::PriorityQueue) = invoke(merge!, Tuple{AbstractDict, PriorityQueue}, d, other)\n\nfunction Base.merge!(d::AbstractDict, other::PriorityQueue)\n    next = iterate(other, false)\n    while next !== nothing\n        (k, v), state = next\n        d[k] = v\n        next = iterate(other, state)\n    end\n    return d\nend\n\nfunction Base.merge!(combine::Function, d::AbstractDict, other::PriorityQueue)\n    next = iterate(other, false)\n    while next !== nothing\n        (k, v), state = next\n        d[k] = haskey(d, k) ? combine(d[k], v) : v\n        next = iterate(other, state)\n    end\n    return d\nend\n\n# Opaque not to be exported.\nmutable struct _PQIteratorState{K, V, O <: Ordering}\n    pq::PriorityQueue{K, V, O}\n    _PQIteratorState{K, V, O}(pq::PriorityQueue{K, V, O}) where {K, V, O <: Ordering} = new(pq)\nend\n\n_PQIteratorState(pq::PriorityQueue{K, V, O}) where {K, V, O <: Ordering} = _PQIteratorState{K, V, O}(pq)\n\n# Unordered iteration through key value pairs in a PriorityQueue\n# O(n) iteration.\nfunction _iterate(pq::PriorityQueue, state)\n    (k, idx), i = state\n    return (pq.xs[idx], i)\nend\n_iterate(pq::PriorityQueue, ::Nothing) = nothing\n\nBase.iterate(pq::PriorityQueue, ::Nothing) = nothing\n\nfunction Base.iterate(pq::PriorityQueue, ordered::Bool=true)\n    if ordered\n        isempty(pq) && return nothing\n        state = _PQIteratorState(PriorityQueue(copy(pq.xs), pq.o, copy(pq.index)))\n        return popfirst!(state.pq), state\n    else\n        _iterate(pq, iterate(pq.index))\n    end\nend\n\nfunction Base.iterate(pq::PriorityQueue, state::_PQIteratorState)\n    isempty(state.pq) && return nothing\n    return popfirst!(state.pq), state\nend\n\nBase.iterate(pq::PriorityQueue, i) = _iterate(pq, iterate(pq.index, i))\n"}, "source_files_changed": ["src/heaps.jl", "src/heaps/arrays_as_heaps.jl", "src/priorityqueue.jl"], "test_files_changed": [], "lines_changed": 66, "is_valid": true, "validation_errors": []}
{"repo": "DataStructures.jl", "commit_sha": "45952124083d0c25a0b16810c54bb591c0f70f76", "parent_sha": "b7c5a5166b250c25bba2ac7a7bc29a2d8220864f", "commit_message": "Fix deprecation of DisjointSets(xs...) to avoid warning on package load", "commit_date": "2025-08-25T15:22:38+12:00", "action": {"type": "UNKNOWN", "target_file": "src/deprecations.jl", "target_symbol": null, "signature": null, "confidence": 0.1}, "files_before": {"src/deprecations.jl": "# 0.18 deprecations. Remove before releasing 0.19\n@deprecate path(t::Trie, str::AbstractString) partial_path(t::Trie, str::AbstractString)\n@deprecate find_root find_root!\n@deprecate top first\n@deprecate reverse_iter Iterators.reverse\n# Deprecations from #700\nBase.@deprecate_binding DisjointSets DisjointSet\nBase.@deprecate_binding IntDisjointSets IntDisjointSet\n@deprecate DisjointSets(xs...) DisjointSet(xs)\n# Enqueue and dequeue deprecations\n@deprecate enqueue!(q::Queue, x) Base.push!(q, x)\n@deprecate enqueue!(q::PriorityQueue, x) Base.push!(q, x)\n@deprecate enqueue!(q::PriorityQueue, k, v) Base.push!(q, k=>v)\n@deprecate dequeue!(q::Queue) Base.popfirst!(q)\n@deprecate dequeue!(q::PriorityQueue) Base.popfirst!(q).first # maybe better: `val, _ = popfirst!(pq)`\n@deprecate dequeue!(q::PriorityQueue, x) popat!(q, x).first\n@deprecate dequeue_pair!(q::PriorityQueue) Base.popfirst!(q)\n@deprecate dequeue_pair!(q::PriorityQueue, key) popat!(q, key)\n\n@deprecate startof(m::SortedContainer) firstindex(m::SortedContainer)\n@deprecate endof(m::SortedContainer) lastindex(m::SortedContainer)\n@deprecate insert!(m::SortedSet, k) push_return_semitoken!(m::SortedSet, k)\n@deprecate insert!(m::SortedDict, k, d) push_return_semitoken!(m::SortedDict, k=>d)\n@deprecate insert!(m::SortedMultiDict, k, d) (push_return_semitoken!(m::SortedMultiDict, k=>d))[2]\n\nfunction Base.peek(q::PriorityQueue)\n    Expr(:meta, :noinline)\n    Base.depwarn(\"`peek(q::PriorityQueue)` is deprecated, use `first(q)` instead.\", :peek)\n    first(q)\nend\n"}, "files_after": {"src/deprecations.jl": "# 0.18 deprecations. Remove before releasing 0.19\n@deprecate path(t::Trie, str::AbstractString) partial_path(t::Trie, str::AbstractString)\n@deprecate find_root find_root!\n@deprecate top first\n@deprecate reverse_iter Iterators.reverse\n# Deprecations from #700\nBase.@deprecate_binding DisjointSets DisjointSet\nBase.@deprecate_binding IntDisjointSets IntDisjointSet\n# We won't want to make this `@deprecate DisjointSets(xs...) DisjointSet(xs)`\n# because then loading this package will trigger a deprecation warning when we\n# evaluate the deprecated DisjointSets binding. This breaks any package that\n# tries to load DataStructures with --depwarn=error\n@deprecate DisjointSet(xs...) DisjointSet(xs)\n# Enqueue and dequeue deprecations\n@deprecate enqueue!(q::Queue, x) Base.push!(q, x)\n@deprecate enqueue!(q::PriorityQueue, x) Base.push!(q, x)\n@deprecate enqueue!(q::PriorityQueue, k, v) Base.push!(q, k=>v)\n@deprecate dequeue!(q::Queue) Base.popfirst!(q)\n@deprecate dequeue!(q::PriorityQueue) Base.popfirst!(q).first # maybe better: `val, _ = popfirst!(pq)`\n@deprecate dequeue!(q::PriorityQueue, x) popat!(q, x).first\n@deprecate dequeue_pair!(q::PriorityQueue) Base.popfirst!(q)\n@deprecate dequeue_pair!(q::PriorityQueue, key) popat!(q, key)\n\n@deprecate startof(m::SortedContainer) firstindex(m::SortedContainer)\n@deprecate endof(m::SortedContainer) lastindex(m::SortedContainer)\n@deprecate insert!(m::SortedSet, k) push_return_semitoken!(m::SortedSet, k)\n@deprecate insert!(m::SortedDict, k, d) push_return_semitoken!(m::SortedDict, k=>d)\n@deprecate insert!(m::SortedMultiDict, k, d) (push_return_semitoken!(m::SortedMultiDict, k=>d))[2]\n\nfunction Base.peek(q::PriorityQueue)\n    Expr(:meta, :noinline)\n    Base.depwarn(\"`peek(q::PriorityQueue)` is deprecated, use `first(q)` instead.\", :peek)\n    first(q)\nend\n"}, "source_files_changed": ["src/deprecations.jl"], "test_files_changed": [], "lines_changed": 6, "is_valid": false, "validation_errors": ["Low action confidence: 0.1", "Could not infer action type"]}
{"repo": "DataStructures.jl", "commit_sha": "48e10604440d953cbfa361d9bad3b8e7caeb66f8", "parent_sha": "988cbface1b46cb859132cfe385958f8d9928dcf", "commit_message": "fix pop!", "commit_date": "2025-08-20T15:05:21+02:00", "action": {"type": "UNKNOWN", "target_file": "src/ordered_robin_dict.jl", "target_symbol": null, "signature": null, "confidence": 0.1}, "files_before": {"src/ordered_robin_dict.jl": "const ALLOWABLE_USELESS_GROWTH = 0.25\n\n\"\"\"\n    OrderedRobinDict([itr])\n\n`OrderedRobinDict{K,V}()` constructs a ordered dictionary with keys of type `K` and values of type `V`.\nIt takes advantage of `RobinDict` in maintaining the order of the keys.\nGiven a single iterable argument, constructs a [`OrderedRobinDict`](@ref) whose key-value pairs\nare taken from 2-tuples `(key,value)` generated by the argument.\n\n\n# Examples\n```jldoctest\njulia> OrderedRobinDict([(\"A\", 1), (\"B\", 2)])\nOrderedRobinDict{String, Int64} with 2 entries:\n  \"A\" => 1\n  \"B\" => 2\n```\n\nAlternatively, a sequence of pair arguments may be passed.\n\n```jldoctest\njulia> OrderedRobinDict(\"A\"=>1, \"B\"=>2)\nOrderedRobinDict{String, Int64} with 2 entries:\n  \"A\" => 1\n  \"B\" => 2\n```\n\"\"\"\nmutable struct OrderedRobinDict{K,V} <: AbstractDict{K,V}\n    dict::RobinDict{K, Int32}\n    keys::Vector{K}\n    vals::Vector{V}\n    count::Int32\n\n    function OrderedRobinDict{K, V}() where {K, V}\n        new{K, V}(RobinDict{K, Int32}(), Vector{K}(), Vector{V}(), 0)\n    end\n\n    function OrderedRobinDict{K, V}(d::OrderedRobinDict{K, V}) where {K, V}\n        new{K, V}(copy(d.dict), copy(d.keys), copy(d.vals), d.count)\n    end\n\n    function OrderedRobinDict{K,V}(kv) where {K, V}\n        h = OrderedRobinDict{K,V}()\n        for (k,v) in kv\n            h[k] = v\n        end\n        return h\n    end\n    OrderedRobinDict{K,V}(p::Pair) where {K,V} = setindex!(OrderedRobinDict{K,V}(), p.second, p.first)\n    function OrderedRobinDict{K,V}(ps::Pair...) where V where K\n        h = OrderedRobinDict{K,V}()\n        sizehint!(h, length(ps))\n        for p in ps\n            h[p.first] = p.second\n        end\n        return h\n    end\nend\n\nOrderedRobinDict() = OrderedRobinDict{Any,Any}()\nOrderedRobinDict(kv::Tuple{}) = OrderedRobinDict()\nBase.copy(d::OrderedRobinDict) = OrderedRobinDict(d)\nBase.empty(d::OrderedRobinDict, ::Type{K}, ::Type{V}) where {K, V} = OrderedRobinDict{K, V}()\n\nOrderedRobinDict(ps::Pair{K,V}...) where {K,V} = OrderedRobinDict{K,V}(ps)\nOrderedRobinDict(ps::Pair...)                  = OrderedRobinDict(ps)\n\nOrderedRobinDict(d::AbstractDict{K, V}) where {K, V} = OrderedRobinDict{K, V}(d)\n\nfunction OrderedRobinDict(kv)\n    try\n        return dict_with_eltype((K, V) -> OrderedRobinDict{K, V}, kv, eltype(kv))\n    catch e\n        if !isiterable(typeof(kv)) || !all(x -> isa(x, Union{Tuple,Pair}), kv)\n            !all(x->isa(x,Union{Tuple,Pair}),kv)\n            throw(ArgumentError(\"OrderedRobinDict(kv): kv needs to be an iterator of tuples or pairs\"))\n        else\n            rethrow(e)\n        end\n    end\nend\n\nBase.empty(d::OrderedRobinDict{K,V}) where {K,V} = OrderedRobinDict{K,V}()\n\nBase.length(d::Union{RobinDict, OrderedRobinDict}) = d.count\nBase.isempty(d::Union{RobinDict, OrderedRobinDict}) = (length(d) == 0)\n\n\"\"\"\n    empty!(collection) -> collection\n\nRemove all elements from a `collection`.\n\n# Examples\n```jldoctest\njulia> A = OrderedRobinDict(\"a\" => 1, \"b\" => 2)\nOrderedRobinDict{String, Int64} with 2 entries:\n  \"a\" => 1\n  \"b\" => 2\n\njulia> empty!(A);\n\n\njulia> A\nOrderedRobinDict{String, Int64}()\n```\n\"\"\"\nfunction Base.empty!(h::OrderedRobinDict{K,V}) where {K, V}\n    empty!(h.dict)\n    empty!(h.keys)\n    empty!(h.vals)\n    h.count = 0\n    return h\nend\n\nfunction _setindex!(h::OrderedRobinDict, v, key)\n    hk, hv = h.keys, h.vals\n    push!(hk, key)\n    push!(hv, v)\n    nk = length(hk)\n    @inbounds h.dict[key] = Int32(nk)\n    h.count += 1\nend\n\nfunction Base.setindex!(h::OrderedRobinDict{K, V}, v0, key0) where {K,V}\n    key = convert(K, key0)\n    v = convert(V, v0)\n    index = get(h.dict, key, -2)\n\n    if index < 0\n        _setindex!(h, v0, key0)\n    else\n        @assert haskey(h, key0)\n        @inbounds orig_v = h.vals[index]\n        !isequal(orig_v, v0) && (@inbounds h.vals[index] = v0)\n    end\n\n    check_for_rehash(h) && rehash!(h)\n\n    return h\nend\n\n# rehash when there are ALLOWABLE_USELESS_GROWTH %\n# tombstones, or non-mirrored entries in the dictionary\nfunction check_for_rehash(h::OrderedRobinDict)\n    keysl = length(h.keys)\n    dictl = length(h)\n    return (keysl > (1 + ALLOWABLE_USELESS_GROWTH)*dictl)\nend\n\nfunction rehash!(h::OrderedRobinDict{K, V}) where {K, V}\n    keys = h.keys\n    vals = h.vals\n    hk = Vector{K}()\n    hv = Vector{V}()\n\n    for (idx, (k, v)) in enumerate(zip(keys, vals))\n        if get(h.dict, k, -1) == idx\n            push!(hk, k)\n            push!(hv, v)\n        end\n    end\n\n    h.keys = hk\n    h.vals = hv\n\n    for (idx, k) in enumerate(h.keys)\n        h.dict[k] = idx\n    end\n    return h\nend\n\nfunction Base.sizehint!(d::OrderedRobinDict, newsz::Integer)\n    oldsz = length(d)\n    # grow at least 25%\n    if newsz < (oldsz*5)>>2\n        return d\n    end\n    sizehint!(d.keys, newsz)\n    sizehint!(d.vals, newsz)\n    sizehint!(d.dict, newsz)\n    return d\nend\n\n\"\"\"\n    get!(collection, key, default)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store\n`key => default`, and return `default`.\n\n# Examples\n```jldoctest\njulia> d = OrderedRobinDict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\n\njulia> get!(d, \"a\", 5)\n1\n\njulia> get!(d, \"d\", 4)\n4\n\njulia> d\nOrderedRobinDict{String, Int64} with 4 entries:\n  \"a\" => 1\n  \"b\" => 2\n  \"c\" => 3\n  \"d\" => 4\n```\n\"\"\"\nfunction Base.get!(h::OrderedRobinDict{K,V}, key0, default) where {K,V}\n    index = get(h.dict, key0, -2)\n    index > 0 && return h.vals[index]\n    v = convert(V, default)\n    setindex!(h, v, key0)\n    return v\nend\n\n\"\"\"\n    get!(f::Function, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store\n`key => f()`, and return `f()`.\n\nThis is intended to be called using `do` block syntax:\n```julia\nget!(dict, key) do\n    # default value calculated here\n    time()\nend\n```\n\"\"\"\nfunction Base.get!(default::Base.Callable, h::OrderedRobinDict{K,V}, key0) where {K,V}\n    index = get(h.dict, key0, -2)\n    index > 0 && return @inbounds h.vals[index]\n\n    v = convert(V, default())\n    setindex!(h, v, key0)\n    return v\nend\n\nfunction Base.getindex(h::OrderedRobinDict{K,V}, key) where {K,V}\n    index = get(h.dict, key, -1)\n    return (index < 0) ? throw(KeyError(key)) : @inbounds h.vals[index]::V\nend\n\n\"\"\"\n    get(collection, key, default)\n\nReturn the value stored for the given key, or the given default value if no mapping for the\nkey is present.\n\n# Examples\n```jldoctest\njulia> d = OrderedRobinDict(\"a\"=>1, \"b\"=>2);\n\n\njulia> get(d, \"a\", 3)\n1\n\njulia> get(d, \"c\", 3)\n3\n```\n\"\"\"\nfunction Base.get(h::OrderedRobinDict{K,V}, key, default) where {K,V}\n    index = get(h.dict, key, -1)\n    return (index < 0) ? default : @inbounds h.vals[index]::V\nend\n\n\"\"\"\n    get(f::Function, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, return\n`f()`.  Use [`get!`](@ref) to also store the default value in the dictionary.\n\nThis is intended to be called using `do` block syntax\n\n```julia\nget(dict, key) do\n    # default value calculated here\n    time()\nend\n```\n\"\"\"\nfunction Base.get(default::Base.Callable, h::OrderedRobinDict{K,V}, key) where {K,V}\n    index = get(h.dict, key, -1)\n    return (index < 0) ? default() : @inbounds h.vals[index]::V\nend\n\n\"\"\"\n    haskey(collection, key) -> Bool\n\nDetermine whether a collection has a mapping for a given `key`.\n\n# Examples\n```jldoctest\njulia> D = OrderedRobinDict('a'=>2, 'b'=>3)\nOrderedRobinDict{Char, Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> haskey(D, 'a')\ntrue\n\njulia> haskey(D, 'c')\nfalse\n```\n\"\"\"\nBase.haskey(h::OrderedRobinDict, key) = (get(h.dict, key, -1) > 0)\nBase.in(key, v::Base.KeySet{K,T}) where {K,T<:OrderedRobinDict{K}} = (get(v.dict.dict, key, -1) >= 0)\n\n\"\"\"\n    getkey(collection, key, default)\n\nReturn the key matching argument `key` if one exists in `collection`, otherwise return `default`.\n\n# Examples\n```jldoctest\njulia> D = OrderedRobinDict('a'=>2, 'b'=>3)\nOrderedRobinDict{Char, Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> getkey(D, 'a', 1)\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> getkey(D, 'd', 'a')\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n```\n\"\"\"\nfunction Base.getkey(h::OrderedRobinDict{K,V}, key, default) where {K,V}\n    index = get(h.dict, key, -1)\n    return (index < 0) ? default : h.keys[index]::K\nend\n\nBase.@propagate_inbounds isslotfilled(h::OrderedRobinDict, index) = (h.dict[h.keys[index]] == index)\n\nfunction _pop!(h::OrderedRobinDict, index)\n    @inbounds val = h.vals[index]\n    _delete!(h, index)\n    return val\nend\n\nfunction Base.pop!(h::OrderedRobinDict)\n    check_for_rehash(h) && rehash!(h)\n    index = length(h.keys)\n    while (index > 0)\n        isslotfilled(h, index) && break\n        index -= 1\n    end\n    index == 0 && rehash!(h)\n    @inbounds key = h.keys[index]\n    return key => _pop!(h, index)\nend\n\nfunction Base.pop!(h::OrderedRobinDict, key)\n    index = get(h.dict, key, -1)\n    (index > 0) ? _pop!(h, index) : throw(KeyError(key))\nend\n\n\"\"\"\n    pop!(collection, key[, default])\n\nDelete and return the mapping for `key` if it exists in `collection`, otherwise return\n`default`, or throw an error if `default` is not specified.\n\n# Examples\n```jldoctest\njulia> d = OrderedRobinDict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\n\njulia> pop!(d, \"a\")\n1\n\njulia> pop!(d, \"d\")\nERROR: KeyError: key \"d\" not found\nStacktrace:\n[...]\n\njulia> pop!(d, \"e\", 4)\n4\n```\n\"\"\"\nfunction Base.pop!(h::OrderedRobinDict, key, default)\n    index = get(h.dict, key, -1)\n    (index > 0) ? _pop(h, index) : default\nend\n\n\"\"\"\n    delete!(collection, key)\n\nDelete the mapping for the given key in a collection, and return the collection.\n\n# Examples\n```jldoctest\njulia> d = OrderedRobinDict(\"a\"=>1, \"b\"=>2)\nOrderedRobinDict{String, Int64} with 2 entries:\n  \"a\" => 1\n  \"b\" => 2\n\njulia> delete!(d, \"b\")\nOrderedRobinDict{String, Int64} with 1 entry:\n  \"a\" => 1\n```\n\"\"\"\nfunction Base.delete!(h::OrderedRobinDict, key)\n    pop!(h, key)\n    return h\nend\n\nfunction _delete!(h::OrderedRobinDict, index)\n    @inbounds h.dict[h.keys[index]] = -1\n    h.count -= 1\n    check_for_rehash(h) ? rehash!(h) : h\nend\n\nfunction get_first_filled_index(h::OrderedRobinDict)\n    index = 1\n    while (true)\n        isslotfilled(h, index) && return index\n        index += 1\n    end\nend\n\nfunction get_next_filled_index(h::OrderedRobinDict, index)\n    # get the next filled slot, including index and beyond\n    while (index <= length(h.keys))\n        isslotfilled(h, index) && return index\n        index += 1\n    end\n    return -1\nend\n\nBase.@propagate_inbounds function Base.iterate(h::OrderedRobinDict)\n    isempty(h) && return nothing\n    check_for_rehash(h) && rehash!(h)\n    index = get_first_filled_index(h)\n    return (Pair(h.keys[index], h.vals[index]), index+1)\nend\n\nBase.@propagate_inbounds function Base.iterate(h::OrderedRobinDict, i)\n    length(h.keys) < i && return nothing\n    index = get_next_filled_index(h, i)\n    (index < 0) && return nothing\n    return (Pair(h.keys[index], h.vals[index]), index+1)\nend\n\nBase.filter!(f, d::Union{RobinDict, OrderedRobinDict}) = Base.filter_in_one_pass!(f, d)\n\nfunction Base.merge(d::OrderedRobinDict, others::AbstractDict...)\n    K,V = _merge_kvtypes(d, others...)\n    merge!(OrderedRobinDict{K,V}(), d, others...)\nend\n\nfunction Base.merge(combine::Function, d::OrderedRobinDict, others::AbstractDict...)\n    K,V = _merge_kvtypes(d, others...)\n    merge!(combine, OrderedRobinDict{K,V}(), d, others...)\nend\n\nOrderedCollections.isordered(::Type{T}) where {T <: OrderedRobinDict} = true\n"}, "files_after": {"src/ordered_robin_dict.jl": "const ALLOWABLE_USELESS_GROWTH = 0.25\n\n\"\"\"\n    OrderedRobinDict([itr])\n\n`OrderedRobinDict{K,V}()` constructs a ordered dictionary with keys of type `K` and values of type `V`.\nIt takes advantage of `RobinDict` in maintaining the order of the keys.\nGiven a single iterable argument, constructs a [`OrderedRobinDict`](@ref) whose key-value pairs\nare taken from 2-tuples `(key,value)` generated by the argument.\n\n\n# Examples\n```jldoctest\njulia> OrderedRobinDict([(\"A\", 1), (\"B\", 2)])\nOrderedRobinDict{String, Int64} with 2 entries:\n  \"A\" => 1\n  \"B\" => 2\n```\n\nAlternatively, a sequence of pair arguments may be passed.\n\n```jldoctest\njulia> OrderedRobinDict(\"A\"=>1, \"B\"=>2)\nOrderedRobinDict{String, Int64} with 2 entries:\n  \"A\" => 1\n  \"B\" => 2\n```\n\"\"\"\nmutable struct OrderedRobinDict{K,V} <: AbstractDict{K,V}\n    dict::RobinDict{K, Int32}\n    keys::Vector{K}\n    vals::Vector{V}\n    count::Int32\n\n    function OrderedRobinDict{K, V}() where {K, V}\n        new{K, V}(RobinDict{K, Int32}(), Vector{K}(), Vector{V}(), 0)\n    end\n\n    function OrderedRobinDict{K, V}(d::OrderedRobinDict{K, V}) where {K, V}\n        new{K, V}(copy(d.dict), copy(d.keys), copy(d.vals), d.count)\n    end\n\n    function OrderedRobinDict{K,V}(kv) where {K, V}\n        h = OrderedRobinDict{K,V}()\n        for (k,v) in kv\n            h[k] = v\n        end\n        return h\n    end\n    OrderedRobinDict{K,V}(p::Pair) where {K,V} = setindex!(OrderedRobinDict{K,V}(), p.second, p.first)\n    function OrderedRobinDict{K,V}(ps::Pair...) where V where K\n        h = OrderedRobinDict{K,V}()\n        sizehint!(h, length(ps))\n        for p in ps\n            h[p.first] = p.second\n        end\n        return h\n    end\nend\n\nOrderedRobinDict() = OrderedRobinDict{Any,Any}()\nOrderedRobinDict(kv::Tuple{}) = OrderedRobinDict()\nBase.copy(d::OrderedRobinDict) = OrderedRobinDict(d)\nBase.empty(d::OrderedRobinDict, ::Type{K}, ::Type{V}) where {K, V} = OrderedRobinDict{K, V}()\n\nOrderedRobinDict(ps::Pair{K,V}...) where {K,V} = OrderedRobinDict{K,V}(ps)\nOrderedRobinDict(ps::Pair...)                  = OrderedRobinDict(ps)\n\nOrderedRobinDict(d::AbstractDict{K, V}) where {K, V} = OrderedRobinDict{K, V}(d)\n\nfunction OrderedRobinDict(kv)\n    try\n        return dict_with_eltype((K, V) -> OrderedRobinDict{K, V}, kv, eltype(kv))\n    catch e\n        if !isiterable(typeof(kv)) || !all(x -> isa(x, Union{Tuple,Pair}), kv)\n            !all(x->isa(x,Union{Tuple,Pair}),kv)\n            throw(ArgumentError(\"OrderedRobinDict(kv): kv needs to be an iterator of tuples or pairs\"))\n        else\n            rethrow(e)\n        end\n    end\nend\n\nBase.empty(d::OrderedRobinDict{K,V}) where {K,V} = OrderedRobinDict{K,V}()\n\nBase.length(d::Union{RobinDict, OrderedRobinDict}) = d.count\nBase.isempty(d::Union{RobinDict, OrderedRobinDict}) = (length(d) == 0)\n\n\"\"\"\n    empty!(collection) -> collection\n\nRemove all elements from a `collection`.\n\n# Examples\n```jldoctest\njulia> A = OrderedRobinDict(\"a\" => 1, \"b\" => 2)\nOrderedRobinDict{String, Int64} with 2 entries:\n  \"a\" => 1\n  \"b\" => 2\n\njulia> empty!(A);\n\n\njulia> A\nOrderedRobinDict{String, Int64}()\n```\n\"\"\"\nfunction Base.empty!(h::OrderedRobinDict{K,V}) where {K, V}\n    empty!(h.dict)\n    empty!(h.keys)\n    empty!(h.vals)\n    h.count = 0\n    return h\nend\n\nfunction _setindex!(h::OrderedRobinDict, v, key)\n    hk, hv = h.keys, h.vals\n    push!(hk, key)\n    push!(hv, v)\n    nk = length(hk)\n    @inbounds h.dict[key] = Int32(nk)\n    h.count += 1\nend\n\nfunction Base.setindex!(h::OrderedRobinDict{K, V}, v0, key0) where {K,V}\n    key = convert(K, key0)\n    v = convert(V, v0)\n    index = get(h.dict, key, -2)\n\n    if index < 0\n        _setindex!(h, v0, key0)\n    else\n        @assert haskey(h, key0)\n        @inbounds orig_v = h.vals[index]\n        !isequal(orig_v, v0) && (@inbounds h.vals[index] = v0)\n    end\n\n    check_for_rehash(h) && rehash!(h)\n\n    return h\nend\n\n# rehash when there are ALLOWABLE_USELESS_GROWTH %\n# tombstones, or non-mirrored entries in the dictionary\nfunction check_for_rehash(h::OrderedRobinDict)\n    keysl = length(h.keys)\n    dictl = length(h)\n    return (keysl > (1 + ALLOWABLE_USELESS_GROWTH)*dictl)\nend\n\nfunction rehash!(h::OrderedRobinDict{K, V}) where {K, V}\n    keys = h.keys\n    vals = h.vals\n    hk = Vector{K}()\n    hv = Vector{V}()\n\n    for (idx, (k, v)) in enumerate(zip(keys, vals))\n        if get(h.dict, k, -1) == idx\n            push!(hk, k)\n            push!(hv, v)\n        end\n    end\n\n    h.keys = hk\n    h.vals = hv\n\n    for (idx, k) in enumerate(h.keys)\n        h.dict[k] = idx\n    end\n    return h\nend\n\nfunction Base.sizehint!(d::OrderedRobinDict, newsz::Integer)\n    oldsz = length(d)\n    # grow at least 25%\n    if newsz < (oldsz*5)>>2\n        return d\n    end\n    sizehint!(d.keys, newsz)\n    sizehint!(d.vals, newsz)\n    sizehint!(d.dict, newsz)\n    return d\nend\n\n\"\"\"\n    get!(collection, key, default)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store\n`key => default`, and return `default`.\n\n# Examples\n```jldoctest\njulia> d = OrderedRobinDict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\n\njulia> get!(d, \"a\", 5)\n1\n\njulia> get!(d, \"d\", 4)\n4\n\njulia> d\nOrderedRobinDict{String, Int64} with 4 entries:\n  \"a\" => 1\n  \"b\" => 2\n  \"c\" => 3\n  \"d\" => 4\n```\n\"\"\"\nfunction Base.get!(h::OrderedRobinDict{K,V}, key0, default) where {K,V}\n    index = get(h.dict, key0, -2)\n    index > 0 && return h.vals[index]\n    v = convert(V, default)\n    setindex!(h, v, key0)\n    return v\nend\n\n\"\"\"\n    get!(f::Function, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store\n`key => f()`, and return `f()`.\n\nThis is intended to be called using `do` block syntax:\n```julia\nget!(dict, key) do\n    # default value calculated here\n    time()\nend\n```\n\"\"\"\nfunction Base.get!(default::Base.Callable, h::OrderedRobinDict{K,V}, key0) where {K,V}\n    index = get(h.dict, key0, -2)\n    index > 0 && return @inbounds h.vals[index]\n\n    v = convert(V, default())\n    setindex!(h, v, key0)\n    return v\nend\n\nfunction Base.getindex(h::OrderedRobinDict{K,V}, key) where {K,V}\n    index = get(h.dict, key, -1)\n    return (index < 0) ? throw(KeyError(key)) : @inbounds h.vals[index]::V\nend\n\n\"\"\"\n    get(collection, key, default)\n\nReturn the value stored for the given key, or the given default value if no mapping for the\nkey is present.\n\n# Examples\n```jldoctest\njulia> d = OrderedRobinDict(\"a\"=>1, \"b\"=>2);\n\n\njulia> get(d, \"a\", 3)\n1\n\njulia> get(d, \"c\", 3)\n3\n```\n\"\"\"\nfunction Base.get(h::OrderedRobinDict{K,V}, key, default) where {K,V}\n    index = get(h.dict, key, -1)\n    return (index < 0) ? default : @inbounds h.vals[index]::V\nend\n\n\"\"\"\n    get(f::Function, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, return\n`f()`.  Use [`get!`](@ref) to also store the default value in the dictionary.\n\nThis is intended to be called using `do` block syntax\n\n```julia\nget(dict, key) do\n    # default value calculated here\n    time()\nend\n```\n\"\"\"\nfunction Base.get(default::Base.Callable, h::OrderedRobinDict{K,V}, key) where {K,V}\n    index = get(h.dict, key, -1)\n    return (index < 0) ? default() : @inbounds h.vals[index]::V\nend\n\n\"\"\"\n    haskey(collection, key) -> Bool\n\nDetermine whether a collection has a mapping for a given `key`.\n\n# Examples\n```jldoctest\njulia> D = OrderedRobinDict('a'=>2, 'b'=>3)\nOrderedRobinDict{Char, Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> haskey(D, 'a')\ntrue\n\njulia> haskey(D, 'c')\nfalse\n```\n\"\"\"\nBase.haskey(h::OrderedRobinDict, key) = (get(h.dict, key, -1) > 0)\nBase.in(key, v::Base.KeySet{K,T}) where {K,T<:OrderedRobinDict{K}} = (get(v.dict.dict, key, -1) >= 0)\n\n\"\"\"\n    getkey(collection, key, default)\n\nReturn the key matching argument `key` if one exists in `collection`, otherwise return `default`.\n\n# Examples\n```jldoctest\njulia> D = OrderedRobinDict('a'=>2, 'b'=>3)\nOrderedRobinDict{Char, Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> getkey(D, 'a', 1)\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> getkey(D, 'd', 'a')\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n```\n\"\"\"\nfunction Base.getkey(h::OrderedRobinDict{K,V}, key, default) where {K,V}\n    index = get(h.dict, key, -1)\n    return (index < 0) ? default : h.keys[index]::K\nend\n\nBase.@propagate_inbounds isslotfilled(h::OrderedRobinDict, index) = (h.dict[h.keys[index]] == index)\n\nfunction _pop!(h::OrderedRobinDict, index)\n    @inbounds val = h.vals[index]\n    _delete!(h, index)\n    return val\nend\n\nfunction Base.pop!(h::OrderedRobinDict)\n    check_for_rehash(h) && rehash!(h)\n    index = length(h.keys)\n    while (index > 0)\n        isslotfilled(h, index) && break\n        index -= 1\n    end\n    index == 0 && rehash!(h)\n    @inbounds key = h.keys[index]\n    return key => _pop!(h, index)\nend\n\nfunction Base.pop!(h::OrderedRobinDict, key)\n    index = get(h.dict, key, -1)\n    (index > 0) ? _pop!(h, index) : throw(KeyError(key))\nend\n\n\"\"\"\n    pop!(collection, key[, default])\n\nDelete and return the mapping for `key` if it exists in `collection`, otherwise return\n`default`, or throw an error if `default` is not specified.\n\n# Examples\n```jldoctest\njulia> d = OrderedRobinDict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\n\njulia> pop!(d, \"a\")\n1\n\njulia> pop!(d, \"d\")\nERROR: KeyError: key \"d\" not found\nStacktrace:\n[...]\n\njulia> pop!(d, \"e\", 4)\n4\n```\n\"\"\"\nfunction Base.pop!(h::OrderedRobinDict, key, default)\n    index = get(h.dict, key, -1)\n    (index > 0) ? _pop!(h, index) : default\nend\n\n\"\"\"\n    delete!(collection, key)\n\nDelete the mapping for the given key in a collection, and return the collection.\n\n# Examples\n```jldoctest\njulia> d = OrderedRobinDict(\"a\"=>1, \"b\"=>2)\nOrderedRobinDict{String, Int64} with 2 entries:\n  \"a\" => 1\n  \"b\" => 2\n\njulia> delete!(d, \"b\")\nOrderedRobinDict{String, Int64} with 1 entry:\n  \"a\" => 1\n```\n\"\"\"\nfunction Base.delete!(h::OrderedRobinDict, key)\n    pop!(h, key)\n    return h\nend\n\nfunction _delete!(h::OrderedRobinDict, index)\n    @inbounds h.dict[h.keys[index]] = -1\n    h.count -= 1\n    check_for_rehash(h) ? rehash!(h) : h\nend\n\nfunction get_first_filled_index(h::OrderedRobinDict)\n    index = 1\n    while (true)\n        isslotfilled(h, index) && return index\n        index += 1\n    end\nend\n\nfunction get_next_filled_index(h::OrderedRobinDict, index)\n    # get the next filled slot, including index and beyond\n    while (index <= length(h.keys))\n        isslotfilled(h, index) && return index\n        index += 1\n    end\n    return -1\nend\n\nBase.@propagate_inbounds function Base.iterate(h::OrderedRobinDict)\n    isempty(h) && return nothing\n    check_for_rehash(h) && rehash!(h)\n    index = get_first_filled_index(h)\n    return (Pair(h.keys[index], h.vals[index]), index+1)\nend\n\nBase.@propagate_inbounds function Base.iterate(h::OrderedRobinDict, i)\n    length(h.keys) < i && return nothing\n    index = get_next_filled_index(h, i)\n    (index < 0) && return nothing\n    return (Pair(h.keys[index], h.vals[index]), index+1)\nend\n\nBase.filter!(f, d::Union{RobinDict, OrderedRobinDict}) = Base.filter_in_one_pass!(f, d)\n\nfunction Base.merge(d::OrderedRobinDict, others::AbstractDict...)\n    K,V = _merge_kvtypes(d, others...)\n    merge!(OrderedRobinDict{K,V}(), d, others...)\nend\n\nfunction Base.merge(combine::Function, d::OrderedRobinDict, others::AbstractDict...)\n    K,V = _merge_kvtypes(d, others...)\n    merge!(combine, OrderedRobinDict{K,V}(), d, others...)\nend\n\nOrderedCollections.isordered(::Type{T}) where {T <: OrderedRobinDict} = true\n"}, "source_files_changed": ["src/ordered_robin_dict.jl"], "test_files_changed": [], "lines_changed": 2, "is_valid": false, "validation_errors": ["Low action confidence: 0.1", "Could not infer action type"]}
{"repo": "DataStructures.jl", "commit_sha": "88d6cd71c7b421027663a426c49244ce73ff5b44", "parent_sha": "331b9da28c52506798a759ff34529359d755eaf2", "commit_message": "remove comment", "commit_date": "2025-08-19T09:29:34-05:00", "action": {"type": "UNKNOWN", "target_file": "src/default_dict.jl", "target_symbol": null, "signature": null, "confidence": 0.1}, "files_before": {"src/default_dict.jl": "# Dictionary which returns (and sets) a default value for a requested item not\n# already in to the dictionary\n\n# DefaultDictBase is the main class used to in Default*Dicts.\n#\n# Each related (immutable) Default*Dict class contains a single\n# DefaultDictBase object as a member, and delegates almost all\n# functions to this object.\n#\n# The main rationale for doing this instead of using type aliases is\n# that this way, we can have actual class names and constructors for\n# each of the DefaultDictBase \"subclasses\", in some sense getting\n# around the Julia limitation of not allowing concrete classes to be\n# subclassed.\n#\n\n\"\"\"\n    DefaultDictBase{K,V,F,D}(default[, dict][, pairs...]; passkey=false)\n\nInternal base type for DefaultDict and DefaultOrderedDict.\n\nThis type handles the core \"default on miss\" behavior, where accessing\na missing key returns (and stores) a default value.\n\n# Parameters\n\n- `K` Key type\n- `V` Value type  \n- `F` Type of the default value or callable\n- `D` Type of the underlying dictionary\n- `default` Default value or callable to use for missing keys\n- `passkey::Bool=false` If true and default is callable, pass the key to the default function\n\n# Note\n\nThis is an internal type. Users should use `DefaultDict` or `DefaultOrderedDict` instead.\n\"\"\"\nstruct DefaultDictBase{K,V,F,D} <: AbstractDict{K,V}\n    default::F\n    d::D\n    passkey::Bool\n\n    check_D(D,K,V) = (D <: AbstractDict{K,V}) ||\n        throw(ArgumentError(\"Default dict must be <: AbstractDict{$K,$V}\"))\n\n    DefaultDictBase{K,V,F,D}(x::F, kv::AbstractArray{Tuple{K,V}}; passkey=false) where {K,V,F,D} =\n        (check_D(D,K,V); new{K,V,F,D}(x, D(kv), passkey))\n    DefaultDictBase{K,V,F,D}(x::F, ps::Pair{K,V}...; passkey=false) where {K,V,F,D} =\n        (check_D(D,K,V); new{K,V,F,D}(x, D(ps...), passkey))\n\n    DefaultDictBase{K,V,F,D}(x::F, d::D; passkey=d.passkey) where {K,V,F,D<:DefaultDictBase} =\n        (check_D(D,K,V); DefaultDictBase(x, d.d; passkey=passkey))\n    DefaultDictBase{K,V,F,D}(x::F, d::D = D(); passkey=false) where {K,V,F,D} =\n        (check_D(D,K,V); new{K,V,F,D}(x, d, passkey))\nend\n\n# Constructors\n\nDefaultDictBase(; kwargs...) = throw(ArgumentError(\"no default specified\"))\nDefaultDictBase(k, v; kwargs...) = throw(ArgumentError(\"no default specified\"))\n\n# syntax entry points\nDefaultDictBase(default::F; kwargs...) where {F} = DefaultDictBase{Any,Any,F,Dict{Any,Any}}(default; kwargs...)\nDefaultDictBase(default::F, kv::AbstractArray{Tuple{K,V}}; kwargs...) where {K,V,F} = DefaultDictBase{K,V,F,Dict{K,V}}(default, kv; kwargs...)\nDefaultDictBase(default::F, ps::Pair{K,V}...; kwargs...) where {K,V,F} = DefaultDictBase{K,V,F,Dict{K,V}}(default, ps...; kwargs...)\nDefaultDictBase(default::F, d::D; kwargs...) where {F,D<:AbstractDict} = (K=keytype(d); V=valtype(d); DefaultDictBase{K,V,F,D}(default, d; kwargs...))\n\n# Constructor for DefaultDictBase{Int,Float64}(0.0)\nDefaultDictBase{K,V}(default::F; kwargs...) where {K,V,F} = DefaultDictBase{K,V,F,Dict{K,V}}(default; kwargs...)\n\n# Functions\n\n# most functions are simply delegated to the wrapped dictionary\n@delegate DefaultDictBase.d [ Base.get, Base.haskey, Base.getkey, Base.pop!,\n                              Base.iterate, Base.isempty, Base.length ]\n\n# Some functions are delegated, but then need to return the main dictionary\n# NOTE: push! is not included below, because the fallback version just\n#       calls setindex!\n@delegate_return_parent DefaultDictBase.d [ Base.delete!, Base.empty!, Base.setindex!, Base.sizehint! ]\n\n\"\"\"\n    empty(d::DefaultDictBase)\n\nCreate an empty DefaultDictBase with the same default and passkey settings.\n\"\"\"\nBase.empty(d::DefaultDictBase{K,V,F}) where {K,V,F} = DefaultDictBase{K,V,F}(d.default; passkey=d.passkey)\n\n\"\"\"\n    getindex(d::DefaultDictBase, key)\n\nReturn the value for `key` if it exists, otherwise return and store the default value.\n\nFor non-callable defaults, returns the constant value.\nFor callable defaults, calls the function and stores the result.\n\"\"\"\nBase.getindex(d::DefaultDictBase, key) = get!(d.d, key, d.default)\n\nfunction Base.getindex(d::DefaultDictBase{K,V,F}, key) where {K,V,F<:Base.Callable}\n    if d.passkey\n        return get!(d.d, key) do\n            d.default(key)\n        end\n    else\n        return get!(d.d, key) do\n            d.default()\n        end\n    end\nend\n\n\n################\n\n# Here begins the actual definition of the DefaultDict and\n# DefaultOrderedDict classes.  As noted above, these are simply\n# wrappers around a DefaultDictBase object, and delegate all functions\n# to that object\n\nfor _Dict in [:Dict, :OrderedDict]\n    DefaultDict = Symbol(\"Default\"*string(_Dict))\n    @eval begin\n        \"\"\"\n            $($DefaultDict)(default, pairs...; passkey=false)\n            $($DefaultDict)(default, d::AbstractDict; passkey=false)\n            $($DefaultDict){K, V}(default, pairs...; passkey=false)\n            $($DefaultDict){K, V}(default, dict::AbstractDict; passkey=false)\n\n        Construct an $($(_Dict == :Dict ? \"un\" : \"\"))ordered dictionary with \"default on miss\" behavior.\n        When accessing a missing key, the dictionary returns (and stores) either the constant\n        `default` value (if non-callable) or the result of calling the callable `default`.\n\n        If the `default` is a `Function` or `Type`, it is called on retrieval of a missing key\n        with either zero arguments (if `passkey==false`) or with the requested key (if `passkey==true`).\n\n        # Examples\n        ```julia\n        # Counting pattern with constant default\n        counter = $($DefaultDict)(0)\n        for ch in \"banana\"\n            counter[ch] += 1\n        end\n        # counter['b'] == 1, counter['a'] == 3, counter['n'] == 2\n\n        # Grouping items with fresh container per key\n        groups = $($DefaultDict)(() -> Int[])\n        for (k, v) in [(\"a\", 1), (\"a\", 2), (\"b\", 3)]\n            push!(groups[k], v)\n        end\n        # groups[\"a\"] == [1, 2], groups[\"b\"] == [3]\n\n        # Using type constructors as callable defaults\n        dd = $($DefaultDict)(Vector{String})\n        push!(dd[:colors], \"red\")\n        push!(dd[:colors], \"blue\")\n        # dd[:colors] == [\"red\", \"blue\"]\n\n        # passkey=false: default function called with no arguments\n        dd1 = $($DefaultDict)(() -> \"default\", passkey=false)\n        dd1[\"anything\"]  # returns \"default\"\n\n        # passkey=true: default function receives the missing key\n        dd2 = $($DefaultDict)(k -> \"Key '\\$k' not found\", passkey=true)\n        dd2[\"missing\"]  # returns \"Key 'missing' not found\"\n        dd2[\"other\"]    # returns \"Key 'other' not found\"\n\n        # Initialize with specified types\n        dd = $($DefaultDict){String,Int}(0)\n        dd[\"a\"] = 1\n        dd[\"b\"]  # returns 0\n\n        # Create from existing dictionary\n        base = Dict(\"a\" => 1, \"b\" => 2)\n        dd = $($DefaultDict)(0, base)\n        dd[\"c\"]  # returns 0\n        ```\n        \"\"\"\n        struct $DefaultDict{K,V,F} <: AbstractDict{K,V}\n            d::DefaultDictBase{K,V,F,$_Dict{K,V}}\n\n            $DefaultDict{K,V,F}(x, ps::Pair{K,V}...; kwargs...) where {K,V,F} =\n                new{K,V,F}(DefaultDictBase{K,V,F,$_Dict{K,V}}(x, ps...; kwargs...))\n            $DefaultDict{K,V,F}(x, kv::AbstractArray{Tuple{K,V}}; kwargs...) where {K,V,F} =\n                new{K,V,F}(DefaultDictBase{K,V,F,$_Dict{K,V}}(x, kv; kwargs...))\n            $DefaultDict{K,V,F}(x, d::$DefaultDict) where {K,V,F} = $DefaultDict(x, d.d)\n            $DefaultDict{K,V,F}(x, d::$_Dict; kwargs...) where {K,V,F} =\n                new{K,V,F}(DefaultDictBase{K,V,F,$_Dict{K,V}}(x, d; kwargs...))\n            $DefaultDict{K,V,F}(x; kwargs...) where {K,V,F} =\n                new{K,V,F}(DefaultDictBase{K,V,F,$_Dict{K,V}}(x; kwargs...))\n        end\n\n        ## Constructors\n\n        $DefaultDict() = throw(ArgumentError(\"$DefaultDict: no default specified\"))\n        $DefaultDict(k,v) = throw(ArgumentError(\"$DefaultDict: no default specified\"))\n\n        # syntax entry points\n        $DefaultDict(default::F; kwargs...) where {F} = $DefaultDict{Any,Any,F}(default; kwargs...)\n        $DefaultDict(default::F, kv::AbstractArray{Tuple{K,V}}; kwargs...) where {K,V,F} = $DefaultDict{K,V,F}(default, kv; kwargs...)\n        $DefaultDict(default::F, ps::Pair{K,V}...; kwargs...) where {K,V,F} = $DefaultDict{K,V,F}(default, ps...; kwargs...)\n\n        $DefaultDict(default::F, d::AbstractDict; kwargs...) where {F} = ((K,V)= (Base.keytype(d), Base.valtype(d)); $DefaultDict{K,V,F}(default, $_Dict(d); kwargs...))\n\n        # Constructor syntax: DefaultDictBase{Int,Float64}(default)\n        $DefaultDict{K,V}(; kwargs...) where {K,V} = throw(ArgumentError(\"$DefaultDict: no default specified\"))\n        $DefaultDict{K,V}(default::F, pairs...; kwargs...) where {K,V,F} = $DefaultDict{K,V,F}(default, $_Dict{K,V}(pairs...); kwargs...)\n        $DefaultDict{K,V}(default::F, d::AbstractDict; kwargs...) where {K,V,F} = $DefaultDict{K,V,F}(default, $_Dict{K,V}(d); kwargs...)\n\n        ## Functions\n\n        # Most functions are simply delegated to the wrapped DefaultDictBase object\n        @delegate $DefaultDict.d [ Base.getindex, Base.get, Base.get!, Base.haskey,\n                                   Base.getkey, Base.pop!, Base.iterate,\n                                   Base.isempty, Base.length ]\n\n        # Some functions are delegated, but then need to return the main dictionary\n        # NOTE: push! is not included below, because the fallback version just\n        #       calls setindex!\n        @delegate_return_parent $DefaultDict.d [ Base.delete!, Base.empty!, Base.setindex!, Base.sizehint! ]\n\n        \"\"\"\n            push!(d::$($DefaultDict), p::Pair)\n            push!(d::$($DefaultDict), p::Pair...)\n\n        Insert one or more key-value pairs into the dictionary `d`.\n        \n        # Examples\n        ```jldoctest\n        julia> d = $($DefaultDict)(0)\n        julia> push!(d, \"a\" => 1, \"b\" => 2)\n        julia> d[\"a\"]\n        1\n        ```\n        \"\"\"\n        # NOTE: The second and third definition of push! below are only\n        # necessary for disambiguating with the fourth, fifth, and sixth\n        # definitions of push! below.\n        # If these are removed, the second and third definitions can be\n        # removed as well.\n        Base.push!(d::$DefaultDict, p::Pair) = (setindex!(d.d, p.second, p.first); d)\n        Base.push!(d::$DefaultDict, p::Pair, q::Pair) = push!(push!(d, p), q)\n        Base.push!(d::$DefaultDict, p::Pair, q::Pair, r::Pair...) = push!(push!(push!(d, p), q), r...)\n\n        Base.push!(d::$DefaultDict, p) = (setindex!(d.d, p[2], p[1]); d)\n        Base.push!(d::$DefaultDict, p, q) = push!(push!(d, p), q)\n        Base.push!(d::$DefaultDict, p, q, r...) = push!(push!(push!(d, p), q), r...)\n\n        \"\"\"\n            empty(d::$($DefaultDict))\n\n        Return an empty $($DefaultDict) with the same default value and type parameters.\n        \"\"\"\n        Base.empty(d::$DefaultDict{K,V,F}) where {K,V,F} = $DefaultDict{K,V,F}(d.d.default)\n        \"\"\"\n            in(key, keys::Base.KeySet{K,$($DefaultDict){K}})\n\n        Check if `key` is present in the key set of a $($DefaultDict).\n        \"\"\"\n        Base.in(key, v::Base.KeySet{K,T}) where {K,T<:$DefaultDict{K}} = key in keys(v.dict.d.d)\n    end\nend\n\nOrderedCollections.isordered(::Type{T}) where {T<:DefaultOrderedDict} = true\n\n## This should be uncommented to provide a DefaultSortedDict\n\n# struct DefaultSortedDict{K,V,F} <: AbstractDict{K,V}\n#     d::DefaultDictBase{K,V,F,SortedDict{K,V}}\n\n#     DefaultSortedDict(x, kv::AbstractArray{(K,V)}) = new(DefaultDictBase{K,V,F,SortedDict{K,V}}(x, kv))\n#     DefaultSortedDict(x, d::DefaultSortedDict) = DefaultSortedDict(x, d.d)\n#     DefaultSortedDict(x, d::SortedDict) = new(DefaultDictBase{K,V,F,SortedDict{K,V}}(x, d))\n#     DefaultSortedDict(x) = new(DefaultDictBase{K,V,F,SortedDict{K,V}}(x))\n#     DefaultSortedDict(x, ks, vs) = new(DefaultDictBase{K,V,F,SortedDict{K,V}}(x,ks,vs))\n# end\n\n## Constructors\n\n# DefaultSortedDict() = throw(ArgumentError(\"DefaultSortedDict: no default specified\"))\n# DefaultSortedDict(k,v) = throw(ArgumentError(\"DefaultSortedDict: no default specified\"))\n\n# # TODO: these mimic similar Dict constructors, but may not be needed\n# DefaultSortedDict{K,V,F}(default::F, ks::AbstractArray{K}, vs::AbstractArray{V}) = DefaultSortedDict{K,V,F}(default,ks,vs)\n# DefaultSortedDict{F}(default::F,ks,vs) = DefaultSortedDict{Any,Any,F}(default, ks, vs)\n\n# # syntax entry points\n# DefaultSortedDict{F}(default::F) = DefaultSortedDict{Any,Any,F}(default)\n# DefaultSortedDict{K,V,F}(::Type{K}, ::Type{V}, default::F) = DefaultSortedDict{K,V,F}(default)\n# DefaultSortedDict{K,V,F}(default::F, kv::AbstractArray{(K,V)}) = DefaultSortedDict{K,V,F}(default, kv)\n\n# DefaultSortedDict{F}(default::F, d::AbstractDict) = ((K,V)=eltype(d); DefaultSortedDict{K,V,F}(default, SortedDict(d)))\n\n## Functions\n\n## Most functions are simply delegated to the wrapped DefaultDictBase object\n\n# @delegate DefaultSortedDict.d [ getindex, get, get!, haskey,\n#                                 getkey, pop!, start, next,\n#                                 done, isempty, length]\n# @delegate_return_parent DefaultSortedDict.d [ delete!, empty!, setindex!, sizehint! ]\n\n# similar{K,V,F}(d::DefaultSortedDict{K,V,F}) = DefaultSortedDict{K,V,F}(d.d.default)\n# in{T<:DefaultSortedDict}(key, v::Base.KeySet{T}) = key in keys(v.dict.d.d)\n"}, "files_after": {"src/default_dict.jl": "# Dictionary which returns (and sets) a default value for a requested item not\n# already in to the dictionary\n\n# DefaultDictBase is the main class used to in Default*Dicts.\n#\n# Each related (immutable) Default*Dict class contains a single\n# DefaultDictBase object as a member, and delegates almost all\n# functions to this object.\n#\n# The main rationale for doing this instead of using type aliases is\n# that this way, we can have actual class names and constructors for\n# each of the DefaultDictBase \"subclasses\", in some sense getting\n# around the Julia limitation of not allowing concrete classes to be\n# subclassed.\n#\n\n\"\"\"\n    DefaultDictBase{K,V,F,D}(default[, dict][, pairs...]; passkey=false)\n\nInternal base type for DefaultDict and DefaultOrderedDict.\n\nThis type handles the core \"default on miss\" behavior, where accessing\na missing key returns (and stores) a default value.\n\n# Parameters\n\n- `K` Key type\n- `V` Value type\n- `F` Type of the default value or callable\n- `D` Type of the underlying dictionary\n- `default` Default value or callable to use for missing keys\n- `passkey::Bool=false` If true and default is callable, pass the key to the default function\n\n\"\"\"\nstruct DefaultDictBase{K,V,F,D} <: AbstractDict{K,V}\n    default::F\n    d::D\n    passkey::Bool\n\n    check_D(D,K,V) = (D <: AbstractDict{K,V}) ||\n        throw(ArgumentError(\"Default dict must be <: AbstractDict{$K,$V}\"))\n\n    DefaultDictBase{K,V,F,D}(x::F, kv::AbstractArray{Tuple{K,V}}; passkey=false) where {K,V,F,D} =\n        (check_D(D,K,V); new{K,V,F,D}(x, D(kv), passkey))\n    DefaultDictBase{K,V,F,D}(x::F, ps::Pair{K,V}...; passkey=false) where {K,V,F,D} =\n        (check_D(D,K,V); new{K,V,F,D}(x, D(ps...), passkey))\n\n    DefaultDictBase{K,V,F,D}(x::F, d::D; passkey=d.passkey) where {K,V,F,D<:DefaultDictBase} =\n        (check_D(D,K,V); DefaultDictBase(x, d.d; passkey=passkey))\n    DefaultDictBase{K,V,F,D}(x::F, d::D = D(); passkey=false) where {K,V,F,D} =\n        (check_D(D,K,V); new{K,V,F,D}(x, d, passkey))\nend\n\n# Constructors\n\nDefaultDictBase(; kwargs...) = throw(ArgumentError(\"no default specified\"))\nDefaultDictBase(k, v; kwargs...) = throw(ArgumentError(\"no default specified\"))\n\n# syntax entry points\nDefaultDictBase(default::F; kwargs...) where {F} = DefaultDictBase{Any,Any,F,Dict{Any,Any}}(default; kwargs...)\nDefaultDictBase(default::F, kv::AbstractArray{Tuple{K,V}}; kwargs...) where {K,V,F} = DefaultDictBase{K,V,F,Dict{K,V}}(default, kv; kwargs...)\nDefaultDictBase(default::F, ps::Pair{K,V}...; kwargs...) where {K,V,F} = DefaultDictBase{K,V,F,Dict{K,V}}(default, ps...; kwargs...)\nDefaultDictBase(default::F, d::D; kwargs...) where {F,D<:AbstractDict} = (K=keytype(d); V=valtype(d); DefaultDictBase{K,V,F,D}(default, d; kwargs...))\n\n# Constructor for DefaultDictBase{Int,Float64}(0.0)\nDefaultDictBase{K,V}(default::F; kwargs...) where {K,V,F} = DefaultDictBase{K,V,F,Dict{K,V}}(default; kwargs...)\n\n# Functions\n\n# most functions are simply delegated to the wrapped dictionary\n@delegate DefaultDictBase.d [ Base.get, Base.haskey, Base.getkey, Base.pop!,\n                              Base.iterate, Base.isempty, Base.length ]\n\n# Some functions are delegated, but then need to return the main dictionary\n# NOTE: push! is not included below, because the fallback version just\n#       calls setindex!\n@delegate_return_parent DefaultDictBase.d [ Base.delete!, Base.empty!, Base.setindex!, Base.sizehint! ]\n\n\"\"\"\n    empty(d::DefaultDictBase)\n\nCreate an empty DefaultDictBase with the same default and passkey settings.\n\"\"\"\nBase.empty(d::DefaultDictBase{K,V,F}) where {K,V,F} = DefaultDictBase{K,V,F}(d.default; passkey=d.passkey)\n\n\"\"\"\n    getindex(d::DefaultDictBase, key)\n\nReturn the value for `key` if it exists, otherwise return and store the default value.\n\nFor non-callable defaults, returns the constant value.\nFor callable defaults, calls the function and stores the result.\n\"\"\"\nBase.getindex(d::DefaultDictBase, key) = get!(d.d, key, d.default)\n\nfunction Base.getindex(d::DefaultDictBase{K,V,F}, key) where {K,V,F<:Base.Callable}\n    if d.passkey\n        return get!(d.d, key) do\n            d.default(key)\n        end\n    else\n        return get!(d.d, key) do\n            d.default()\n        end\n    end\nend\n\n\n################\n\n# Here begins the actual definition of the DefaultDict and\n# DefaultOrderedDict classes.  As noted above, these are simply\n# wrappers around a DefaultDictBase object, and delegate all functions\n# to that object\n\nfor _Dict in [:Dict, :OrderedDict]\n    DefaultDict = Symbol(\"Default\"*string(_Dict))\n    @eval begin\n        \"\"\"\n            $($DefaultDict)(default, pairs...; passkey=false)\n            $($DefaultDict)(default, d::AbstractDict; passkey=false)\n            $($DefaultDict){K, V}(default, pairs...; passkey=false)\n            $($DefaultDict){K, V}(default, dict::AbstractDict; passkey=false)\n\n        Construct an $($(_Dict == :Dict ? \"un\" : \"\"))ordered dictionary with \"default on miss\" behavior.\n        When accessing a missing key, the dictionary returns (and stores) either the constant\n        `default` value (if non-callable) or the result of calling the callable `default`.\n\n        If the `default` is a `Function` or `Type`, it is called on retrieval of a missing key\n        with either zero arguments (if `passkey==false`) or with the requested key (if `passkey==true`).\n\n        # Examples\n        ```julia\n        # Counting pattern with constant default\n        counter = $($DefaultDict)(0)\n        for ch in \"banana\"\n            counter[ch] += 1\n        end\n        # counter['b'] == 1, counter['a'] == 3, counter['n'] == 2\n\n        # Grouping items with fresh container per key\n        groups = $($DefaultDict)(() -> Int[])\n        for (k, v) in [(\"a\", 1), (\"a\", 2), (\"b\", 3)]\n            push!(groups[k], v)\n        end\n        # groups[\"a\"] == [1, 2], groups[\"b\"] == [3]\n\n        # Using type constructors as callable defaults\n        dd = $($DefaultDict)(Vector{String})\n        push!(dd[:colors], \"red\")\n        push!(dd[:colors], \"blue\")\n        # dd[:colors] == [\"red\", \"blue\"]\n\n        # passkey=false: default function called with no arguments\n        dd1 = $($DefaultDict)(() -> \"default\", passkey=false)\n        dd1[\"anything\"]  # returns \"default\"\n\n        # passkey=true: default function receives the missing key\n        dd2 = $($DefaultDict)(k -> \"Key '\\$k' not found\", passkey=true)\n        dd2[\"missing\"]  # returns \"Key 'missing' not found\"\n        dd2[\"other\"]    # returns \"Key 'other' not found\"\n\n        # Initialize with specified types\n        dd = $($DefaultDict){String,Int}(0)\n        dd[\"a\"] = 1\n        dd[\"b\"]  # returns 0\n\n        # Create from existing dictionary\n        base = Dict(\"a\" => 1, \"b\" => 2)\n        dd = $($DefaultDict)(0, base)\n        dd[\"c\"]  # returns 0\n        ```\n        \"\"\"\n        struct $DefaultDict{K,V,F} <: AbstractDict{K,V}\n            d::DefaultDictBase{K,V,F,$_Dict{K,V}}\n\n            $DefaultDict{K,V,F}(x, ps::Pair{K,V}...; kwargs...) where {K,V,F} =\n                new{K,V,F}(DefaultDictBase{K,V,F,$_Dict{K,V}}(x, ps...; kwargs...))\n            $DefaultDict{K,V,F}(x, kv::AbstractArray{Tuple{K,V}}; kwargs...) where {K,V,F} =\n                new{K,V,F}(DefaultDictBase{K,V,F,$_Dict{K,V}}(x, kv; kwargs...))\n            $DefaultDict{K,V,F}(x, d::$DefaultDict) where {K,V,F} = $DefaultDict(x, d.d)\n            $DefaultDict{K,V,F}(x, d::$_Dict; kwargs...) where {K,V,F} =\n                new{K,V,F}(DefaultDictBase{K,V,F,$_Dict{K,V}}(x, d; kwargs...))\n            $DefaultDict{K,V,F}(x; kwargs...) where {K,V,F} =\n                new{K,V,F}(DefaultDictBase{K,V,F,$_Dict{K,V}}(x; kwargs...))\n        end\n\n        ## Constructors\n\n        $DefaultDict() = throw(ArgumentError(\"$DefaultDict: no default specified\"))\n        $DefaultDict(k,v) = throw(ArgumentError(\"$DefaultDict: no default specified\"))\n\n        # syntax entry points\n        $DefaultDict(default::F; kwargs...) where {F} = $DefaultDict{Any,Any,F}(default; kwargs...)\n        $DefaultDict(default::F, kv::AbstractArray{Tuple{K,V}}; kwargs...) where {K,V,F} = $DefaultDict{K,V,F}(default, kv; kwargs...)\n        $DefaultDict(default::F, ps::Pair{K,V}...; kwargs...) where {K,V,F} = $DefaultDict{K,V,F}(default, ps...; kwargs...)\n\n        $DefaultDict(default::F, d::AbstractDict; kwargs...) where {F} = ((K,V)= (Base.keytype(d), Base.valtype(d)); $DefaultDict{K,V,F}(default, $_Dict(d); kwargs...))\n\n        # Constructor syntax: DefaultDictBase{Int,Float64}(default)\n        $DefaultDict{K,V}(; kwargs...) where {K,V} = throw(ArgumentError(\"$DefaultDict: no default specified\"))\n        $DefaultDict{K,V}(default::F, pairs...; kwargs...) where {K,V,F} = $DefaultDict{K,V,F}(default, $_Dict{K,V}(pairs...); kwargs...)\n        $DefaultDict{K,V}(default::F, d::AbstractDict; kwargs...) where {K,V,F} = $DefaultDict{K,V,F}(default, $_Dict{K,V}(d); kwargs...)\n\n        ## Functions\n\n        # Most functions are simply delegated to the wrapped DefaultDictBase object\n        @delegate $DefaultDict.d [ Base.getindex, Base.get, Base.get!, Base.haskey,\n                                   Base.getkey, Base.pop!, Base.iterate,\n                                   Base.isempty, Base.length ]\n\n        # Some functions are delegated, but then need to return the main dictionary\n        # NOTE: push! is not included below, because the fallback version just\n        #       calls setindex!\n        @delegate_return_parent $DefaultDict.d [ Base.delete!, Base.empty!, Base.setindex!, Base.sizehint! ]\n\n        \"\"\"\n            push!(d::$($DefaultDict), p::Pair)\n            push!(d::$($DefaultDict), p::Pair...)\n\n        Insert one or more key-value pairs into the dictionary `d`.\n\n        # Examples\n        ```jldoctest\n        julia> d = $($DefaultDict)(0)\n        julia> push!(d, \"a\" => 1, \"b\" => 2)\n        julia> d[\"a\"]\n        1\n        ```\n        \"\"\"\n        # NOTE: The second and third definition of push! below are only\n        # necessary for disambiguating with the fourth, fifth, and sixth\n        # definitions of push! below.\n        # If these are removed, the second and third definitions can be\n        # removed as well.\n        Base.push!(d::$DefaultDict, p::Pair) = (setindex!(d.d, p.second, p.first); d)\n        Base.push!(d::$DefaultDict, p::Pair, q::Pair) = push!(push!(d, p), q)\n        Base.push!(d::$DefaultDict, p::Pair, q::Pair, r::Pair...) = push!(push!(push!(d, p), q), r...)\n\n        Base.push!(d::$DefaultDict, p) = (setindex!(d.d, p[2], p[1]); d)\n        Base.push!(d::$DefaultDict, p, q) = push!(push!(d, p), q)\n        Base.push!(d::$DefaultDict, p, q, r...) = push!(push!(push!(d, p), q), r...)\n\n        \"\"\"\n            empty(d::$($DefaultDict))\n\n        Return an empty $($DefaultDict) with the same default value and type parameters.\n        \"\"\"\n        Base.empty(d::$DefaultDict{K,V,F}) where {K,V,F} = $DefaultDict{K,V,F}(d.d.default)\n        \"\"\"\n            in(key, keys::Base.KeySet{K,$($DefaultDict){K}})\n\n        Check if `key` is present in the key set of a $($DefaultDict).\n        \"\"\"\n        Base.in(key, v::Base.KeySet{K,T}) where {K,T<:$DefaultDict{K}} = key in keys(v.dict.d.d)\n    end\nend\n\nOrderedCollections.isordered(::Type{T}) where {T<:DefaultOrderedDict} = true\n\n## This should be uncommented to provide a DefaultSortedDict\n\n# struct DefaultSortedDict{K,V,F} <: AbstractDict{K,V}\n#     d::DefaultDictBase{K,V,F,SortedDict{K,V}}\n\n#     DefaultSortedDict(x, kv::AbstractArray{(K,V)}) = new(DefaultDictBase{K,V,F,SortedDict{K,V}}(x, kv))\n#     DefaultSortedDict(x, d::DefaultSortedDict) = DefaultSortedDict(x, d.d)\n#     DefaultSortedDict(x, d::SortedDict) = new(DefaultDictBase{K,V,F,SortedDict{K,V}}(x, d))\n#     DefaultSortedDict(x) = new(DefaultDictBase{K,V,F,SortedDict{K,V}}(x))\n#     DefaultSortedDict(x, ks, vs) = new(DefaultDictBase{K,V,F,SortedDict{K,V}}(x,ks,vs))\n# end\n\n## Constructors\n\n# DefaultSortedDict() = throw(ArgumentError(\"DefaultSortedDict: no default specified\"))\n# DefaultSortedDict(k,v) = throw(ArgumentError(\"DefaultSortedDict: no default specified\"))\n\n# # TODO: these mimic similar Dict constructors, but may not be needed\n# DefaultSortedDict{K,V,F}(default::F, ks::AbstractArray{K}, vs::AbstractArray{V}) = DefaultSortedDict{K,V,F}(default,ks,vs)\n# DefaultSortedDict{F}(default::F,ks,vs) = DefaultSortedDict{Any,Any,F}(default, ks, vs)\n\n# # syntax entry points\n# DefaultSortedDict{F}(default::F) = DefaultSortedDict{Any,Any,F}(default)\n# DefaultSortedDict{K,V,F}(::Type{K}, ::Type{V}, default::F) = DefaultSortedDict{K,V,F}(default)\n# DefaultSortedDict{K,V,F}(default::F, kv::AbstractArray{(K,V)}) = DefaultSortedDict{K,V,F}(default, kv)\n\n# DefaultSortedDict{F}(default::F, d::AbstractDict) = ((K,V)=eltype(d); DefaultSortedDict{K,V,F}(default, SortedDict(d)))\n\n## Functions\n\n## Most functions are simply delegated to the wrapped DefaultDictBase object\n\n# @delegate DefaultSortedDict.d [ getindex, get, get!, haskey,\n#                                 getkey, pop!, start, next,\n#                                 done, isempty, length]\n# @delegate_return_parent DefaultSortedDict.d [ delete!, empty!, setindex!, sizehint! ]\n\n# similar{K,V,F}(d::DefaultSortedDict{K,V,F}) = DefaultSortedDict{K,V,F}(d.d.default)\n# in{T<:DefaultSortedDict}(key, v::Base.KeySet{T}) = key in keys(v.dict.d.d)\n"}, "source_files_changed": ["src/default_dict.jl"], "test_files_changed": [], "lines_changed": 7, "is_valid": false, "validation_errors": ["Low action confidence: 0.1", "Could not infer action type"]}
